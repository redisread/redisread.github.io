[{"content":"c文件读写🗃\nFILE对象结构体 1 2 3 4 5 6 7 8  typedef struct { int _fd; // 文件号  int _cleft; // 缓冲区中剩下的字节数  int _mode; // 文件操作模式  char * _nextc; // 下一个字节的位置  char * _buff; // 文件缓冲区位置 }FILE;   打开文件 可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：\n1  FILE *fopen( const char * filename, const char * mode );   mode 的值可以是r,w,a,,r+,w+,a+:\n   r 打开一个已有的文本文件，允许读取文件。     w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。   a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。   r+ 打开一个文本文件，允许读写文件。   w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。   a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。    如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：\n1  \u0026#34;rb\u0026#34;, \u0026#34;wb\u0026#34;, \u0026#34;ab\u0026#34;, \u0026#34;rb+\u0026#34;, \u0026#34;r+b\u0026#34;, \u0026#34;wb+\u0026#34;, \u0026#34;w+b\u0026#34;, \u0026#34;ab+\u0026#34;, \u0026#34;a+b\u0026#34;     关闭文件 关闭文件非常简单,只需要调用**fclose()**函数即可,其中参数就是指向文件对象的指针.\n1  int fclose( FILE *fp );   如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。  demo 1 2 3 4 5 6 7 8 9 10 11 12 13  void open_close_file(){ char fname[10]; printf(\u0026#34;pease input file name: \u0026#34;); scanf(\u0026#34;%s\u0026#34;,fname); FILE *p = fopen(fname,\u0026#34;r+\u0026#34;); if(p == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return ; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;,fname); fclose(p); printf(\u0026#34;file %s had be closed!\\n\u0026#34;,fname); }   读取文件 读取单个字符的最简单的函数:\n1  int fgetc( FILE * fp );   读取多个字符的函数(也可以读取单个字符):\n1  char *fgets( char *buf, int n, FILE *fp );   fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。\n函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。\n 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void read_file_demo() { char fname[10] = \u0026#34;basic.sql\u0026#34;; FILE *fp = fopen(fname, \u0026#34;r+\u0026#34;); if (fp == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;, fname); char ch; int n = 5; printf(\u0026#34;\\nusing fgetc()......\\n\u0026#34;); while (n--) { ch = fgetc(fp); if(ch != EOF) printf(\u0026#34;char = %c\\n\u0026#34;, ch); } char str[20]; printf(\u0026#34;\\nusing fgets()......\\n\u0026#34;); fgets(str,20,fp); printf(\u0026#34;str[20] = %s\\n\u0026#34;,str); fclose(fp); printf(\u0026#34;file %s had be closed!\\n\u0026#34;, fname); }   读取二进制输入:\n1  size_t fread(void *buffer, size_t size, size_t count, FILE * stream);    buffer为接收数据的地址，size为一个单元的大小，count为单元个数，stream为文件流。\n返回实际读取的单元个数。如果小于count，则可能文件结束或读取出错；可以用ferror()检测是否读取出错，用feof()函数检测是否到达文件结尾。如果size或count为0，则返回0。\n 写入文件 写入单个字符的最简单的函数:\n1  int fputc( int c, FILE *fp );   写入多个字符的函数(也可以写入单个字符):\n1  int fputs( const char *s, FILE *fp );   函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。\n函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。\n 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void write_file_demo() { char fname[10] = \u0026#34;test.txt\u0026#34;; FILE *fp = fopen(fname, \u0026#34;w+\u0026#34;); if (fp == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;, fname); char ch; int n = 5; printf(\u0026#34;\\nusing fputc()......\\n\u0026#34;); while (n--) { ch = (char)(100+n); if((ch = fputc(ch,fp)) != EOF) printf(\u0026#34;char %c write successful!\\n\u0026#34;,ch); } char str[30] = \u0026#34;\\nIt`s a test for write!\u0026#34;; printf(\u0026#34;\\nusing fputs()......\\n\u0026#34;); int r = fputs(str,fp); if(r \u0026gt;= 0) printf(\u0026#34;str[30] = %s write successful!\\n\u0026#34;,str); fclose(fp); printf(\u0026#34;file %s had be closed!\\n\u0026#34;, fname); }   二进制输出:\n1  size_t fwrite(void * buffer, size_t size, size_t count, FILE * stream);    buffer为数据源地址，size为每个单元的字节数，count为单元个数，stream为文件流指针。\n返回成功写入的单元个数。如果小于count，则说明发生了错误，文件流错误标志位将被设置，随后可以通过ferror()函数判断。\n 参考:\n https://www.runoob.com/cprogramming/c-file-io.html ","description":"","id":0,"section":"posts","tags":["C","文件读写"],"title":"C文件读写","uri":"https://vhope.cf/zh/posts/c-read-write/"},{"content":"在markdown文件中嵌入html代码.🛶\n使用自定义文字样式 输入代码:\n1  \u0026lt;span style=\u0026#34;font-size:2rem; background:yellow;\u0026#34;\u0026gt;**Bigger**\u0026lt;/span\u0026gt;   Bigger\n设置键盘按键 输入代码:\n1  \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;F9\u0026lt;/kbd\u0026gt;   Ctrl+F9\n其他网站摘录的html 1  \u0026lt;blockquote class=\u0026#34;twitter-tweet\u0026#34;\u0026gt;\u0026lt;p lang=\u0026#34;en\u0026#34; dir=\u0026#34;ltr\u0026#34;\u0026gt;Sunsets don\u0026amp;#39;t get much better than this one over \u0026lt;a href=\u0026#34;https://twitter.com/GrandTetonNPS?ref_src=twsrc%5Etfw\u0026#34;\u0026gt;@GrandTetonNPS\u0026lt;/a\u0026gt;. \u0026lt;a href=\u0026#34;https://twitter.com/hashtag/nature?src=hash\u0026amp;amp;ref_src=twsrc%5Etfw\u0026#34;\u0026gt;#nature\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://twitter.com/hashtag/sunset?src=hash\u0026amp;amp;ref_src=twsrc%5Etfw\u0026#34;\u0026gt;#sunset\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;http://t.co/YuKy2rcjyU\u0026#34;\u0026gt;pic.twitter.com/YuKy2rcjyU\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026amp;mdash; US Department of the Interior (@Interior) \u0026lt;a href=\u0026#34;https://twitter.com/Interior/status/463440424141459456?ref_src=twsrc%5Etfw\u0026#34;\u0026gt;May 5, 2014\u0026lt;/a\u0026gt;\u0026lt;/blockquote\u0026gt; \u0026lt;script async src=\u0026#34;https://platform.twitter.com/widgets.js\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   Sunsets don\u0026#39;t get much better than this one over @GrandTetonNPS. #nature #sunset pic.twitter.com/YuKy2rcjyU\n\u0026mdash; US Department of the Interior (@Interior) May 5, 2014 ","description":"","id":1,"section":"posts","tags":["markdown","html"],"title":"在markdown使用html","uri":"https://vhope.cf/zh/posts/markdown-html/"},{"content":"TCP/IP编程\n  目标:  能进行网络编程\n1.如果你说你会select,epoll,iocp模型,那会让对方觉得更靠谱\n2.如果你说出你做过im,下载之类那会让对方来兴趣.\n3.如果你说设计了通讯协议,会让对方觉得更贴切\n4.如果你说做过,熟悉, ftp http snmp smtp 这些简单的老古董协议,会加分,但不大.\n5.如果你说熟悉bt,emule,udt等协议,那会对你很有好感.\n6.如果你说你破解过某大牌 qq,360内某通讯协议,那会对你加分很大.\n阶段:\n1)熟悉TCP/IP协议族的基本原理\nIP地址的分类，定义，获得，大概的管理方法\nTCP、UDP等主要协议的特点，主要格式，以及重要字段在协议交互中起到的作用。\n2）对于简单的TCP/IP协议导致的问题，有基本的判断\n熟悉网络问题的解决方法，一个问题，应该是由上而下（top-button），还是由下而上（button-top）来分析？\n3）基本的编程知识。\n在系统内，构建简单通信。\n在系统间，构建简单的通信。\n熟悉系统内的API，知道在什么时候，改使用哪些API协调工作。\n能够熟练使用这些API，在系统间传递信息，文件。\n能够熟练使用这些API，实现自己的简单的私有协议。\n4）进阶编程知识\n知道一两个已经封装好的框架（framwork），它们之间的差别。\n使用一个框架，写过能正常工作的程序。\n知道网络协议处理也是要讲究性能的，知道性能的瓶颈会在什么地方产生。\n能有较好的设计技巧，将私有协议设计得更加具有弹性，优雅。\n熟悉系统间协议处理的细微的差异，以及将会对业务造成的影响，时延、状态不一致、自定义字段、、、、、\n5）熟练阶段的知识\n针对业务的需求，快速选型，定框架。\n不再认为多线程是万能的。\n知道稳定性比性能更加重要。\n数据包去了哪儿，不用看代码，也能预估出来。\n6）源代码是最好的老师，永远都是。\n以上，差不多或者已经达到4）的时候，就是“熟悉”了。\n  网络模型 OSI模型 TCP/IP模型 示例 协议对应 数据封装 C++UDP/TCP实例 套接字 为了区分不同应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP交互提供了称为**嵌套字(Socket)**的接口。\n常用的TCP/IP有以下三种类型的嵌套字：\n  流式嵌套字（SOCK_STREAM）\n用于提供面向连接的、可靠的数据传输服务，即使用TCP进行传输。\n  数据报嵌套字（SOCK_DGRAM）\n用于提供无连接的服务，即使用UDP进行传输。\n  原始嵌套字（SOCK_RAW\n可以读写内核没有处理的IP数据报，而流式嵌套字只能读取TCP的数据，数据报嵌套字只能读取UDP的数据.\n   如果要访问其它协议发送的数据必须使用原始嵌套字，它允许对底层协议(如IP或ICMP)直接访问\n 端口对应进程 单单之后ip地址还不足以辨识通信的两个进程,因为操作系统是并发的,使用端口来辨认某个进程.所以套接字必须的两个信息为: ip地址 + 端口,例如: 192.168.1.4 1500\n参考:\n https://www.jianshu.com/p/c1015f5ffa74 进程间通信 https://segmentfault.com/a/1190000003063859 Linux IO模式及 select、poll、epoll详解 https://cloud.tencent.com/developer/article/1373483 各种IO复用模式之select，poll，epoll，kqueue，iocp分析 ","description":"","id":2,"section":"posts","tags":["tcp","udp","网络"],"title":"Udp-Tcp编程","uri":"https://vhope.cf/zh/posts/udp-tcp/"},{"content":"每次push都需要输入用户名和密码,其实可以免去这些操作.🚛\n1. 使用.git-credentials文件 在git项目目录下新建.git-credentials这个文件,然后在里面填写下面内容(大括号不用填写):\nhttps://{username}:{password}@github.com 然后在git项目目录执行:\n1  git config --global credential.helper store   执行此命令后，用户主目录下的.gitconfig文件会多了一项：[credential]\nhelper = store  注意: Linux用户主目录一般在~/下,而Windows下一般为C:\\users\\Administrator\n 这样以后push就不需要用户名和密码了\n2. 使用ssh协议 首先生成密钥对,执行\n1  ssh-keygen -t rsa -C \u0026#34;youremail\u0026#34;   接下来按照提示操作，默认可以一路往下。\n然后将生成的位于~/.ssh/的id_rsa.pub的内容复制到你github setting里的ssh key中。\n复制之后，如果你还没有克隆你的仓库，那你直接使用ssh协议用法：git@github.com:yourusername/yourrepositoryname克隆就行了。\n如果已经使用https协议克隆了，那么按照如下方法更改协议：\ngit remote set-url origin git@github.com:yourusername/yourrepositoryname.git\nDone!\n3. 管理多git账号 参考:\n https://www.jianshu.com/p/f7f4142a1556 简书 https://segmentfault.com/a/1190000012432367 https://juejin.im/post/5d6a23d45188252bd90f601a 掘金 https://www.cnblogs.com/popfisher/p/5731232.html ","description":"","id":3,"section":"posts","tags":["git","github"],"title":"Git免密push","uri":"https://vhope.cf/zh/posts/git-push-no-pw/"},{"content":"AES算法是继DES之后比较快且比较简单的加密算法.⚖\nAES算法 算法原理： AES密码与分组密码Rijndael基本上完全一致，Rijndael分组大小和密钥大小都可以为128位、192位和256位。然而AES只要求分组大小为128位，因此只有分组长度为128Bit的Rijndael才称为AES算法。\n下面是分组长度为128位的AES算法,而key位数可以是128/192/256,本次实验选择key的大小位128位.\n特点  明文分组被描述为一个字节方阵并复制到状态数组，在每轮替换和移位时都并行处理整个状态分组。 矩阵中字节的顺序是按列排序的，例如128比特的明文分组的前4个字节占输入矩阵的第一列，接下来的4个字节占第二列，依次类推。扩展子密钥数组也类似操作。 假设AES使用128比特的密钥，其密钥被描述为一个字节方阵并将扩展成为一个子密钥数组w[i]（具有44个32比特字），4个不同的字（共128比特）用作每轮的轮密钥。 AES在每轮运算中将进行4个不同的步骤，1个是移位，3个是替换。  数学知识 在AES算法中的MixColumn层中会用到伽罗瓦域中的乘法运算，而伽罗瓦域的运算涉及一些数学知识。\n素域 有限域有时也称伽罗瓦域，它指的是由有限个元素组成的集合，在这个集合内可以执行加、减、乘和逆运算。而在密码编码学中，我们只研究拥有有限个元素的域，也就是有限域。域中包含元素的个数称为域的阶。只有当m是一个素数幂时，即$m=p^n$(其中n为正整数是p的次数，p为素数)，阶为m的域才存在。p称为这个有限域的特征。\n例如，有限域中元素的个数可以是11(p=11是一个素数,n=1)、可以是81(p=3是一个素数，n=4)、也可以是256(p=2是一个素数，n=8)\u0026hellip;..但有限域的中不可能拥有12个元素，因为12=2·2·3，因此12也不是一个素数幂。因此满足p是一个素数且满足$m = p^n$这个公式，m才是一个素数幂。\n有限域中最直观的例子就是阶为素数的域，即n=1的域。域GF(p)的元素可以用整数0、1、\u0026hellip;、p-1l来表示。域的两种操作就是模整数加法和整数乘法模p。加上p是一个素数，整数环Z表示为GF(p)，也成为拥有素数个元素的素数域或者伽罗瓦域。GF(p)中所有的非零元素都存在逆元，GF(p)内所有的运算都是模p实现的。\n素域内的算数运算规则如下  加法和乘法都是通过模p实现的； 任何一个元素a的加法逆元都是由a+(a的逆元)=0 mod p得到的； 任何一个非零元素a的乘法逆元定义为a·a的逆元=1。  举个例子，在素域GF(5)={0、1、2、3、4}中，2的加法逆元为3，这是因为2+(3)=5，5mod5=0,所以2+3=5mod5=0。2的乘法逆元为3，这是因为2·3=6，6mod5=1，所以2·3=6mod5=1。(在很多地方a的加法逆元1用$-a$表示，a的乘法逆元2用$1/a$表示)\n 注：GF(2)是一个非常重要的素域，也是存在的最小的有限域，由于GF(2)的加法，即模2加法与异或(XOR)门等价，GF(2)的乘法与逻辑与(AND)门等价，所以GF(2)对AES非常重要。\n模2加法与异或(XOR)门等价:\n$$\n(1 + 0) \\mod 2 = 1\\\\\n(0 + 1) \\mod 2 = 1\\\\\n(0 + 0) \\mod 2 = 0\\\\\n(1 + 1) \\mod 2 = 0\\\\\n$$\n乘法与逻辑与(AND)门等价:\n$$\n(1 \\times 0) \\mod 2 = 0\\\\\n(0 \\times 1) \\mod 2 = 0\\\\\n(0 \\times 0) \\mod 2 = 0\\\\\n(1 \\times 1) \\mod 2 = 1\\\\\n$$\n 扩展域 如果有限域的阶不是素数，则这样的有限域内的加法和乘法运算就不能用模整数加法和整数乘法模p表示。而且m\u0026gt;1的域被称为扩展域，为了处理扩展域，我们就要使用不同的符号表示扩展域内的元素，使用不同的规则执行扩展域内元素的算术运算。\n在扩展域$GF(2^m)$中，元素并不是用整数表示的，而是用系数为域$GF(2)$中元素的多项式表示。这个多项式最大的度(幂)为m-1​，所以每个元素共有m个系数，在AES算法使用的域$GF(2^8)$中，每个元素$A∈GF(2^8)$都可以表示为：\n$$\nA(x) = a_7x^7 + a_6x^6 + a_5x^5 + a_4x^4 + a_3x^3 + a_2x^2+a_1x + a_0,x_i \\in GF(2) = 0,1\n$$\n注意：在域GF(2^8)中这样的多项式共有256个，这256个多项式组成的集合就是扩展域GF(2^8)。每个多项式都可以按一个8位项链的数值形式存储：\n$$\nA = (a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0)\n$$\n像$x^7$、$x^6$等因子都无需存储，因为从位的位置就可以清楚地判断出每个系数对应的幂。\n扩展域$GF(2^m)$内的加减法 在AES算法中的密钥加法层中就使用了这部分的知识，但是不是很明显，因为我们通常把扩展域中的加法当作异或运算进行处理了，因为在扩展域中的加减法处理都是在底层域GF(2)内完成的，与按位异或运算等价。假设$A(x)$、$B(x)∈GF(2^m)$，计算两个元素之和的方法就是：\n$$\nC(x) = A(x) + B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i + b_i) \\mod 2\n$$\n而两个元素之差的计算公式就是：\n$$\nC(x) = A(x) - B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i - b_i) \\mod 2 = (a_i + b_i) \\mod 2\n$$\n 注：在减法运算中减号之所以变成加号，这就和二进制减法的性质有关了，大家可以试着验算下。从上述两个公式中我们发现在扩展域中加法和减法等价，并且与XOR等价(异或运算也被称作二进制加法)。\n 扩展域GF(2^m)内的乘法 扩展域的乘法主要运用在AES算法的列混淆层(Mix Column)中，也是列混淆层中最重要的操作。我们项要将扩展域中的两个元素用多项式形式展开，然后使用标准的多项式乘法规则将两个多项式相乘：\nAES步骤详解 AES算法主要有四种操作处理，分别是密钥加法层(也叫轮密钥加，英文Add Round Key)、字节代换层(SubByte)、行位移层(Shift Rows)、列混淆层(Mix Column)。而明文x和密钥k都是由16个字节组成的数据(当然密钥还支持192位和256位的长度)，它是按照字节的先后顺序从上到下、从左到右进行排列的。而加密出的密文读取顺序也是按照这个顺序读取的，相当于将数组还原成字符串的模样了，然后再解密的时候又是按照4·4数组处理的。AES算法在处理的轮数上只有最后一轮操作与前面的轮处理上有些许不同(最后一轮只是少了列混淆处理)，在轮处理开始前还单独进行了一次轮密钥加的处理。在处理轮数上，只考虑128位密钥的10轮处理。\n其中字节排列方式需要按照如下转换:\nAES算法流程图如下:\n实现步骤及代码 按照AES流程图,对每一层的代码进行实现.\n密钥加法层 在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。在扩展域中加减法操作和异或运算等价，所以这里的处理也就异常的简单了，只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n如下图：\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4 * 4], word k[4]) { for (int i = 0; i \u0026lt; 4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i + 4] = mtx[i + 4] ^ byte(k2.to_ulong()); mtx[i + 8] = mtx[i + 8] ^ byte(k3.to_ulong()); mtx[i + 12] = mtx[i + 12] ^ byte(k4.to_ulong()); } }   AES密钥生成 首先定义位置变换函数RotWord(),作用是接受一个字 $[a0, a1, a2, a3] $作为输入，循环左移一个字节后输出$ [a1, a2, a3, a0]$,代码如下:\n1 2 3 4 5 6  word RotWord(const word \u0026amp;w) { word result(0x0); result = (w \u0026lt;\u0026lt; 8) | (w \u0026gt;\u0026gt; 24); return result; }   定义S盒变换函数SubWord()，接受一个字 $[a0, a1, a2, a3]$ 作为输入，然后每一个byte，例如a0，前四个字节为行，后四个字节为列，从S_Box中查找并且返回四个元素。，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  word SubWord(const word\u0026amp; sw) { word temp; for(int i=0; i\u0026lt;32; i+=8) { int row = sw[i+7]*8 + sw[i+6]*4 + sw[i+5]*2 + sw[i+4]; int col = sw[i+3]*8 + sw[i+2]*4 + sw[i+1]*2 + sw[i]; byte val = S_Box[row][col]; for(int j=0; j\u0026lt;8; ++j) temp[i+j] = val[j]; } return temp; }   轮常数Rcon[]作为一个常量数组，每一轮生成密钥的时候需要作为参数异或\n1 2 3  // 轮常数，密钥扩展中用到。（AES-128只需要10轮） word Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};   密钥拓展函数KeyExpansion(),接受一个参数为外部密钥，另外一个为需要拓展的轮密钥数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1),Nr为轮数 void KeyExpansion(byte key[4 * N_key], word w[4 * (N_round + 1)]) { word temp; int i = 0; while (i \u0026lt; N_key)\t//前四个word就是输入的key  { w[i] = ToWord(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); ++i; } i = N_key; while (i \u0026lt; 4 * (N_round + 1)) { temp = w[i - 1]; //记录前一个word  if (i % N_key == 0) { //temp先位置表换RotWord，再S盒变换，然后与轮常数异或，最后w[i-N_key] 异或  w[i] = w[i - N_key] ^ SubWord(RotWord(temp)) ^ Rcon[i / N_key - 1]; } else { w[i] = w[i - N_key] ^ temp; } i++; } }   字节替换层 S盒字节替换，主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，读取S_box数据的方法就是要将输入数据的每个字节的高四位作为第一个下标，第四位作为第二个下标。然后返回数据，字节替换主要是为了扰乱数据。\nS盒：\n逆S盒：\n图解如下：\n正向S盒变换代码如下：\n1 2 3 4 5 6 7 8 9 10  //S盒变换 - 前4位为行号，后4位为列号 void SubBytes(byte mtx[4 * 4]) { for (int i = 0; i \u0026lt; 16; ++i) { int row = mtx[i][7] * 8 + mtx[i][6] * 4 + mtx[i][5] * 2 + mtx[i][4]; int col = mtx[i][3] * 8 + mtx[i][2] * 4 + mtx[i][1] * 2 + mtx[i][0]; mtx[i] = S_Box[row][col]; } }   反向S盒变换代码如下:\n1 2 3 4 5 6 7 8 9 10  // 逆S盒变换 void InvSubBytes(byte mtx[4*4]) { for(int i=0; i\u0026lt;16; ++i) { int row = mtx[i][7]*8 + mtx[i][6]*4 + mtx[i][5]*2 + mtx[i][4]; int col = mtx[i][3]*8 + mtx[i][2]*4 + mtx[i][1]*2 + mtx[i][0]; mtx[i] = Inv_S_Box[row][col]; } }   行移位层 将输入数据作为一个$4·4$的字节矩阵进行处理，然后将这个矩阵的字节进行位置上的置换。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在$4·4$矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。最终结束。\n正向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //正向行变换 - 按字节循环移位 void ShiftRows(byte mtx[4 * 4]) { // 第二行循环左移一位  byte temp = mtx[4]; for (int i = 0; i \u0026lt; 3; ++i) mtx[i + 4] = mtx[i + 5]; mtx[7] = temp; // 第三行循环左移两位  for (int i = 0; i \u0026lt; 2; ++i) { temp = mtx[i + 8]; mtx[i + 8] = mtx[i + 10]; mtx[i + 10] = temp; } // 第四行循环左移三位  temp = mtx[15]; for (int i = 3; i \u0026gt; 0; --i) mtx[i + 12] = mtx[i + 11]; mtx[12] = temp; }   反向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 逆行变换 - 以字节为单位循环右移 void InvShiftRows(byte mtx[4*4]) { // 第二行循环右移一位 \tbyte temp = mtx[7]; for(int i=3; i\u0026gt;0; --i) mtx[i+4] = mtx[i+3]; mtx[4] = temp; // 第三行循环右移两位 \tfor(int i=0; i\u0026lt;2; ++i) { temp = mtx[i+8]; mtx[i+8] = mtx[i+10]; mtx[i+10] = temp; } // 第四行循环右移三位 \ttemp = mtx[12]; for(int i=0; i\u0026lt;3; ++i) mtx[i+12] = mtx[i+13]; mtx[15] = temp; }   列混淆层 列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。\n在加密的正向列混淆中，我们要将输入的$4·4$矩阵左乘一个给定的$4·4$矩阵。而它们之间的加法、乘法都在扩展域$GF(2^8)$中进行，,在矩阵相乘计算中，出现了加法和乘法，而前面提到了在拓展域中加法等同于异或运算，而对于乘法，需要特殊的方式进行处理，于是将+号换成^号，然后将伽罗瓦域的乘法定义成一个有两个参数的函数，并让他返回最后计算结果，最后列混淆代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //正向列变换 void MixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x02, arr[0]) ^ GFMul(0x03, arr[1]) ^ arr[2] ^ arr[3]; mtx[i+4] = arr[0] ^ GFMul(0x02, arr[1]) ^ GFMul(0x03, arr[2]) ^ arr[3]; mtx[i+8] = arr[0] ^ arr[1] ^ GFMul(0x02, arr[2]) ^ GFMul(0x03, arr[3]); mtx[i+12] = GFMul(0x03, arr[0]) ^ arr[1] ^ arr[2] ^ GFMul(0x02, arr[3]); } }   在解密的逆向列混淆中与正向列混淆的不同之处在于使用的左乘矩阵不同，它与正向列混淆的左乘矩阵互为逆矩阵，也就是说，数据矩阵同时左乘这两个矩阵后，数据矩阵不会发生任何变化。下面是图解：\n正向混淆处理：\n逆向混淆处理：\n反向列变换代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //反向列混淆 void InvMixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]); mtx[i+4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]); mtx[i+8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]); mtx[i+12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]); } }   密钥加法层 这一层主要是明文矩阵盒子密钥矩阵进行异或操作,在密钥加法层中有两个输入的参数，分别是明文和子密钥，而且这两个输入都是128位的。只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4*4], word k[4]) { for(int i=0; i\u0026lt;4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i+4] = mtx[i+4] ^ byte(k2.to_ulong()); mtx[i+8] = mtx[i+8] ^ byte(k3.to_ulong()); mtx[i+12] = mtx[i+12] ^ byte(k4.to_ulong()); } }   实现加密函数 加密函数按照流程图,首先开始是先进行一次轮密钥加,然后开始9轮的字节替换+行移位+列混淆+轮密钥加的操作,循环之后再做一次字节替换+行移位+轮密钥加就完成加密操作了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void encrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); for(int round=1; round\u0026lt;N_round; ++round) { SubBytes(in); ShiftRows(in); MixColumns(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); } SubBytes(in); ShiftRows(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); }   实现解密函数 解密函数与加密差不多,只不过将行移位变成反向行移位,列混淆变成反向列混淆,字节替换变成逆字节替换即可.\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void decrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); for(int round=N_round-1; round\u0026gt;0; --round) { InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); InvMixColumns(in); } InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); }   测试加密解密函数 可以发现上面面的测试中明文与解密之后的明文是完全正确的,说明加密函数与解密函数正确!\n测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  void Aes_test() { byte key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}; byte plain[16] = {0x32, 0x88, 0x31, 0xe0, 0x43, 0x5a, 0x31, 0x37, 0xf6, 0x30, 0x98, 0x07, 0xa8, 0x8d, 0xa2, 0x34}; // 输出密钥  cout \u0026lt;\u0026lt; \u0026#34;Key is : \u0026#34;; for (int i = 0; i \u0026lt; 16; ++i) cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; key[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; cout \u0026lt;\u0026lt; endl; word w[4 * (N_round + 1)]; KeyExpansion(key, w); // 输出待加密的明文  cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;the plaintext to encrypy:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 加密，输出密文  encrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;cipher : \u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 解密，输出明文  decrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;plain arter decrypt:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; }   实现加解密文件 加密文件函数,返回加密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  string encryptFile(string oname, string suffix, word w[4 * (N_round + 1)]) { string outputfilename = oname + \u0026#34;_cipher.bin\u0026#34;; bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining encrypy...........\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); // 将文件加密到 oname + cipher.bin 中  ifstream in; ofstream out; in.open(oname + suffix, ios::binary); //输入文件  out.open(outputfilename, ios::binary); //输出加密文件  while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); encrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0  } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;encrypy finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;encrypy cost time : \u0026#34; \u0026lt;\u0026lt; (end - start) \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; //返回加密之后的文件 }   解密文件函数,返回解密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  string decryptFile(string filename, string oname, string suffix, word w[4 * (N_round + 1)]) { ifstream in; ofstream out; in.open(filename, ios::binary); string outputfilename = oname + \u0026#34;_decrypt\u0026#34; + suffix; out.open(outputfilename, ios::binary); bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining decrypt............\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); decrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0  } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;decrypt finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;decrypt cost time : \u0026#34; \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; }   实现效果:\n加密txt文件:\n加密jpg文件:\n加密mp3文件:\n加密doc文件:\nAES五种加密模式 实现五种加密方式的密钥是一个置换表unsigned char Table[4] = {0x12, 0xb1, 0x53, 0x28};,加密函数是原文与密钥的异或.\nECB模式(电子密码本模式) 加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。\nECB模式由于每块数据的加密是独立的因此加密和解密都可以并行计算，ECB模式最大的缺点是相同的明文块会被加密成相同的密文块，这种方法在某些环境下不能提供严格的数据保密性。\n流程图如下:\n实现代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //电子密码本模式,分组大小为4 unsigned char* ECB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for(int j = 0;j \u0026lt; groupSize;++j) temp[j] = plain[count++]; //加密  encrypt(temp,groupSize); for(int j = i*4;j \u0026lt; i*4 + 4;++j) cipher[j] = temp[j - i * 4]; } return cipher;//返回密文 }   解密方法也是让密文与密钥进行异或即可,实现效果如下:\nCBC模式(分组链接模式) CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。\n可用公式总结为:\n$$\nC_i = E_K(P_i XOR C_{i-1}) \\\nC_{-1} = IV\n$$\n流程图如下:\nCBC模式相比ECB有更高的保密性，但由于对每个数据块的加密依赖与前一个数据块的加密所以加密无法并行。与ECB一样在加密前需要对数据进行填充，不是很适合对流数据进行加密。\n代码如下:\n加密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //CCB加密函数 unsigned char *CCB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = plain[count++]; //加密  for (int j = 0; j \u0026lt; groupSize; ++j) //先与初始向量异或  temp[i] ^= C[i]; encrypt(temp, groupSize); //加密  for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { cipher[j] = temp[j - i * 4]; C[j - i * 4] = temp[j - i * 4];//设置新向量  } } return cipher; }   解密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //CCB解密函数 unsigned char *dCCB(unsigned char *cipher, int N) { int gNum = N / groupSize; //分组数量  //明文  unsigned char *plain = new unsigned char[N]; //设置初始向量  unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = cipher[count++]; //解密  encrypt(temp, groupSize); //先解密  for (int j = 0; j \u0026lt; groupSize; ++j) //然后与初始向量异或  temp[i] ^= C[i]; for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { plain[j] = temp[j - i * 4]; C[j - i * 4] = cipher[j];//设置新向量  } } return plain; }   实现效果:\nCFB模式(密文反馈模式) 与前面的模式不同,CFB模式可以将消息被当成是比特流.可以总结为如下的公式:\n$$\nC_i = P_i XOR E_K(C_{i-1})\\\nC_{-1} = IV\n$$\n流程图如下:\n加密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  //密文反馈模式,加密函数 unsigned char *CFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文,大小为2  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; gsize;++j){ temp[j] ^= C[j]; S[j] = temp[j]; //获取密文的2bit  } //设置密文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; }   解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  //密文反馈解密 unsigned char *dCFB(unsigned char *cipher, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //明文  unsigned char *plain = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组密文  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = cipher[count++]; //解密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; 2;++j){ S[j] = temp[j]; temp[j] = C[j] ^ temp[j]; } //设置明文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { plain[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j+gsize] = S[j]; } } return plain; }   实现效果:\nOFB模式(输出反馈模式) OFB是先用块加密器生成密钥流（Keystream），然后再将密钥流与明文流异或得到密文流，解密是先用块加密器生成密钥流，再将密钥流与密文流异或得到明文，由于异或操作的对称性所以加密和解密的流程是完全一样的。\nOFB与CFB一样都非常适合对流数据的加密，OFB由于加密和解密都依赖与前一段数据，所以加密和解密都不能并行。\n流程图如下:\n加密解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  //输出反馈模式,加密解密函数相同 unsigned char *OFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xee, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; 2;++j){ S[j] = C[j]; //取向量加密后的前两位  temp[j] ^= C[j]; } //设置密文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; }   实现效果:\nCTR模式(计数器模式) 类型于CFB，但是加密每个计数值，而不是任何反馈值,对每个明文分组，必须有不同的密钥和计数值 (从不重复使用),,可以用如下公式表示:\n$$\nO_i = E_K(i)\\\nC_i = P_i XOR O_i\n$$\n计数器模式流程图如下:\n计数器模式加密函数与解密函数一样,代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  //计数器模式,加密函数 unsigned char *CTR(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; //设置随机值  unsigned char Counter[groupSize*groupSize] = {0x44, 0xa9, 0x5d, 0x99, 0xe5, 0xf1, 0x3d, 0x91, 0x16, 0xa6, 0xe1, 0x33, 0x22, 0xdd, 0xab, 0x1f}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; //明文分组  unsigned char C[groupSize]; //分组随机值  for (int j = 0; j \u0026lt; groupSize; ++j) { temp[j] = plain[count++]; C[j] = Counter[i*4+j]; } //加迷  //首先加密随机值C  encrypt(C, groupSize); //然后与明文进行异或  for(int j = 0;j \u0026lt; groupSize;++j) temp[j] ^= C[j]; //设置密文  for(int j = i*groupSize;j \u0026lt; i*groupSize+groupSize;j++) cipher[j] = temp[j-i*groupSize]; } return cipher; }   实现效果如下:\n参考:\n https://www.cnblogs.com/RabbitHu/p/bitset.html bitset用法 https://blog.csdn.net/liushu1231/article/details/8844631 bitset的空间大小 http://c.biancheng.net/cpp/html/2834.html 文件处理 https://bbs.pediy.com/thread-253884.htm AES算法带图解 https://blog.csdn.net/lisonglisonglisong/article/details/41909813 AES算法 CSDN https://blog.csdn.net/sinat_23338865/article/details/72869841 AES五种加密模式   设“+”为一个交换性的二元运算，即对于所有x,y，x+y=y+x。若该集内存在一个元素0，使得对于所有x，x+0=0+x=x，则此元素是唯一的。如果对于一个给定的x，存在一个x'使得x+x'=x'+x=0，则称x'是x的加法逆元。 \u0026#x21a9;\u0026#xfe0e;\n 乘法逆元，是指数学领域群G中任意一个元素a，都在G中有唯一的逆元a‘，具有性质a×a'=a'×a=e，其中e为该群的单位元。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":4,"section":"posts","tags":["AES","密码学","加密"],"title":"Aes-高级加密标准","uri":"https://vhope.cf/zh/posts/aes/"},{"content":"简单地说，云计算就是计算服务的提供（包括服务器、存储、数据库、网络、软件、分析和智能）- 通过 Internet（云）提供快速创新、弹性资源和规模经济。对于云服务，通常你只需使用多少支付多少，从而帮助降低运营成本，使基础设施更有效地运行，并能根据业务需求的变化调整对服务的使用。\n行云趣码记录 行云趣码官网：http://mart.cloudtogo.cn/\nLinux服务器 生成自己的服务器 进入应用商店，选择需要的Linux服务器，这里选择CentOS\n点击部署，等待生成自己的服务器\n发布成功\n参数解释 点击访问，会跳出访问地址，部署区域以及提示信息，一步一步看。\n访问地址\n部署区域\n部署区域没什么好说的，就是这个服务器部署的区域。\n详情\n从上面给的信息，可以归为如下：\n  ssh远程访问的地址为2c56369b3c95a919.c.cloudtogo.cn，端口为34920(注意：端口不是22)。远程登陆的用户名为：root，密码为：123456.\n  有五个映射端口，他们的对应关系如下：\n   Linux内部 外部访问     8001 34921(预留a端口)   8002 34916(预留b端口)   8003 34917(预留c端口)   8004 34918(预留d端口)   8005 34924(预留e端口)    也就是说，当我们在Linux内部启用8001-8005这五个端口运行相应的应用时，我们可以访问对应的外部预留端口以及子域名进行访问测试。\n例如在Linux内运行了一个web应用在8001端口，我们可以在浏览器访问61823a63ab19b300.c.cloudtogo.cn:34921\n  ssh远程连接：\n查看配置 查看CPU型号: Intel(R) Xeon(R) CPU E5-2680 v3\n1  cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c   查看物理CPU个数: 2\n1  cat /proc/cpuinfo | grep \u0026#34;physical id\u0026#34; | sort | uniq|wc -l   查看逻辑CPU的个数: 8个\n1  cat /proc/cpuinfo | grep \u0026#34;processor\u0026#34; |wc -l   查看CPU是几核: 4核\n1  cat /proc/cpuinfo | grep \u0026#34;cores\u0026#34;|uniq   设置远程访问jupyter 安装完jupyter之后，输入以下命令生成配置文件：\n1  jupyter notebook --generate-config   参考：\nhttps://www.jianshu.com/p/960f011f712e\nhttps://zhuanlan.zhihu.com/p/64524822\n结果：\n添加虚拟环境：https://ofooo.github.io/wiki/python/%E5%B7%A5%E5%85%B7/jupyter-notebook/\n更换pip源：https://www.linuxidc.com/Linux/2019-04/158178.htm\n部署nodejs：https://blog.csdn.net/xerysherryx/article/details/78920978\nnpm镜像：https://www.cnblogs.com/alps/p/12439387.html\nCentOS基本命令 查看服务进程\n1 2 3  [victor@mylove ~]$ ps -aux|grep mysql victor 23477 0.0 0.0 110656 2688 pts/3 S+ 12:26 0:00 grep --color=auto mysql   查看进程端口\n1  netstat -anp |grep 1506   查看端口进程\n1  netstat -lnp|grep 3306   关闭进程\n1  kill –9 1506   生产应用 使用docker生产自己的应用 开发网页App 进入应用工厂,打开一个Blank的模板继续,然后再设计页面拖入一个代码组件,如下:\n输入名字为webpy,应为使用的是web.py框架进行编写,然后点击下一步.\n然后输入存放代码的地址,代码需要编写完成之后存到GitHub上,程序默认的运行入口时main.py,在运行main.py之前,还会执行pip install -r requirements.txt这个代码,所以我们可以将所需要的依赖包都写在requirements.txt这个文件中.\n我的代码地址: https://github.com/redisread/webpy.git\n编写组件向导,有许多参数\n其他的参数作用:\n 环境变量: 存储系统的相关需要运行的程序的位置 多副本: 多副本设置支持可以使用弹性伸缩功能,可开启可不开启 会话保持: 维持客户端与一台服务器的连接,即对于某个客户端,,不会更换与他进行连接的服务器 执行命令: 可以执行Linux的相关命令 存储路径: 可以设置存储到数据卷中,填写的Linux的位置就是数据卷存放的位置 root权限: 是否开启root权限 服务名称: 就是服务的名称 读取指定文件: **0 日志文件: 填写日志文件存放的的地方 映射配置文件: 可以映射(相当于替换)配置文件,例如nginx的nginx.conf文件. 健康检查: 特权模式: 资源限制: 限制CPUy以及内存的设置  最后点击完成就可以发发布应用了\n发布一般不需要配置什么,需要的话可以自行设置.\n发布成功!\n访问该地址就能够访问我们写的应用了.\n运维管理 在发布页的侧边栏有一个运维按钮,点击进入运维界面\n如下就是可以进行查看的相关信息\n","description":"","id":5,"section":"posts","tags":["云计算","行云趣码"],"title":"行云开发","uri":"https://vhope.cf/zh/posts/xingyun-begin/"},{"content":"集万滴雨水，成一条江河🌊🌊\nRedis  REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。\nRedis是一个开源的使用ANSI C语言编写、遵守BSD协议1、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n  开源界的 5 大许可协议：五大开源许可协议分别是GPL,LGPL,BSD,MIT,Apache。\n 存储类型：\n String: 字符串 Hash: 散列 List: 列表 Set: 集合 Sorted Set: 有序集合  三个特点：\n Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式2的数据备份。  Redis与其他key-value存储有什么不同？\n Redis有着更为复杂的数据结构并且提供对他们的原子性操作3，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。  安装 github链接：https://github.com/microsoftarchive/redis/releases\nRedis是C语言开发，安装Redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc。\n安装GCC 步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  ## 先安装 gcc 编译环境,如果已经安装, 请忽略 yum -y install gcc automake autoconf libtool make ## 下载 redis 源代码 wget http://download.redis.io/releases/redis-4.0.1.tar.gz ## 下载完成后,解压 tar zxvf redis-4.0.1.tar.gz ## 跳转到 redis 目录 cd redis-4.0.1 ## 编译 make ## 安装编译后的软件到 /usr/local/redis ## PREFIX必须大写,自动为我们创建redis目录，并将结果安装此目录 make PREFIX=/usr/local/redis install ## 查看安装的结果 cd /usr/local/redis/bin ls -l -rwxr-xr-x 1 root root 2451864 Mar 12 13:28 redis-benchmark -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-check-aof -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-check-rdb -rwxr-xr-x 1 root root 2606088 Mar 12 13:28 redis-cli lrwxrwxrwx 1 root root 12 Mar 12 13:28 redis-sentinel -\u0026gt; redis-server -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-server   配置  Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。\n redis.conf配置文件详解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  ## 指定包含其它的配置文件，可以多个Redis实例使用同一份配置文件，而各个实例又拥有自己的特定配置文件 include /path/to/local.conf ## 绑定的主机地址, 可以监听一个或多个, 如果为 127.0.0.1 只能本机才能访问 bind 127.0.0.1 ## Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no ## Redis以守护进程方式运行时,Redis默认会把 pid 写入 /var/run/redis.pid 文件,可以通过 pidfile 指定 pidfile /var/run/redis_6379.pid ## 指定Redis监听端口，默认端口为6379 port 6379 ## 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 0 ## 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose ## debug 会打印出很多信息，适用于开发和测试阶段 ## verbose 包含很多不太有用的信息，但比debug要清爽一些 ## notice 适用于生产模式 ## warning 警告信息（仅记录非常重要/重要的消息） loglevel verbose ## 日志记录方式，默认为标准输出 ## 如果 Redis 以守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout ## 设置数据库的数量，默认数据库为0，可以使用SELECT \u0026lt;dbid\u0026gt;命令在连接上指定数据库id databases 16 ## 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件(持久化)，可以多个条件配合 ## save \u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt; save 900 1 ## 900秒内有一个更新 save 300 10 ## 300秒内有10个更新 save 60 10000 ## 60秒内有10000个更新 ## 指定存储至本地数据库时是否压缩数据，默认为yes ## Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes ## 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb ## 也就是安装目录下我们看到的那个文件 ## 指定本地数据库存放目录 dir ./ ## 当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt; ## 当master服务设置了密码保护时，slav服务连接master的密码 masterauth \u0026lt;master-password\u0026gt; ## 设置Redis连接密码 ## 如果配置了连接密码，客户端在连接Redis时需要通过AUTH \u0026lt;password\u0026gt;命令提供密码，默认关闭 requirepass foobared ## 设置同一时间最大客户端连接数，默认无限制 ## Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数 ## 如果设置 maxclients 0，表示不作限制 ## 客户端连接数到达限制时,Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 128 ## Redis最大内存限制 ## Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key ## 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。 ## Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory \u0026lt;bytes\u0026gt; ## 指定是否在每次更新操作后进行日志记录, 默认为 no ## Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失 ## 因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中 appendonly no ## 指定更新日志文件名，默认为 appendonly.aof appendfilename appendonly.aof ## 指定更新日志条件 ## no : 表示等操作系统进行数据缓存同步到磁盘（快） ## always : 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） ## everysec : 表示每秒同步一次（折中，默认值） appendfsync everysec ## 指定是否启用虚拟内存机制，默认值为no ## VM机制将数据分页存放,将访问量较少的页即冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中 vm-enabled no ## 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap ## 将所有大于vm-max-memory的数据存入虚拟内存 ## 无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys), ## 也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 ## Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享 vm-page-size 32 ## 设置swap文件中的page数量 ## 由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的,在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 ## 设置访问swap文件的线程数,最好不要超过机器的核数, ## 如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 ## 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes ## 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 ## 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes   注意事项 我们查看了配置文件信息, 总结如下\n   如果你想要以加载配置文件的方式启动 Redis, 那么你需要使用 ./redis-server /path/to/redis.conf 命令启动 Redis 服务端.\n  内存设置大小单位\n   1k =\u0026gt; 1000 bytes 1kb =\u0026gt; 1024 bytes 1m =\u0026gt; 1000000 bytes 1mb =\u0026gt; 1024*1024 bytes 1g =\u0026gt; 1000000000 bytes 1gb =\u0026gt; 102410241024 bytes 1GB 1Gb 1gB 表达一样的意思, 单位不区分大小写    121321\n   基本操作 连接远程服务器：redis-cli -h host -p port -a password\n例如：$redis-cli -h 127.0.0.1 -p 6379 -a \u0026quot;mypass\u0026quot;\n键Key 与 Redis 键相关的基本命令：\n   序号 命令及描述     1 DEL key 该命令用于在 key 存在时删除 key。   2 DUMP key 序列化给定 key ，并返回被序列化的值。   3 EXISTS key 检查给定 key 是否存在。   4 EXPIRE key seconds 为给定 key 设置过期时间，以秒计。   5 EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。   6 PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。   7 PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计   8 KEYS pattern 查找所有符合给定模式( pattern)的 key 。   9 MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。   10 PERSIST key 移除 key 的过期时间，key 将持久保持。   11 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。   12 TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。   13 RANDOMKEY 从当前数据库中随机返回一个 key 。   14 RENAME key newkey 修改 key 的名称   15 RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。   16 TYPE key 返回 key 所储存的值的类型。    设置键值对 set key value 与取出键值对 get key\n删除键值使用del key\n字符串存储 Hash存储 之前变量没删除会报错\nRedis hash 是一个键值(key=\u0026gt;value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n每个 hash 可以存储 232 -1 键值对（40多亿）。\n列表存储 Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n展示：\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n集合存储 指令：sadd key member 向集合key添加元素。\n指令：smembers key，展示集合key中的元素：\n有序集合-zset 指令：zadd key score member ，向有序集合添加元素，并且设置相应的score。\n上面设置A且score为0，B且score为2，C且score为1.\n指令：zrangebyscore key l r,展示有序集合按score排序之后且在范围l到r的元素。\n显然元素已经按照score的顺序排列。\n 跟其他条款相比，从GNU通用公共许可证（GPL）到限制重重的著作权（Copyright），BSD许可证比较宽松，甚至跟公有领域更为接近。事实上，BSD许可证被认为是copycenter（中间著作权），介乎标准的copyright与GPL的copyleft之间。\u0026ldquo;Take it down to the copy center and make as many copies as you want\u0026rdquo;[1]。可以说，GPL强迫后续版本必须一样是自由软件，BSD的后续版本可以选择要继续是BSD或其他自由软件条款或封闭软件等等。 \u0026#x21a9;\u0026#xfe0e;\n 主从设备模式也叫做主仆模式英文简称为Master-Slave,核心思想是基于分而治之的思想,将一个原始任务分解为若干个语义等同的子任务,并由专门的工作者线程来并行执行这些任务,原始任务的结果是通过整合各个子任务的处理结果形成的 \u0026#x21a9;\u0026#xfe0e;\n 意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":6,"section":"posts","tags":["redis","分布式计算","云计算","数据库"],"title":"分布式-Redis","uri":"https://vhope.cf/zh/posts/redis/"},{"content":"走得慢的时候，为什么不跑呢？#️⃣\n哈希散列表 两个概念：\n散列表：\n散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。\n散列函数：\n散列函数，顾名思义，它是一个函数。如果把它定义成 hash(key) ，其中 key 表示元素的键值，则 hash(key) 的值表示经过散列函数计算得到的散列值。\n散列函数特点：\n 确定性 散列碰撞（collision） 不可逆性(一个哈希值对应无数个明文，理论上你并不知道哪个是。) 混淆特性  常见的散列函数：\n MD51 SHA-12  为什么哈希算法查找数组元素会更快？\n 原来使用下标进行匹配的画，会一个一个从一整个数组进行元素匹配，知道找到相等的元素才得到数组的信息。例如在Arr[20]查找值为12的,就需要从下标0到19进行查找。\n但是哈希散列表将一个一个按顺序的查找转换为使用计算的方式进行查找，将运算结果的下标映射成一个哈希表，实现了跳跃式的查找，从而效率更高。\n 问题:散列冲突\n 对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的散列冲突。\n 解决散列函数的两个方法：\n  链表法\n就是使用链表来保存冲突下标的数据，例如$12 % 5 = 2$和$7 % 5 = 2$,那么在下标为2的表下用一个链表存储12和7。\n  开放寻址法。\n常见三种方法：线性探测法、二次探测法、双散列\n假设哈希函数为：\n$$\nH(key) = key \\mod10\n$$\n线性探测法：\n还是$12 % 10 = 2 $和$22 % 10 = 2$这两个例子，当22这个数字需要存入哈希表时，发现已经有12这个元素存放在下标为2的哈希表上了，那么对Hash后的数字加一在进行Hash。即对7进行这样的操作：\n$$\nH((H(key)+1)) = ((22 \\mod 10) + 1) \\mod 10 = (2 + 1) \\mod 10 = 3\n$$\n但是这种方式的问题是冲突较多的时候会出现数据聚集在一个区域，这样不利于查询数据。\n二次探测法：\n二次探测法使用下面的函数解决冲突：\n$$\n(H(key) \\pm j^2) \\mod 10,j = 0,1,2\u0026hellip;\n$$\n这种方法较为复杂，而且虽然不会连续的聚集一片，但是会在多个间断的位置聚集。\n双散列：\n双散列，顾名思义就需要增加一个二级散列函数，例如$G(key) = q - (key \\mod q) q为素数且q\u0026lt;N$，发现冲突使用如下操作：\n$$\nH(key) + j * G(key),j = 0,1,2\u0026hellip;\u0026hellip;\n$$\n双散列方法有很多组合的方法，这里只是其中的一种，也有一些例如:$H(key) + G(key)$,没有j这个参数。\n  密码学中的哈希算法  hash（散列、杂凑）函数，是将任意长度的数据映射到有限长度的域上。直观解释起来，就是对一串数据m进行杂糅，输出另一段固定长度的数据h，作为这段数据的特征（指纹）。也就是说，无论数据块m有多大，其输出值h为固定长度。到底是什么原理？将m分成固定长度（如128位），依次进行hash运算，然后用不同的方法迭代即可（如前一块的hash值与后一块的hash值进行异或）。如果不够128位怎么办？用0补全或者用1补全随意，算法中约定好就可以了。\n 一般来说，公司不会直接将用户的密码保存在数据库中，而是保存经过哈希操作的密码得到的哈希值。这样，当哈希值被不法分子窃取，也不能还原出用户的密码；并且，公司只需要将用户输入的密码进行哈希操作，将哈希值与存储在数据库中的哈希值进行对比就能够验证用户了。\n哈希的其他用法 数据校验：\n  Git的- git commit id\n每次git提交后都有一个commit id，比如:\n19d02d2cc358e59b3d04f82677dbf3808ae4fc40\n  版权校验\n判断两个文件是不是一样的，对两个文件都进行哈希操作，得到哈希值，若哈希值相同，则两个文件为同一个文件。\n  大文件分块校验\n例如使用bt下载，在p2p网络中会把一个大文件拆分成很多小的数据各自传输。这样的好处是如果某个小的数据块在传输过程中损坏了，只要重新下载这个块就好。为了确保每一个小的数据块都是发布者自己传输的，我们可以对每一个小的数据块都进行一个hash的计算，维护一个hash List，在收到所有数据以后，我们对于这个hash List里的每一块进行遍历比对。这里有一个优化点是如果文件分块特别多的时候，如果遍历对比就会效率比较低。可以把所有分块的hash值组合成一个大的字符串，对于这个字符串再做一次Hash运算，得到最终的hash（Root hash）。在实际的校验中，我们只需要拿到了正确的Root hash，即可校验Hash List，也就可以校验每一个数据块了。\n  负载均衡：\n一致性hash的基本原理是将输入的值hash后，对结果的hash值进行2^32取模，这里和普通的hash取模算法不一样的点是在一致性hash算法里将取模的结果映射到一个环上。将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一个openid必定会被缓存到固定的服务器上，那么，当下次想要访问这个用户的数据时，只要再次使用相同的算法进行计算，即可算出这个用户的数据被缓存在哪个服务器上，直接去对应的服务器查找对应的数据即可。这里的逻辑其实和直接取模的是一样的。如下图所示：\n这部分不是很深入，之后再补充\u0026hellip;\u0026hellip;🚴\n参考链接：\n https://www.zhihu.com/question/26762707?sort=created-知乎 动画：什么是散列表？-五分钟算法 什么是 hash？-知乎   MD5 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 MD5 实现。 \u0026#x21a9;\u0026#xfe0e;\n SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":7,"section":"posts","tags":["Hash","Algorithm","md5","sha"],"title":"什么是Hash？","uri":"https://vhope.cf/zh/posts/hash/"},{"content":"排序是最基本的算法，里面包含了最基础的思想。一个简单的优化可以让排序快很多。\n$O(n^2)$的排序算法 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13  //冒泡排序 template \u0026lt;typename T\u0026gt; void bubbleSort(T *arr, int size) { for (int i = 0; i \u0026lt; size; ++i) { for (int j = 0; j \u0026lt; size - i - 1; ++j) { if (arr[j] \u0026gt; arr[j + 1]) swap(arr[j], arr[j + 1]); } } }   插入排序 ​\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; void insertSort(T *arr,int size) { for(int i = 0;i \u0026lt; size;++i) { int j; for(j = i;j \u0026gt; 0 \u0026amp;\u0026amp; arr[j] \u0026lt; arr[j-1];--j){swap(arr[j],arr[j-1]);} } }   选择排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14  //选择排序 复杂度O(n^2) template\u0026lt;typename T\u0026gt; void selectionSort(T *arr,int size) { int k; for(int i = 0;i \u0026lt; size-1; ++i) { k = i; for(int j = i+1;j \u0026lt; size;++j) if(arr[j] \u0026lt; arr[k]) k = j; if(k != i) mySwap(arr[k],arr[i]); } }   测试排序使用时间的时候，总是选择排序快于插入排序，按理说，插入排序应该比选择排序要快啊，因为插入排序可以提前终止循环，这是为什么呢？\n 原因是选择排序比较的是下标，而插入排序每一次比较都要交换，而交换所耗费的时间是高于简单的比较的。\n 插入排序优化-将交换变成赋值\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; void insertSort(T *arr,int size) { for(int i = 0;i \u0026lt; size;++i) { T e = arr[i]; int j; for(j = i;j \u0026gt; 0 \u0026amp;\u0026amp; arr[j-1] \u0026gt; e;--j){arr[j] = arr[j-1];} arr[j] = e; } }   运行时间明显变快了\n 对于近乎有序的数据来说，插入排序的速度要快很多，近乎$O (n)$。而插入排序的实际应用有很多，比如日志，日志的时间是近乎有序的，但是生成日志可能会出错，需要进行时间排序处理，这个时候使用插入排序会更好；还有银行的一些流水单等等\n 拓展： C++运算符重载\n 一般在类中实现，有两种可以实现的方法\n  运算符重载例子，使用在一个类中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Student { public: string name; int score; bool operator\u0026lt;(const Student \u0026amp;otherStudent) { return this-\u0026gt;score \u0026lt; otherStudent.score; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const Student \u0026amp;student) { os \u0026lt;\u0026lt; \u0026#34;Student:\u0026#34; \u0026lt;\u0026lt; student.name \u0026lt;\u0026lt; \u0026#34;\u0026#34;\u0026lt;\u0026lt;student.score\u0026lt;\u0026lt;endl; return os; } };      使用友元函数\n1 2 3 4 5 6 7 8  返回值类型 operator 运算符(形参表) { ... } //例Complex是一个复数类 friend Complex operator+(const Complex \u0026amp;c1,const Complex \u0026amp;c2){ return Complex(c1.i + c2.i,c1.j + c2.j); }     使用类里面的函数\n1 2 3 4 5 6 7 8  返回值类型 operator 运算符(形参表) { ... } //例Complex是一个复数类 Complex operator+(const Complex \u0026amp;complex){ return Complex(this-\u0026gt;i + complex.i,this-\u0026gt;j + complex.j); }     它们的区别就是参数的个数不同以及需不需要加上fridend这个关键字\n$O(n\\log (n))$的排序算法 归并排序 代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  template \u0026lt;typename T\u0026gt; void __merge(T *arr, int l, int middle, int r) { T aux[r - l + 1]; for (int i = l; i \u0026lt;= r; ++i) aux[i - l] = arr[i]; int i = l, j = middle + 1; for (int k = l; k \u0026lt;= r; ++k) { if (i \u0026gt; middle) { arr[k] = aux[j - l]; j++; } else if (j \u0026gt; r) { arr[k] = aux[i - l]; i++; } else if (aux[i - l] \u0026lt; aux[j - l]) { arr[k] = aux[i - l]; i++; } else { arr[k] = aux[j - l]; j++; } } } template \u0026lt;typename T\u0026gt; void __mergeSort(T *arr, int l, int r) { if (l \u0026gt;= r) return; int middle = (l + r) / 2; __mergeSort(arr, l, middle); __mergeSort(arr, middle+1, r); if(arr[middle] \u0026gt; arr[middle+1]) __merge(arr, l, middle, r); } //归并排序 template \u0026lt;typename T\u0026gt; void mergeSort(T *arr, int size) { __mergeSort(arr, 0, size - 1); }   下面这段代码的标记部分需要考虑溢出的问题\n 归并排序快是快，但是要耗费多一倍$O(n)$的存储空间，也就是使用空间换时间。\n 希尔排序 动画演示(来自@五分钟算法)：\n代码实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //希尔排序 template \u0026lt;typename T\u0026gt; void shellSort(T *arr, int size) { int dk[] = {5, 3, 1}; for (int index = 0; index \u0026lt; 3; ++index) { for (int i = 0; i \u0026lt; size / dk[index]; ++i) { int j; int e = arr[i]; for (j = i + dk[index]; j \u0026gt; dk[index] \u0026amp;\u0026amp; arr[j] \u0026gt; e; j -= dk[index]) { arr[j] = arr[j - dk[index]]; } arr[j] = e; } } }    希尔排序相当于是插入排序的升级版，增加了一个步长参数，使用希尔排序可以让零散的数据实现跳跃行的交换，最后逐渐将数组转化为有序，这样最后使用步长为1的插入排序就非常快了。\n 快速排序 被称为二十世纪影响最大的算法之一！\n动画演示(来自@五分钟算法)：\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  template\u0026lt;typename T\u0026gt; int __partition(T *arr,int l,int r){ T v = arr[l]; int j = l; for(int i = l+1;i \u0026lt;= r;++i){ if(arr[i] \u0026lt; v){ swap(arr[i],arr[++j]); } } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void __quickSort(T *arr,int l,int r) { if(l \u0026gt;= r) return; int p = __partition(arr,l,r); __quickSort(arr,l,p-1); __quickSort(arr,p+1,r); } //快速排序 template\u0026lt;typename T\u0026gt; void quickSort(T *arr,int size) { __quickSort(arr,0,size-1); }   优化一：\n在数组的元素个数小于15个的时候使用插入排序进行优化:\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; void __quickSort(T *arr,int l,int r) { + if(r - l \u0026lt;= 15) insertionSort(arr,l,r);  int p = __partition(arr,l,r); __quickSort(arr,l,p-1); __quickSort(arr,p+1,r); }   优化二：\n使用随机值作为划分标准\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  template\u0026lt;typename T\u0026gt; int __partition(T *arr,int l,int r){ + swap(arr[l],arr[rand() % (r-l+1) + l]);  T v = arr[l]; int j = l; for(int i = l+1;i \u0026lt;= r;++i){ if(arr[i] \u0026lt; v){ swap(arr[i],arr[++j]); } } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void quickSort(T *arr,int size) { + srand(time(NULL));  __quickSort(arr,0,size-1); }   缺点:\n 在近乎有序的数组排序中，快速排序的性能很差。时间复杂度也近乎$O(n^2 )$ 对于有很多重复元素的数组，快速排序的性能也很差  快速排序版本二：两路快排 使用两个下标分别处理大于v与小于v的部分。(v为基准元素)\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  template\u0026lt;typename T\u0026gt; int __partition2(T *arr,int l,int r){ swap(arr[l],arr[rand() % (r-l+1) + l]); T v = arr[l]; int i = l + 1,j = r; while(true) { while(arr[i] \u0026lt; v \u0026amp;\u0026amp; i \u0026lt;= r) ++i; while(arr[j] \u0026gt; v \u0026amp;\u0026amp; j \u0026gt;= l+1) --j; if(i \u0026gt; j) break; swap(arr[i++],arr[j--]); } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void __quickSort2(T *arr,int l,int r) { if(r - l\u0026lt;= 15){ insertSort(arr,l,r); return; } int p = __partition2(arr,l,r); __quickSort2(arr,l,p-1); __quickSort2(arr,p+1,r); } //快速排序版本二，双路快排 template\u0026lt;typename T\u0026gt; void quickSort2(T *arr,int size) { srand(time(NULL)); __quickSort2(arr,0,size-1); }   快速排序版本三：三路快排 使用三个下标分别处理大于v、等于v与小于v的部分。(v为基准元素)\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  template\u0026lt;typename T\u0026gt; void __quickSort3(T *arr,int l,int r) { if(r - l\u0026lt;= 15){ insertSort(arr,l,r); return; } swap(arr[l],arr[rand() % (r-l+1) + l]); T v = arr[l]; int lt = l; //arr[l+1...lt] \u0026lt; v  int gt = r + 1; //arr[gt...r] \u0026gt; v  int i = l+1; //arr[lt+1...i] == v  while(i \u0026lt; gt){ if(arr[i] \u0026lt; v){ swap(arr[i++],arr[++lt]); }else if(arr[i] \u0026gt; v){ swap(arr[i],arr[--gt]); }else{ i++; } } swap(arr[l],arr[lt]); __quickSort3(arr,l,lt-1); __quickSort3(arr,gt,r); } //快速排序版本三，三路快排 template\u0026lt;typename T\u0026gt; void quickSort3(T *arr,int size) { srand(time(NULL)); __quickSort3(arr,0,size-1); }   堆排序 基数排序 桶排序 排序算法总结 图片：\n未完待续\u0026hellip;\u0026hellip;🛴\n参考：\n https://www.cnblogs.com/onepixel/p/7674659.html https://github.com/MisterBooo/Article ","description":"","id":8,"section":"posts","tags":["算法","排序","C++"],"title":"排序算法总结","uri":"https://vhope.cf/zh/posts/algorithmstructure/sort/"},{"content":"机器学习有这些基本的算法组成，要门机器学习，就需要打个地基✒\nK近邻算法-KNN-(k-Nearest-Neighbors) 可以解决的问题:\n 分类问题 回归问题  预测一个人是天才还是白痴 首先先生成模拟数据，,x1和x2分别表示两个特征\nIQ值低的数据\n1 2 3  x1_low = np.random.random(10) + 3 x2_low = np.random.random(10) + 6 x1_low,y2_low   (array([3.72183336, 3.16146551, 3.88914234, 3.85673496, 3.1573191 , 3.4293751 , 3.96033808, 3.78793864, 3.94939642, 3.57378294]), array([6.47227974, 6.49537929, 6.98666118, 6.79440424, 6.99201224, 6.73386195, 6.63275792, 6.65411763, 6.42891099, 6.49695701])) IQ值高的数据\n1 2 3  x1_high = 4 + np.random.random(8) x2_high = 7 + np.random.random(8) x1_high,x2_high   (array([4.39543051, 4.73302502, 4.02667743, 4.46232039, 4.68128181, 4.92115752, 4.45267816, 4.84647668]), array([7.40538131, 7.3356809 , 7.90412483, 7.45237382, 7.15550294, 7.3764611 , 7.52492352, 7.67692014])) 总的数据和标签\n1 2 3 4 5 6  x1 = np.append(x1_low,x1_high) x2 = np.append(x2_low,x2_high) x_train = np.c_[x1.T,x2.T] print(x_train) y_train = np.append(np.zeros_like(x_low),np.ones_like(x_high)) print(y_train)   [[3.72183336 6.47227974] [3.16146551 6.49537929] [3.88914234 6.98666118] [3.85673496 6.79440424] [3.1573191 6.99201224] [3.4293751 6.73386195] [3.96033808 6.63275792] [3.78793864 6.65411763] [3.94939642 6.42891099] [3.57378294 6.49695701] [4.28739637 7.71057536] [4.31513454 7.70173516] [4.10934692 7.38111019] [4.35094666 7.33731866] [4.01739934 7.41472044] [4.98558165 7.72054925] [4.80075428 7.12604512] [4.48912715 7.08753069]] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1.] 绘制散点图\n1 2 3 4 5  plt.scatter(x_train[y_train==0,0],x_train[y_train==0,1]) plt.scatter(x_train[y_train==1,0],x_train[y_train==1,1]) plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;IQ\u0026#39;) plt.show()    上图红色表示天才，蓝色表示白痴\n 假设输入一个样本的数据为 (4.36,7.465)，判断它天才还是白痴\n1 2 3 4 5 6 7 8  example = np.array([4.36,7.456]) # 首先再图上画出来观察 plt.scatter(x_train[y_train==0,0],x_train[y_train==0,1]) plt.scatter(x_train[y_train==1,0],x_train[y_train==1,1]) plt.scatter(example[0],example[1],color=\u0026#39;black\u0026#39;) plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;IQ\u0026#39;) plt.show()    黑点表示输入的样本\n 获取距离列表\n1 2  distance = [sqrt(sum(((x-example)**2))) for x in x_train] distance   [1.172587826601725, 1.5359938425092403, 0.6648201732802982, 0.8312548678718089, 1.2890795094301544, 1.177941448784469, 0.9151268590623418, 0.9850226059672444, 1.1061225623709607, 1.2401212526176475, 0.2647260841097585, 0.24979727210937175, 0.26160170347749107, 0.1190261413334191, 0.3450785650776031, 0.6792191910080055, 0.5505765678982287, 0.39044007348145965] 对于KNN，假设k=3，就是求出与样本最近的三个点的数据\n1 2  result = np.argsort(distance) result[:k]   array([13, 11, 12], dtype=int64)  可以得知，前三个的训练样本的点的下标分别围殴13，11，12\n 接下来根据这三个训练样本的类别来预测输入的样本是天才还是白痴，假如这三个训练样本是天才的数量多于白痴，就认为它是天才；不然，就认为它是白痴\n1 2 3 4 5 6 7  from collections import Counter votes = Counter(r) y_hat = votes.most_common(1)[0][0] if y_hat == 1: print(\u0026#34;预测它为天才\u0026#34;) else: print(\u0026#34;预测它为白痴\u0026#34;)   预测它为天才 主成分分析法-PCA-(Principal Component Analysis)  PAC主要用于数据的降维\n 二维降到一维\n 由上面两个降维的图来看，第二张图片是一个更好的图，因为图二点和点的距离相对比较大，也就是说，点之间的区分度比较高\n 更好的降维方案\n 此时点和点之间的距离最大，区分度更大\n 那么如何定义样本之间的间距呢？\n可以使用方差(Variance),方差可以表示样本整体分布的疏密程度\n$$\nVar(x) = \\frac{1}{m}\\sum_{i = 1}^{m}(x_{i} - \\bar x)^2\n$$\n可以转化成：\n​\t希望找到一条轴，使得样本投影到该轴上的各点之间的方差最大\nPCA操作步骤：\n  将样例的均值归为0(demean)\n这样，就相当于坐标轴变成如下的图：\n  当均值$\\bar x = 0$时，原来的方差公式变为\n$$\nVar(x) = \\frac{1}{m}\\sum_{i = 1}^{m}(x_{i} - \\bar x)^2 \\Rightarrow Var(x) = \\frac{1}{m}\\sum_{i = 1}^{m}x_{i}^2\n$$\n假设两个维度的特征为$w1$,$w2$,那么需要求得的直线的方向为$w =（w_{1},w_{2}）$,映射到$w$后，有:\n$$\nVar(X_{project}) = \\frac{1}{m} \\sum_{1}^{m} (X_{project}^{(i)} - \\bar X{project})^2\n$$\n使得上面的公式最大\n其实最后的结果还是向量，因为$X$每一个点都包含两个元素，即应该是\n由均值为0，得到\n  计算过程\n目标即：\n与线性回归的不同：\n PCA的两个坐标轴表示的是两个特征，而线性回归的横轴是特征，纵轴是输出标记 PCA使得点之间的方差最大，而线性回归则是需要使得输出标记尽量拟合一条直线，是在纵轴上的  决策树 例子：\n数值特征例子：\n特点：\n 非参数学习算法 可以解决分类问题 天然的解决多分类问题 也可以解决回归问题 非常好的可解释性  问题：\n 每个节点在哪个维度作划分 某个维度的哪个值作划分    支持向量机-SVM-(Support Vector Machine) 主要思想：\nSVM分类:\n  Hard Margin SVM\t解决的是线性可分问题\n  Soft Margin SVM 可解决线性不可分问题\n  🤠未完待续\u0026hellip;\u0026hellip;\n","description":"机器学习必须掌握的基础算法，学会这些基础，对后面的理解才会透彻","id":9,"section":"posts","tags":["机器学习","SVM","决策树","kNN","PCA"],"title":"机器学习基本算法","uri":"https://vhope.cf/zh/posts/machine-learning-base/"},{"content":"一些英雄的图案🌿\n","description":"","id":10,"section":"gallery","tags":[""],"title":"Hero","uri":"https://vhope.cf/zh/gallery/hero/"},{"content":"使用Scrapy爬取文章的一个小项目..\nScrapy 框架图：\n抓取小程序社区文章 创建爬虫项目 创建项目（项目名为MyTest）\n1  scrapy startproject MyTest   创建爬虫🐞(先进入到MyTest目录)\n1  scrapy genspider -t crawl wx wxapp-union.com    wx为爬虫的名字，wxapp-union.com为爬取的域名，使用了模板crawl\n 定义爬取的数据结构 爬取的数据结构类继承Item类，在items.py文件中，如下是设置需要爬取的数据结构，其中包括:标题、作者、时间、访问者、前言、正文。\n1 2 3 4 5 6 7 8 9 10  from scrapy import Item,Field # 定义文章数据结构 class ArticleItem(Item): title = Field() author = Field() _time = Field() visitors = Field() pre_talk = Field() article_content = Field()   编写爬虫规则与解析规则  爬虫的爬取网页的链接的规则和解析页面的规则都是在新建的spider文件中的类中，也即在wx.py中\n 编写的spider类如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import scrapy from scrapy.linkextractors import LinkExtractor from scrapy.spiders import CrawlSpider, Rule from MyTest.items import ArticleItem class WxSpider(CrawlSpider): name = \u0026#39;wx\u0026#39; allowed_domains = [\u0026#39;wxapp-union.com\u0026#39;] start_urls = [\u0026#39;http://www.wxapp-union.com/portal.php?mod=list\u0026amp;catid=2\u0026amp;page=255\u0026#39;] rules = ( Rule(LinkExtractor(allow=r\u0026#39;.+mod=list\u0026amp;catid=2\u0026amp;page=\\d\u0026#39;), follow=True), Rule(LinkExtractor(allow=r\u0026#39;.+article-.+\\.html\u0026#39;),callback=\u0026#34;parse_item\u0026#34;,follow=False) ) def parse_item(self, response): title = response.xpath(\u0026#39;//h1[@class=\u0026#34;ph\u0026#34;]/text()\u0026#39;).get() author = response.xpath(\u0026#39;//p[@class=\u0026#34;authors\u0026#34;]//a\u0026#39;).get() _time = response.xpath(\u0026#39;//span[@class=\u0026#34;time\u0026#34;]/text()\u0026#39;).get() visitors = response.xpath(\u0026#39;//div[contains(@class,\u0026#34;focus_num\u0026#34;)]//a/text()\u0026#39;).get() pre_talk = response.xpath(\u0026#39;//div[@class=\u0026#34;blockquote\u0026#34;]//p/text()\u0026#39;).get() article_content = response.xpath(\u0026#39;//td[@id=\u0026#34;article_content\u0026#34;]\u0026#39;).get() item = ArticleItem(title=title,author=author,_time=_time,visitors=visitors,pre_talk=pre_talk,article_content=article_content) print(\u0026#39;*\u0026#39;*40) print(title) print(\u0026#39;*\u0026#39;*40) return item    首先rules定义了爬取链接规则，有两个规则，第一个规则是爬取页面的链接，每一页有多个文章的链接，而第二个规则则是定义爬取的具体文章内容的链接。 第一个规则需要Follow，因为需要根据每一页的内容查找文章的链接；而第二个规则是文章链接，故不需要继续Follow 第一个页面链接规则不需要回调函数，因为不需要解析，只需要获取文章链接；第二个文章链接规则则需要设置回调函数来对返回的文章网页内容进行解析。  parse_item说明：\n parse_item是解析页面返回内容的函数，其返回Item数据结构，使用Xpath分别获取数据结构各个元素的内容并且返回Item\n 保存数据  pipelines是一个最后处理Item的管道\n 在pipelines.py文件中新建pipleline对返回的Item进行处理，可以保存为文件，或者存储到数据库。\n首先文件中需要导入必要的库‘\n1 2 3 4 5  import re\t# 正则处理 from html2text import HTML2Text\t# 将网页转化为Markdown格式 from scrapy.exporters import JsonLinesItemExporter\t# 输出Json文件输出器 from urllib.parse import urljoin\t# 补全URL，因为有些URL只显示相对位置 import pymongo\t# MongoDB操作库   第一个Pipeline：保存到Json文件 程序的构造函数新建一个Json文件输出器，process_item进行数据的存储，关闭的时候close_spider会调用关闭文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 存储到Json文件中 class JsonPipeline(object): def __init__(self): self.f = open(\u0026#39;wxjc.json\u0026#39;,\u0026#39;wb\u0026#39;) self.exporter = JsonLinesItemExporter(self.f, ensure_ascii=False,encoding=\u0026#34;utf-8\u0026#34;) def process_item(self, item, spider): # 将内容转化为MarkDown格式 item[\u0026#39;article_content\u0026#39;] = convert_md(item[\u0026#39;article_content\u0026#39;]) self.exporter.export_item(item) return item def close_spider(self,spider): self.f.close()   第二个Pipeline：保存到Markdown文件 方法与第一发Pipeline类似，只是写文件使用最简单的追加方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 写入Markdown class MDPipeline(object): def __init__(self): self.f = open(\u0026#39;wx_teaches.md\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) def process_item(self,item,spider): if self.f: self.f.write(\u0026#39;\\n\u0026#39;) self.f.write(\u0026#34;# \u0026#34; + item[\u0026#39;title\u0026#39;] + \u0026#39;\\n\u0026#39;) header_info = \u0026#34;作者:{} 发布时间:{} Visitors:{}\\n\u0026#34;.format(item[\u0026#39;author\u0026#39;],item[\u0026#39;_time\u0026#39;],item[\u0026#39;visitors\u0026#39;]) self.f.write(header_info) self.f.write(\u0026#39;\u0026gt; \u0026#39; + item[\u0026#39;pre_talk\u0026#39;] + \u0026#39;\\n\u0026#39;) self.f.write(item[\u0026#39;article_content\u0026#39;]) return item def close_spider(self,spider): self.f.close()   第三个Pileline：保存到MongoDB 其中使用了类方法装饰器@classmethod,意思就是直接用类名调用该函数，就能够直接返回一个MongoPipeline类了，还定义了打开spider与关闭spider的操作，就是连接数据库与关闭数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 存储到MongoDB数据库 class MongoPipeline(object): def __init__(self,mongo_uri,mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls,crawler): return cls(mongo_uri = crawler.settings.get(\u0026#39;MONGO_URI\u0026#39;), mongo_db = crawler.settings.get(\u0026#39;MONGO_DB\u0026#39;)) def open_spider(self,spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db =self.client[self.mongo_db] def process_item(self,item,spider): name = item.__class__.__name__ # \u0026lt;a href=\\\u0026#34;space-uid-17761.html\\\u0026#34;\u0026gt;Rolan\u0026lt;/a\u0026gt;  item[\u0026#39;author\u0026#39;] = re.search(\u0026#39;\u0026lt;a.*?\u0026gt;(.*?)\u0026lt;/a\u0026gt;\u0026#39;,item[\u0026#39;author\u0026#39;]).group(1) self.db[name].insert(dict(item)) return item def close_spider(self,spider): self.client.close()    最后需要在settings.py中添加如下字段:\n1 2  MONGO_URI = \u0026#39;localhost\u0026#39; MONGO_DB = \u0026#39;WX\u0026#39;    最后需要在settings.py中添加如下字段 1 2 3 4 5 6 7 8 9  ITEM_PIPELINES = { \u0026#39;MyTest.pipelines.JsonPipeline\u0026#39;: 300, \u0026#39;MyTest.pipelines.MDPipeline\u0026#39;: 301, \u0026#39;MyTest.pipelines.MongoPipeline\u0026#39;: 400, } # 修改为False ROBOTSTXT_OBEY = False # 设置延迟1s DOWNLOAD_DELAY = 1   开始爬取 可以在项目目录中新建一个脚本start.py，文件内容如下，自动运行脚本\n1 2  from scrapy import cmdline cmdline.execute(\u0026#39;scrapy crawl test\u0026#39;.split(\u0026#39;\u0026#39;))   爬取结果 Json结果 Markdown结果 Markdown文件由于太大了使用Markdown文件打不开，只好使用文本编辑器打开\nMongoDB结果 ","description":"","id":11,"section":"posts","tags":["爬虫","Scrapy"],"title":"Scrapy框架","uri":"https://vhope.cf/zh/posts/spider/scrapy-1/"},{"content":"好的工具🗝 就成功了一半。\n工具🚡 创造与记录 GitBook 使用前提：  安装NodeJS 使用npm安装：npm install gitbook-cli -g(这是命令行工具)  GitNote GitMind GitMind 是一款全新的云端智能思维导图、流程图制作软件，同时支持在电脑、手机浏览器上使用。\n官网：https://gitmind.cn/\n微信版本：\nNotion Typora caliibre 信息聚合 irreader🔖 下载地址:http://irreader.fatecore.com/\n羽雀-云端知识库☁ 如果英语不好，或者看着英文的文档很烦恼，可以试试这个。🍃\n地址:https://www.yuque.com/\n图片   https://xinquji.com/r/d232a93deb8766\n  https://burst.shopify.com/\n ","description":"实用的工具集合","id":12,"section":"talks","tags":[""],"title":"Tools","uri":"https://vhope.cf/zh/talks/tools/"},{"content":"All about Intresting in Github.\nPython好玩的库 html2text  将网页转化为Markdown文件格式\n 使用前提： 1  pip install htmltotext   使用方法： 1 2 3  ## 转化为TEXT h = HTML2Text() text = h.handle(parse_html) # text为markdown文件   pypandoc  对文件进行任意的转换\n 使用前提： 安装pypandoc库：pip install pypandoc.\n使用方法 导入库:import pypandoc\nMarkdown \u0026mdash;\u0026ndash;\u0026gt; docx 1  output = pypandoc.convert_file(\u0026#39;somefile.md\u0026#39;, \u0026#39;docx\u0026#39;, outputfile=\u0026#34;somefile.docx\u0026#34;)   Markdown \u0026mdash;\u0026ndash;\u0026gt; Rst 1 2 3  output = pypandoc.convert_file(\u0026#39;somefile.md\u0026#39;, \u0026#39;rst\u0026#39;)\t# way1 output = pypandoc.convert_file(\u0026#39;somefile.txt\u0026#39;, \u0026#39;rst\u0026#39;, format=\u0026#39;md\u0026#39;)\t# way 2 output = pypandoc.convert_text(\u0026#39;#some title\u0026#39;, \u0026#39;rst\u0026#39;, format=\u0026#39;md\u0026#39;)\t# 直接转化文本    其中有对应的工具Pandoc\n 如何把 Markdown 文件批量转换为 PDF mdout转换脚本 项目地址:https://github.com/JabinGP/mdout\n使用方法：  打开项目地址查看，其中主要命令为:mdout filename -t pdf\n","description":"Github上好玩的那些库~","id":13,"section":"talks","tags":[""],"title":"Good库","uri":"https://vhope.cf/zh/talks/github-lib/"},{"content":"🚴一些收集视频的方法⚒\n视频归总方法 BiliBli视频嵌入代码 使用方法 首先找到嵌入代码\n然后复制代码到Markdown文件就可以得到如下显示效果：\n 代码如下: 1  \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=6731067\u0026amp;cid=10959711\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt;    其中可以在ifram中添加相关属性\n weibo上传的视频 使用方法 在微博中上传视频后，打开视频的页面，按F12打开工具,鼠标点击视频找到链接\n接下来直接在Markdown中添加代码\nYour browser does not support the video tag.\n代码如下:\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/03/02/GabXC4JmfN6H2hE.png\u0026#34; src=\u0026#34;https://f.video.weibocdn.com/00393mgEgx07BmNCEF4j01041200eeW00E010.mp4?label=mp4_720p\u0026amp;template=1280x720.25.0\u0026amp;trans_finger=721584770189073627c6ee9d880087b3\u0026amp;Expires=1583079687\u0026amp;ssig=%2BAmJANwAPn\u0026amp;KID=unistore,video\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   QQ空间发布的视频 使用方法 与微博的操作类似，打开视频页面，先点击下载按钮\n然后会自动跳转，搜索栏上的地址就是视频的地址\n接下来直接在Markdown中添加代码\nYour browser does not support the video tag.\n代码如下:\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/03/02/GabXC4JmfN6H2hE.png\u0026#34; src=\u0026#34;http://photovideo.photo.qq.com/1075_0b53zeiu6vidieapa3kya5pdbsiej6zqhfsa.f20.mp4?dis_k=97f710c26b204f7f2312614fbcf8f897\u0026amp;dis_t=1583082992\u0026amp;vuin=1427298682\u0026amp;save=1\u0026amp;d=1\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   ","description":"","id":14,"section":"posts","tags":["blog","视频","BliBli","weibo"],"title":"视频的收集","uri":"https://vhope.cf/zh/posts/settings/collect-videos/"},{"content":"在Pt页面增加了一些用JS实现的PPT，主要展示一些效果。🔌\n网页PPT 主题 beige black blood monokai league moon night serif simple solarized sky white 使用方法🌌 在markdown文件的ymal头部添加:revealTheme: serif\n在线制作PPT Slides https://slides.com/\n","description":"","id":15,"section":"posts","tags":["ppt","blog"],"title":"Slides和网页PPT","uri":"https://vhope.cf/zh/posts/settings/ppt-use/"},{"content":"数据分析，begin！📅\n Latex公式参考：\nhttps://www.cnblogs.com/1024th/p/11623258.html\n 概率分析\n中位数\n$$\n\\frac{df(x)}{dx}\\mid_{x_{mode}=0}\n$$\n​\n","description":"","id":18,"section":"posts","tags":["概率","Latex"],"title":"Data Analysis Begin","uri":"https://vhope.cf/zh/posts/bigdata/data-analysis-begin/"},{"content":"使用MXNet的好处你永远想象不到。🉑\n本地环境搭建教程  参考:\nhttps://discuss.gluon.ai/t/topic/13576?u=bigbigwolf-ai\n 范数 L0范数：指向量中非0元素的个数。（难优化求解）\nL1范数：指向量中各个元素的绝对值之和\nL2范数：指向量各元素的平方和然后求平方根\n设$n$维向量$x$中的元素为$x_1, \\ldots, x_n$。向量$x$的$L_{p}$范数为:\n$$\n|\\boldsymbol{x}|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.\n$$\n$L_{1}$范数：\n$$\n|\\boldsymbol{x}|_1 = \\sum_{i=1}^n \\left|x_i \\right|.\n$$\n$L_{2}$范数：\n$$\n|\\boldsymbol{x}|_2 = \\sqrt{\\sum_{i=1}^n x_i^2}.\n$$\n设$X$是一个$m$行$n$列矩阵。矩阵$X$的Frobenius范数为该矩阵元素平方和的平方根：\n$$\n|\\boldsymbol{X}|_F = \\sqrt{\\sum_{i=1}^m \\sum_{j=1}^n x_{ij}^2},\n$$\n查阅文档 1 2  from mxnet import nd print(dir(nd.random))   ['NDArray', '_Null', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_internal', '_random_helper', 'current_context', 'exponential', 'exponential_like', 'gamma', 'gamma_like', 'generalized_negative_binomial', 'generalized_negative_binomial_like', 'multinomial', 'negative_binomial', 'negative_binomial_like', 'normal', 'normal_like', 'numeric_types', 'poisson', 'poisson_like', 'randint', 'randn', 'shuffle', 'uniform', 'uniform_like']  help函数可以查询具体的函数作用及用法\n1  help(nd.ones_like)   Help on function ones_like: ones_like(data=None, out=None, name=None, **kwargs) Return an array of ones with the same shape and type as the input array. Examples:: x = [[ 0., 0., 0.], [ 0., 0., 0.]] ones_like(x) = [[ 1., 1., 1.], [ 1, 1., 1.]] Parameters ---------- data : NDArray The input out : NDArray, optional The output NDArray to hold the result. Returns ------- out : NDArray or list of NDArrays The output of this function.  线性回归 导入必要的库\n1 2 3 4 5  %matplotlib inline from IPython import display from matplotlib import pyplot as plt from mxnet import autograd, nd import random   生成数据集，其中每个例子输入数据个数为2，有1000个数据\n1 2 3 4 5 6 7  num_inputs = 2 num_examples = 1000 true_w = nd.array([2, -3.4]) true_b = nd.array([4.2]) features = nd.random.normal(scale=1, shape=(num_examples, num_inputs)) labels = nd.dot(true_w,features.T) + true_b labels += nd.random.normal(scale=0.01, shape=labels.shape)   查看数据\n1  features[0], labels[0]   ( [ 0.28752208 -0.04466231] \u0026lt;NDArray 2 @cpu(0)\u0026gt;, [4.927063] \u0026lt;NDArray 1 @cpu(0)\u0026gt;)  定义相关函数\n1 2 3 4 5 6 7 8 9 10 11  def use_svg_display(): # 用矢量图显示 display.set_matplotlib_formats(\u0026#39;svg\u0026#39;) def set_figsize(figsize=(3.5, 2.5)): use_svg_display() # 设置图的尺寸 plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = figsize set_figsize() plt.scatter(features[:, 1].asnumpy(), labels.asnumpy(), 1); # 加分号只显示图   data_iter函数作用:\n 扰乱读取顺序，使得读取随机 按Batch_size分段取数据，需要判断是否到结尾，使用yield构建生成器节省内存  1 2 3 4 5 6 7 8  # 本函数已保存在d2lzh包中方便以后使用 def data_iter(batch_size, features, labels): num_examples = len(features) indices = list(range(num_examples)) random.shuffle(indices) # 样本的读取顺序是随机的 for i in range(0, num_examples, batch_size): j = nd.array(indices[i: min(i + batch_size, num_examples)]) yield features.take(j), labels.take(j) # take函数根据索引返回对应元素   1 2 3 4 5  batch_size = 10 for X, y in data_iter(batch_size, features, labels): print(X, y) break   [[-0.65439206 0.74410725] [ 0.69013244 -0.6483847 ] [-0.59409887 0.3589477 ] [-0.47491348 0.6438462 ] [ 0.5074032 0.42834154] [-0.18589513 -0.21707669] [ 0.70281196 -1.3320632 ] [ 1.2072632 1.6909351 ] [-0.17264698 -1.5742793 ] [-1.6516455 -0.29966688]] \u0026lt;NDArray 10x2 @cpu(0)\u0026gt; [ 0.37379816 7.7938933 1.7758217 1.0414512 3.743439 4.5605783 10.148926 0.84148276 9.19984 1.9295483 ] \u0026lt;NDArray 10 @cpu(0)\u0026gt;  初始化\n1 2  w = nd.random.normal(scale=0.01, shape=(num_inputs, 1)) b = nd.zeros(shape=(1,))   添加保存梯度的空间\n1 2  w.attach_grad() b.attach_grad()   1 2  def linreg(X, w, b): # 本函数已保存在d2lzh包中方便以后使用 return nd.dot(X, w) + b   1 2  def squared_loss(y_hat, y): # 本函数已保存在d2lzh包中方便以后使用 return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2   1 2 3  def sgd(params, lr, batch_size): # 本函数已保存在d2lzh包中方便以后使用 for param in params: param[:] = param - lr * param.grad / batch_size   开始训练\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  lr = 0.03 num_epochs = 3 net = linreg loss = squared_loss for epoch in range(num_epochs): # 训练模型一共需要num_epochs个迭代周期 # 在每一个迭代周期中，会使用训练数据集中所有样本一次（假设样本数能够被批量大小整除）。X # 和y分别是小批量样本的特征和标签 for X, y in data_iter(batch_size, features, labels): with autograd.record(): l = loss(net(X, w, b), y) # l是有关小批量X和y的损失 l.backward() # 小批量的损失对模型参数求梯度 sgd([w, b], lr, batch_size) # 使用小批量随机梯度下降迭代模型参数 train_l = loss(net(features, w, b), labels) print(\u0026#39;epoch %d, loss %f\u0026#39; % (epoch + 1, train_l.mean().asnumpy()))   epoch 1, loss 0.040809 epoch 2, loss 0.000157 epoch 3, loss 0.000051  对比\n1  true_w, w   ( [ 2. -3.4] \u0026lt;NDArray 2 @cpu(0)\u0026gt;, [[ 1.9991481] [-3.3992586]] \u0026lt;NDArray 2x1 @cpu(0)\u0026gt;)  1  true_b, b   ( [4.2] \u0026lt;NDArray 1 @cpu(0)\u0026gt;, [4.19921] \u0026lt;NDArray 1 @cpu(0)\u0026gt;) ","description":"","id":19,"section":"posts","tags":["python","MXNet","深度学习","liner"],"title":"MXNet回顾","uri":"https://vhope.cf/zh/posts/dl/mxnet-begin/"},{"content":"重新学习一下DL，这次使用PyTorch框架🔦\n 参考资料：\nhttps://github.com/dsgiitr/d2l-pytorch\n 导入PyTorch库 1 2  import torch import numpy as np   创建Tensor 5x3的未初始化的张量\n1 2  x = torch.empty(5,3) x   tensor([[1.0286e-38, 9.0919e-39, 8.9082e-39], [9.2755e-39, 8.4490e-39, 1.0194e-38], [9.0919e-39, 8.4490e-39, 8.7245e-39], [1.0102e-38, 1.0653e-38, 8.7245e-39], [1.0286e-38, 9.6429e-39, 4.2244e-39]])  5x3随机初始化的张量\n1 2  x = torch.rand(5,3) x   tensor([[0.2518, 0.0419, 0.3233], [0.1493, 0.1408, 0.8559], [0.5145, 0.4648, 0.4605], [0.2555, 0.2502, 0.4506], [0.9798, 0.5056, 0.2726]])  5x3全0的张量\n1 2  x = torch.zeros(5,3) # 可以指定类型 x = torch.zeros(5,3,dtype=torch.long) x   tensor([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])  数据张量\n1 2  x = torch.tensor([5.5,3]) x   tensor([5.5000, 3.0000])  默认创建和原来的张量一样的dtype和device的张量，也可以另外设置\n1 2 3 4  x = x.new_ones(5,3,dtype=torch.double) print(x) x = torch.randn_like(x,dtype=torch.float) print(x)   tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) tensor([[-0.7829, -0.4010, 0.3230], [ 0.2660, 0.4766, 0.3186], [ 0.6096, 1.1226, -1.7942], [ 1.3255, 0.1835, -0.9078], [ 1.7743, -0.0944, -0.1704]])  获取Tensor的形状\n1  x.shape,x.size()   (torch.Size([5, 3]), torch.Size([5, 3]))  其他创建Tensor的函数:\n   函数 功能     Tensor(*sizes) 基础构造函数   tensor(data,) 类似np.array的构造函数   ones(*sizes) 全1Tensor   zeros(*sizes) 全0Tensor   eye(*sizes) 对角线为1，其他为0   arange(s,e,step) 从s到e，步长为step   linspace(s,e,steps) 从s到e，均匀切分成steps份   rand/randn(*sizes) 均匀/标准分布   normal(mean,std)/uniform(from,to) 正态分布/均匀分布   randperm(m) 随机排列     这些创建方法都可以在创建的时候指定数据类型dtype和存放device(cpu/gpu)\n 操作 1 2 3  x = torch.rand(5,3) y = torch.rand(5,3) x,y   (tensor([[0.7706, 0.7674, 0.0476], [0.3675, 0.3652, 0.1215], [0.2842, 0.4927, 0.0903], [0.1202, 0.7635, 0.1862], [0.1391, 0.5023, 0.0580]]), tensor([[0.2149, 0.4744, 0.6664], [0.5948, 0.3451, 0.6485], [0.2303, 0.6660, 0.3796], [0.7194, 0.3815, 0.7536], [0.7886, 0.0630, 0.2459]]))  加法，三种方法\n1 2 3 4  z1 = torch.add(x,y) z2 = x.add_(y) # x会改变 z3 = x + y z1,z2,z3   (tensor([[0.9855, 1.2418, 0.7140], [0.9623, 0.7103, 0.7700], [0.5145, 1.1588, 0.4699], [0.8396, 1.1450, 0.9397], [0.9276, 0.5653, 0.3040]]), tensor([[0.9855, 1.2418, 0.7140], [0.9623, 0.7103, 0.7700], [0.5145, 1.1588, 0.4699], [0.8396, 1.1450, 0.9397], [0.9276, 0.5653, 0.3040]]), tensor([[1.2004, 1.7163, 1.3804], [1.5571, 1.0554, 1.4185], [0.7448, 1.8248, 0.8495], [1.5590, 1.5265, 1.6933], [1.7162, 0.6283, 0.5499]]))  索引\n1 2  y = x[0, :] y   tensor([0.9855, 1.2418, 0.7140])  修改y会修改原来的数据，因为共享内存\n1 2 3  y+=1 print(y) print(x[0,:])   tensor([1.9855, 2.2418, 1.7140]) tensor([1.9855, 2.2418, 1.7140])  PyTorch还提供了一些高级的选择函数:\n   函数 功能     index_select(input, dim, index) 在指定维度dim上选取，比如选取某些行、某些列   masked_select(input, mask) 例子如上，a[a\u0026gt;0]，使用ByteTensor进行选取   nonzero(input) 非0元素的下标   gather(input, dim, index) 根据index，在dim维度上选取数据，输出的size与index一样    改变形状 用view()来改变Tensor的形状：\n1 2 3  y = x.view(15) z = x.view(-1,5) # -1为自动计算维度 print(x.size(),y.size(),z.size())   torch.Size([5, 3]) torch.Size([15]) torch.Size([3, 5])   注意view()返回的新Tensor与源Tensor虽然可能有不同的size，但是是共享data的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，view仅仅是改变了对这个张量的观察角度，内部数据并未改变)\n 1 2  x += 1 x,y   (tensor([[4.9855, 5.2418, 4.7140], [3.9623, 3.7103, 3.7700], [3.5145, 4.1588, 3.4699], [3.8396, 4.1450, 3.9397], [3.9276, 3.5653, 3.3040]]), tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040]))  使用reshape()函数会拷贝一份\n1 2  y = x.reshape(15) y   tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040])  也可以使用克隆后view\n 使用clone还有一个好处是会被记录在计算图中，即梯度回传到副本时也会传到源Tensor。\n 1 2  y = x.clone().view(15) y   tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040])  item(), 它可以将一个标量Tensor转换成一个Python number：\n1 2 3  x = torch.randn(1) print(x) print(x.item())   tensor([0.3816]) 0.3816383183002472  线性代数API    函数 功能     trace 对角线元素之和(矩阵的迹)   diag 对角线元素   triu/tril 矩阵的上三角/下三角，可指定偏移量   mm/bmm 矩阵乘法，batch的矩阵乘法   addmm/addbmm/addmv/addr/baddbmm.. 矩阵运算   t 转置   dot/cross 内积/外积   inverse 求逆矩阵   svd 奇异值分解    广播机制 什么是广播机制？简单的说就是形状不同的运算会自动变换为适合的运算\n1 2 3 4 5  x = torch.arange(3).view(1,3) print(x) y = torch.arange(2).view(2,1) print(y) print(x + y)   tensor([[0, 1, 2]]) tensor([[0], [1]]) tensor([[0, 1, 2], [1, 2, 3]]) ","description":"","id":20,"section":"posts","tags":["PyTorch","python","Tensor"],"title":"Pytorch Begin","uri":"https://vhope.cf/zh/posts/dl/pytorch-begin/"},{"content":"一份还算可以的翻墙清单📇\n本文介绍的方法归总: PC端 Mobile端   谷歌访问助手 插件(可以现在极简插件中下载） Astar VPN 插件 SSR    云帆VPN 老王VPN     'use strict'; var containerId = JSON.parse(\"\\\"635a6660b3cf14fc\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  PC端 谷歌访问助手 首先是不能通过谷歌的应用商店下载的，可以在国内的一些插件网站下载，这些推荐极简插件，找到谷歌访问助手进行下载。\n将CRT文件拖入谷歌浏览器的拓展程序界面中(这里用的助手是另一个版本)\n之后就可以访问谷歌的一部分服务了，例如谷歌搜索，Gmail，谷歌应用商店.\n安装过程可能会出现一些问题，具体可以参考:安装指引    其他类似的插件   PP谷歌访问助手:https://chrome.zzzmh.cn/info?token=kahndhhhcnignmbbpiobmdlgjhgfkfil 集装箱:https://chrome.zzzmh.cn/info?token=kbgigmcnifmaklccibmlepmahpfdhjch 谷歌访问助手:https://chrome.zzzmh.cn/info?token=gocklaboggjfkolaknpbhddbaopcepfp 谷歌学术助手:https://chrome.zzzmh.cn/info?token=jkicnibdkfemnfhojeajbldjgdddpajk 谷歌服务助手:https://chrome.zzzmh.cn/info?token=cgncbhnhlkbdieckbbmeppcefokppagh 谷歌上网助手:https://chrome.zzzmh.cn/info?token=nonmafimegllfoonjgplbabhmgfanaka    Astar VPN Astar VPN也是一个Chrome插件，在谷歌应用商店可以下载。经过第一步之后，we\u0026rsquo;re good to go!😁\n应用商店搜索Astar VPN进行下载，直接就可以在Chrome中进行自动安装。\n之后再插件选项中开启该插件，其中可以选择不同的服务器进行连接，速度还不错。\n使用该插件进行科学上网是真正意义上的，它可以访问国外任何网站!  ShadowsSocks ShadowsSocks是一款在github上的开源软件，可以用来进行连接节点服务器，但是节点需要自己去找，下面会介绍节点的选择。\n首先去github下载这个软件，链接为：https://github.com/shadowsocks/shadowsocks-windows/releases/tag/4.1.9.2\n将两个文件解压之后，将第一个文件夹内的exe文件移动到第二个文件夹的根目录并且打开即可\n关于免费节点，这里有一个网址：https://free-ss.site/(需要科学上网)\n右键ShadowSocks的图标，选择服务器，在选择扫描屏幕二维码，即可添加节点，之后点击系统代理并开启系统代理为全局模式。\n之后就可以🤙🤙🤙!\nMobile端 下面两个软件都是需要科学上网的，建议先在PC端下载再传到手机安装。  云帆VPN 下载地址：https://apkpure.com/store/apps/details?id=cc.dingnet.yunfangp\n虽然每天只能使用1小时，但是基本够了。\n老王VPN 下载地址：https://apkpure.com/wang-vpn-%E2%9D%A4%EF%B8%8F-free-fast-stable-best-vpn-just-try-it/com.findtheway\n老王的东西永远免费！\n参考链接\n 2020年Android高速稳定翻墙方法 Windows上长期有效的免费且高速稳定翻墙法！ ","description":"","id":21,"section":"posts","tags":["科学上网","ShadowShocks"],"title":"2020翻墙指南👈","uri":"https://vhope.cf/zh/posts/settings/2020-fanqiang/"},{"content":"👱‍♀介绍一些markdown中比较实用的一些写作方法。\n任务列表✍  a task list item list syntax required normal formatting, @mentions, #1234 refs incomplete completed  上面的代码如下：\n1 2 3 4 5  - [ ] a task list item - [ ] list syntax required - [ ] normal **formatting**, @mentions, #1234 refs - [ ] incomplete - [x] completed   数学公式📐 使用MathJax渲染LaTeX数学表达式。💡\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\n\\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\\n\\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\\n\\end{vmatrix}\n$$\n上面的代码如下：\n1 2 3 4 5 6 7  $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\\\\\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\\\\\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\\\\\ \\end{vmatrix} $$   $$\n\\begin{align*}\ny = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\n\u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\n\u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\n\u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\n\u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\n\u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t)\n\\end{align*}\n$$\n上面代码如下：\n1 2 3 4 5 6 7 8 9 10  $$ \\begin{align*} y = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\\\\ \u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\\\\ \u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\\\\ \u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\\\\ \u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\\\\ \u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{align*} $$   脚注👣 如下是使用的代码，将鼠标悬停在“ fn1”或“ fn2”上标上可以查看脚注的内容。您可以将任何喜欢的唯一标识用作脚注标记（例如“ fn1”）。\n1 2  [^fn1]: Here is the *text* of the first **footnote**. [^fn2]: Here is the *text* of the second **footnote**   你也可以内嵌脚注，就像^[Here is the text of the first footnote.]\n水平线〰 🌟在空行输入***或---，如下：\nYMAL首要事项🤔 包含YAML前事块的文件将作为特殊文件进行处理，下面是一个例子\n1 2 3 4  ---layout:posttitle:BloggingLikeaHacker---  目录📑 输入[toc]并回车即可。\n内部链接🔗 这是一个跳转到任务列表的链接,this link ！\n代码如下：\n1  [this link](#任务列表✍)   参考链接📖 参考链接使用两组方括号的格式，第一个是显示的文字，第二个括号内是查找的id，代码如下：\n1 2 3 4 5  This is [an example][id] reference-style link. Then, anywhere in the document, you define your link label on a line by itself like this: [id]: http://example.com/ \u0026#34;Optional Title Here\u0026#34;   隐式链接，直接使用Google查阅：\n[Google][] And then define the link: [Google]: http://google.com/ 删除线❌ 删除Mistaken text.，代码为~~Mistaken text.~~\n高亮🔆 ==highlight==，使用两个等号在两边进行包围，代码如下：\n1  ==highlight==   插入视频📹 Your browser does not support the video tag.\n上面的代码即：\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/02/29/S4oN2djFDZYiqAx.png\u0026#34; src=\u0026#34;https://files.catbox.moe/bqrntc.flv\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; loop=\u0026#34;loop\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   插入音乐🎼 Your browser does not support the audio tag.\n上面的代码即：\n1  \u0026lt;audio src=\u0026#34;https://files.catbox.moe/wjiywu.mp3\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; loop=\u0026#34;loop\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the audio tag.\u0026lt;/audio\u0026gt;   更多：\n随机图片🌳 网址:https://picsum.photos/1920/1080\n","description":"","id":22,"section":"posts","tags":["markdown","Typora"],"title":"Markdown深入使用","uri":"https://vhope.cf/zh/posts/settings/markdown-deep/"},{"content":"SM.MS sm.ms 支持的图片格式包括 JPG、JPEG、GIF、PNG 及 BMP，单档不超过 5 MB，单次可上传图片最大 10 张。图片永久保存，请勿上传政治相关图片\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤(15 年成立)\n如优图床 支持大量免费图床分发，网站稳定性未知\n速度：动态 ❤ ❤ ❤ ❤ ❤\n牛图网 速度：日本服务器 ❤ ❤ ❤ ❤(2010 年)\nniupic.com 稳定性不错，不要上传违法图片\nvim-cn 上传界面十分简单，但十分稳定。\n速度： ❤ ❤ ❤(12年到现在)\nimgbb 无需注册，支持最大 16M 图片上传，支持 https，速度不错\n速度：亚太服务器 ❤ ❤ ❤ ❤\nmeotu 16 年成立的免费图片外链网站。上传下载速度快。\n需要注册，默认原图上传，支持 https\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\n遇见图床 18 年成立的免费图片外链网站。上传下载速度快。\n需要注册，默认原图上传，支持最大 10M，支持 https\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\nz4a 图床 需要注册，支持 HTTPS 速度块\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\nz4a.net 由于成立时间较短，稳定性未知。\nupload 2012 年成立的免费图片上传外链网站，至今依然稳定\n无需注册，默认原图上传，支持 https\n速度：亚太服务器 ❤ ❤ ❤\ncatbox 无需注册，支持 https\n速度：海外服务器 ❤ ❤ ❤\ncatbox.moe 支持 200m 主流格式文件外链网站\n","description":"","id":23,"section":"posts","tags":["photo","图床"],"title":"几款好用的图床","uri":"https://vhope.cf/zh/posts/settings/free-image-bed/"},{"content":"Freenom 是目前为数不多的免费域名提供商，提供 .ga, .ml, .gq, .tk, .cf 五个免费顶级域。当然也有一些付费的域名，对于普通人来说，免费域名就够了。😏\n第一步，找域名 打开Freenom，登陆后直接在搜索栏搜索自己想要的域名名字，然后系统会返回可以使用的免费域名，选择一个结算即可\n第二步，配置解析服务 使用cloudflare解析服务 打开cloudflare，首先需要注册一个账号。然后他会要求输入需要解析的域名\n填写相应的DNS信息，并且将下面的NS信息填写到freenom的custom nameservers\n等待个几分钟就好了。Over 🤞\n","description":"","id":24,"section":"posts","tags":["域名","freenom"],"title":"Freenom 免费域名申请","uri":"https://vhope.cf/zh/posts/settings/freenom-domain/"},{"content":"安装MinGW之后，我们可以那它来作为C或C++的编译器.🕸\nCMD编译程序  编译过程分为四个步骤：预处理、编译、汇编、链接。\n 使用g++可以在命令行分别实现上面四个步骤。使用下面的程序作为例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; // this is my test program  #ifndef myNum#define myNum 666 #endifint main() { cout \u0026lt;\u0026lt; \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;myNum = \u0026#34; \u0026lt;\u0026lt; myNum \u0026lt;\u0026lt;endl; return 0; }   预处理 预处理主要完成的工作有：\n（1）删除#define，展开宏；\n（2）处理条件编译指令，预处理程序先判断条件，在根据条件修改源代码；\n（3）删除注释；\n（4）添加行号，以及文件名标识，便于调试\n（5）删除“#include”，插入相应的头文件；\n 使用下面的命令，得到预处理后的文件test.i\n1  g++ -E test.cpp -o test.i   查看test.i文件\n编译 使用下面的代码生成汇编文件test.s\n1  g++ -S test.i -o test.s   注意：直接从test.cpp文件得到汇编文件也可以。直接使用命令 g++ -S test.cpp -o test.s  查看test.s文件\n汇编 使用下面的命令将汇编指令转化为机器指令，生成文件test.o\n1  g++ -c test.s -o test.o   查看文件test.o\n链接 通过链接库文件，可以将目标文件test.o转化为可执行文件test.exe\n注意:Windows下可执行文件的后缀为exe，而Linux下不需要后缀。  CMD输入以下代码\n1  g++ test.o -o test.exe   注意:Windows下.o文件已经可以执行，在命令行输入test.o就可以看到如下的效果：\n 另外一个命令是\n1  g++ test.o -o test.exe -L 所需库文件路径   其中L为link的缩写。 快速生成可执行文件 一般情况下，可以直接使用g++ test.cpp -o test 就可以生成可执行程序了。\n运行程序 如下：\nMinGW + SublimeText配置C++环境 下载MinGW和SublimeText SublimeText下载\nMinGW下载及相关配置\n使用SublimeText 因为前面配置好环境变量了，所以可以直接在SublimeText下编译运行程序\nTools-\u0026gt;build(或者按快捷键Ctrl+B 或 Ctrl + Shift + B)\n可以在最下面一栏看到输出结果\nenjoy it!\n解决SublimeText下不能使用输入的问题 SublimeText是把shell执行的结果读回来显示在终端，这意味无法使用输入语句，无法使用调试功能。  解决方法:让程序直接运行在CMD\n在sublime-\u0026gt;Tools\u0026gt;Build System里新建编译系统，输入以下内容构建C++编译环境,保存名字为C++Buider\n1 2 3 4 5 6 7 8 9 10 11 12  {\u0026#34;cmd\u0026#34;: [\u0026#34;g++\u0026#34;,\u0026#34;$file_name\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_base_name}\u0026#34;,\u0026#34;-lm\u0026#34;,\u0026#34;-Wall\u0026#34;],\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c, source.c++\u0026#34;,\u0026#34;shell\u0026#34;: false,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;,\u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;,\u0026#34;/c\u0026#34;,\u0026#34;g++\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;${file}\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;,\u0026#34;\u0026amp;\u0026amp;\u0026#34;,\u0026#34;start\u0026#34;,\u0026#34;cmd\u0026#34;,\u0026#34;/k\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;]}]}  然后可以使用快捷键Ctrl + Shift + B，会显示如下，使用命令行打开模式选项即可\n结果如下：\n其他编译环境的配置也类似：\nC编译配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12  {\u0026#34;cmd\u0026#34;: [\u0026#34;gcc\u0026#34;,\u0026#34;$file_name\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_base_name}\u0026#34;,\u0026#34;-lm\u0026#34;,\u0026#34;-Wall\u0026#34;],\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c, source.c++\u0026#34;,\u0026#34;shell\u0026#34;: false,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;,\u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;,\u0026#34;/c\u0026#34;,\u0026#34;gcc\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;${file}\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;,\u0026#34;\u0026amp;\u0026amp;\u0026#34;,\u0026#34;start\u0026#34;,\u0026#34;cmd\u0026#34;,\u0026#34;/k\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;]}]}  Java编译配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  { \u0026#34;cmd\u0026#34;: [\u0026#34;javac\u0026#34;, \u0026#34;$file_name\u0026#34;], \u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;source.java\u0026#34;, \u0026#34;shell\u0026#34;: false, \u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;, \u0026#34;variants\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;javac\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;\u0026amp;\u0026amp;\u0026#34;, \u0026#34;start\u0026#34;, \u0026#34;cmd\u0026#34;, \u0026#34;/k\u0026#34;, \u0026#34;java $file_name\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;javac\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;\u0026amp;\u0026amp;\u0026#34;, \u0026#34;start\u0026#34;, \u0026#34;cmd\u0026#34;, \u0026#34;/k\u0026#34;, \u0026#34;gdb ${file_path}/${file_base_name}\u0026#34;] }] }   解决不能输入中文的问题 使用下面的编译配置文件即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  {\u0026#34;encoding\u0026#34;: \u0026#34;GBK\u0026#34;,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file_name\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34;\u0026#34;,\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c++\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;Run in sublime\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file_name\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; cmd /c \\\u0026#34;${file_path}/${file_base_name}\\\u0026#34;\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;CMD Run\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; start cmd /c \\\u0026#34;\\\u0026#34;${file_path}/${file_base_name}\\\u0026#34; \u0026amp; pause\\\u0026#34;\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;gdb Debug\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -g -std=c++11 \\\u0026#34;$file\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; start cmd /c gdb ${file_path}/${file_base_name} \u0026amp; pause\u0026#34;}]}  配置代码格式化 从菜单里选View-\u0026gt;Show Console，跳出Console，下面有一行输入的（光标位置），把下面这段代码输入进去回车(只适用sublime Text 3)\n1  import urllib.request,os; pf = \u0026#39;Package Control.sublime-package\u0026#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), \u0026#39;wb\u0026#39;).write(urllib.request.urlopen( \u0026#39;http://sublime.wbond.net/\u0026#39; + pf.replace(\u0026#39;\u0026#39;,\u0026#39;%20\u0026#39;)).read())   安装CoolFormat，按Ctrl+Shift+P，然后输入install,就会出现“Package Control: Install Package”，输入CoolFormat进行下载，下载完成之后输入Ctrl+Shift+P，然后输入CoolFormat，选下Formatter Settings，可以看到如下配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ;Pleasevisithttp://akof1314.github.io/CoolFormat/doc/index.htmlformoreinformation[SynTidy]C++=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;Java=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;C#=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;Objective-C=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;HTML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-fu-js-ll-n-ox-pe-qa-qn-m-wa-wj-wp-ws-sw-fo-i0-d1-ce0-ie0-oe0-w0-sbo0\u0026#34;\u0026#34;XML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-js-ll-n-ix-qa-qn-m-wa-wj-wp-ws-sw-fo-i1-ce0-ie0-oe0-w0\u0026#34;\u0026#34;PHP=\u0026#34;\u0026#34;-sas-icd-samt-salo-saeo-saro-sabo-saao-samp-aas-rsl-iel-rpc-rst-st\u0026#34;\u0026#34;JavaScript=\u0026#34;\u0026#34;-nb-cn4\u0026#34;\u0026#34;CSS=\u0026#34;\u0026#34;-c2-rub-cl0-os1-cc-cf-cfp0-rs2\u0026#34;\u0026#34;JSON=\u0026#34;\u0026#34;-cn3\u0026#34;\u0026#34;SQL=\u0026#34;\u0026#34;-cn2-el-ml0\u0026#34;\u0026#34;Verilog=\u0026#34;\u0026#34;-A1\u0026#34;\u0026#34;  建立快捷键\n进入菜单选Preferences-\u0026gt;Browse Packages，然后进CoolFormat，里面有个Default.sublime-keymap\n打开后，里面有快捷方式的按键,更改如下：\n1 2 3 4 5 6 7 8 9  [{\u0026#34;keys\u0026#34;: [\u0026#34;ctrl+q\u0026#34;], \u0026#34;command\u0026#34;: \u0026#34;coolformat\u0026#34;, \u0026#34;args\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;quickFormat\u0026#34;}},{\u0026#34;keys\u0026#34;: [\u0026#34;ctrl+alt+shift+s\u0026#34;], \u0026#34;command\u0026#34;: \u0026#34;coolformat\u0026#34;, \u0026#34;args\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;selectedFormat\u0026#34;}}]   这样以后写完的代码直接按 “Ctrl+Q” 便可以格式化代码\n 另一种格式化代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ;Pleasevisithttp://akof1314.github.io/CoolFormat/doc/index.htmlformoreinformation[SynTidy]C++=\u0026#34;\u0026#34;-A2-p-N-Y-o-T-N-k3\u0026#34;\u0026#34;Java=\u0026#34;\u0026#34;-A1-p-N-T-Y-k3\u0026#34;\u0026#34;C#=\u0026#34;\u0026#34;-A1-p-N-Y-T-k3\u0026#34;\u0026#34;Objective-C=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;HTML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-fu-js-ll-n-ox-pe-qa-qn-m-wa-wj-wp-ws-sw-fo-i0-d1-ce0-ie0-oe0-w0-sbo0\u0026#34;\u0026#34;XML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-js-ll-n-ix-qa-qn-m-wa-wj-wp-ws-sw-fo-i1-ce0-ie0-oe0-w0\u0026#34;\u0026#34;PHP=\u0026#34;\u0026#34;-sas-icd-samt-salo-saeo-saro-sabo-saao-samp-aas-rsl-iel-rpc-rst-st\u0026#34;\u0026#34;JavaScript=\u0026#34;\u0026#34;-nb-cn4\u0026#34;\u0026#34;CSS=\u0026#34;\u0026#34;-c2-rub-cl0-os1-cc-cf-cfp0-rs2\u0026#34;\u0026#34;JSON=\u0026#34;\u0026#34;-cn3\u0026#34;\u0026#34;SQL=\u0026#34;\u0026#34;-cn2-el-ml0\u0026#34;\u0026#34;  ","description":"","id":25,"section":"posts","tags":[""],"title":"MinGW在Windows的使用","uri":"https://vhope.cf/zh/posts/settings/mingw-use/"},{"content":"HUGO + Github + Github Action持续集成部署个人博客\nHUGO本地环境 首先在HUGO的官网下载Hugo的Windows安装包，然后将路径添加到环境变量即可。\nstep1:下载hugo\nstep2:配置环境变量\nHUGO站点配置及主题配置 创建站点 在目录下直接输入下面的代码即可创建一个名为blog的hugo站点(注意：新建的站点是没有自带主题的)\n1  hugo new site blog   或者进入blog文件夹内直接输入以下语句：\n1  hugo new site .   下载主题 可以在hugo theme下载主题，然后根据主题的文档进行配置\n放到站点文件夹themes内，配置config.toml\n本地测试运行 输入hugo server测试\nGithub配置 创建站点仓库并且设置GithubPage 可以在Setting中看见如下：\n创建一个存储项目的仓库 配置Github Action 首先在项目仓库点击action，选择Simple workflow，输入一下的配置代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  name:CI#自动化的名称on:push:# push的时候触发branches:# 那些分支需要触发- masterjobs:build:runs-on:ubuntu-latest# 镜像市场steps:- name:checkout# 步骤的名称uses:actions/checkout@v1#软件市场的名称with:# 参数submodules:true- name:SetupHugouses:peaceiris/actions-hugo@v2.2.2with:hugo-version:\u0026#39;0.64.1\u0026#39;extended:true- name:Buildrun:hugo-D- name:Deployuses:peaceiris/actions-gh-pages@v2.5.1env:ACTIONS_DEPLOY_KEY:${{secrets.ACTIONS_DEPLOY_KEY}}EXTERNAL_REPOSITORY:redisread/redisread.github.ioPUBLISH_BRANCH:masterPUBLISH_DIR:./public  准备部署，我们开发的项目及github pages实际是分开的，一个用于保存项目，相当于源代码，另外一个用于保存最终的网页文件。\n  使用git生成ssh key(相当于生成对密钥)\n1 2 3 4  ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key)    假设 开发项目为 HUGO_blog 部署的项目为 redisread.github.io\n   打开HUGO_blog仓库的settings，再点击Secrets，然后添加刚刚生成的私钥，name为ACTIONS_DEPLOY_KEY\n  同理，打开redisread.github.io，点击Deploy keys，添加公钥，Allow write access一定要勾上，否则会无法提交\n  然后，你就可以提交代码了，push成功后，打开仓库actions，至此部署成功，大功告成！\n","description":"Guide to set Hugo site.","id":26,"section":"posts","tags":["Hugo","Github"],"title":"Hugo配置","uri":"https://vhope.cf/zh/posts/hugo/first/"},{"content":"使用Github+PicGo建立一个免费的个人图床。\nPicGo介绍 PicGo是一款图片上传的工具，目前支持微博图床，七牛图床，腾讯云，又拍云，GitHub等图床\n在Github创建图床 创建Repository 生成一个Token用于操作GitHub repository 步骤如下:\n{% note warning %}\n注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存\n{% endnote %}\n配置PicGo 下载PicGo Windows用户下载exe文件\n配置图床    设定仓库名的时候，是按照“账户名/仓库名的格式填写”\n  分支名统一填写“master”\n  将之前的Token黏贴在这里\n  存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹\n  自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/用户名/RepositoryName/分支名，，自定义域名需要按照这样去填写\n   快捷键及相关配置  这里配置上传快捷键为ctrl+shift+c\n 使用 经过上面的配置就大功告成了，每次截图之后，只需要ctrl+shift+c一下就可以把剪切板上面的截图转化为在线网络图片链接。\n","description":"","id":27,"section":"posts","tags":["PicGo","Github","图床"],"title":"配置基于Github的PicGo图床","uri":"https://vhope.cf/zh/posts/settings/image-bed/"},{"content":"写在源文件中的源代码是人类可读的源。它需要\u0026quot;编译\u0026rdquo;，转为机器语言，这样 CPU 可以按给定指令执行程序。C 语言编译器用于把源代码编译成最终的可执行程序。🐤\n安装 首先,到：https://sourceforge.net/projects/mingw-w64/files/latest/download，下载最新版本的 MinGW 安装程\n然后，运行 Download mingw-get-setup.exe ,点击\u0026quot;运行\u0026rdquo;，continue等，注意记住安装的目录，之后需要配置环境变量，例如D:\\MinGW\\bin\n假如网速不好，可以通过下面的链接进行离线下载，下载完成之后使用7Zip解压，然后把解压的文件移动到安装路径即可。\nhttps://pan.baidu.com/s/1W4fHsUeaw1C9vp1lvRygbw\n注：使用这种方式下面的步骤不需要执行了，已经在离线包中集成了。可直接输入gcc -v查看gcc版本。\n 验证安装：\n在开始菜单中，点击\u0026quot;运行\u0026rdquo;，输入 cmd,打开命令行:输入 mingw-get,如果弹出 MinGw installation manager 窗口，说明安装正常，然后关闭窗口。\n安装GCC等编译器 在cmd中输入如下命令进行安装：\n安装gcc\n1  mingw-get install gcc   安装g++\n1  mingw-get install g++   安装gdb\n1  mingw-get install gdb   使用 在桌面创建一个hello.c的程序\n1 2 3 4 5 6 7 8 9  #include \u0026lt;iostream\u0026gt;using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   在 cmd 中输入命令\n1  gcc hello.c   在当前目录下(记住是命令的当前目录)会生成 a.exe 的可执行文件，在 cmd 中输入 a.exe 就可以执行程序了。\n","description":"","id":28,"section":"posts","tags":["gcc","MinGW"],"title":"windows下gcc的安装和使用","uri":"https://vhope.cf/zh/posts/settings/gcc-windows/"},{"content":"我是一个不够严谨的程序员🙉.\n我喜欢📖,还有🏓.\n或许有时候我想的不够远，但是有时候我想的很深入。\n我最喜欢的 Aaron Swartz 语录:\n 在长大的过程中，我才慢慢发现，我身边的所有事，别人跟我说的所有事，那些所谓本来如此，注定如此的事，它们其实没有非得如此，事情是可以改变的。更重要的是，有些事既然错了，那就该做出改变。\n我对学校十分失望，我觉得老师们根本不懂自己所讲的是什么，他们居高临下，管这管那；作业就像是种把戏，就好像知识一种强制所有学生一起庸庸碌碌的手段。于是我就开始去阅读那些关于教育史和这套教育体系演变的书籍。然后你就能发现，如果要真正学到东西，那就不能机械重复老师所教的，这有点儿使得我渐渐学会了质疑。我质疑我所上的学校，我质疑简历这所学校的这个社会，我质疑学校教人们追求的那套事理，我质疑建立起这整个体系的政府。\n我总是深入思考，我希望别人也能想远一点。我为理想而工作，并从别人身上学习，我不喜欢拒人于外。我是个完美主义者，但我不会要求出版界也精益求精。除了教育和娱乐以外，我不会浪费时间在那些不会有影响的事情上。我试着和每个人都友好相处，但我讨厌人们不认真对待我。我不记恨他人，因为这于创造无益。但我从自身经历中学习，我想让世界变得更美好。\n我深深地觉得，光安生与当下这世界是不够的，那样子知识别人给什么你就照收，大人们说什么你就照做，你照着父母说的去做，照着社会说的去做。我觉得你应该总持有质疑，我觉得从科学的角度看，你所学的一切都知识暂时性的，任何所学都有改口、驳斥、质疑的余地。我觉得这情况对社会也适用。当我意识到社会上有着我能尽份力去解决的真正严重的、基础性的问题时，我没法去遗忘它、回避它。\n ","description":"Zzo about page","id":29,"section":"","tags":null,"title":"About","uri":"https://vhope.cf/zh/about/"},{"content":"Markdownify box This is boxmd shortcode Simple box This is **box** shortcode  Code tabs Make it easy to switch between different code\njava javascript  1  System.out.println(\u0026#39;Hello World!\u0026#39;);     1  console.log(\u0026#39;Hello World!\u0026#39;);       'use strict'; var containerId = JSON.parse(\"\\\"642b4352e05d9e04\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Tabs for general purpose Windows MacOS Ubuntu  Windows section 1  console.log(\u0026#39;Hello World!\u0026#39;);   ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n MacOS section Hello world!  Ubuntu section Great!    'use strict'; var containerId = JSON.parse(\"\\\"f09fb25fccaa3686\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Expand   Expand me  Title contents     Expand me2  Title2 contents2   Alert Colored box\nthis is a text this is a text this is a text this is a text Notice success text  info text  warning text  error text  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":30,"section":"posts","tags":["shortcode"],"title":"Shortcodes","uri":"https://vhope.cf/zh/posts/hugo/shortcodes/"},{"content":"A Short Video：  ——以下 Aaron Swartz的宣言，我想这才是信息革命的真谛——\n信息就是力量。但就像所有力量一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 Reed Elsevier 这样的出版商大把钱。\n有人努力去改变这种状况。开放访问运动 (Open Access Movement) 奋勇斗争，确保科学家们没有将他们的版权签署给别人，而是将他们的成果发布到网络上，允许任何人访问它们。但即便是最好的情况，他们的行为也只作用于未来发布的东西。之前的都将失去。\n这样的代价实在太高。强制学者付钱以阅读他们同行的成果？扫描整个图书馆却只允许 Google 的人阅读它们？提供科学文章给那些第一世界的精英大学，却不给身在南半球的儿童？这实在蛮横且无法接受。\n“我同意，”有些人就说了，“但是我们能做什么呢？那些公司握有版权，他们靠限制访问赚取大把的钱，而且这是完全合法的 - 我们没有办法阻止他们。”但有些事我们能做，这些事我们已经在做：我们可以反击。\n那些能够访问这些资源的人 - 学生，图书管理员，科学家 - 你们被赋予了特权。你们能享受到这知识的盛宴，而其他人却被排除在外。但是你们不必 - 事实上，从道义层面来说，你们不能 - 为保留自己保留这份特权。你们有义务和全世界分享它。而且你们已经在做了：和同行们交换密码，回应朋友们的下载请求。\n同时，那些被拒之门外的人们并没有袖手旁观。你们溜过洞穴，翻越围墙，解放那些被出版商封锁的信息并分享给你的朋友们。\n但所有这些行动都是在黑暗中进行，隐藏于地底。它们被称作偷窃或盗版，仿佛分享大量的知识精神上等同于抢劫一艘船只并谋杀其船员。但是分享绝非不道德的，它是一种道德使命。只有那些利欲熏心的人才会拒绝让朋友复制一份。\n大公司，当然，就是利欲熏心。使它们运转的法律要求使然 - 稍微出点事投资人就得叛乱。它们收买的政治家们支持它们，通过法案让它们拥有专属的权力决定谁可以复制。\n遵从不公正的法律不会带来公正。步入光明的时候到了，在公民不服从的伟大传统下，宣告我们对这种私人盗窃公共文化的反抗。\n我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。\n只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？\n亚伦·斯沃茨 (Aaron Swartz)\n2008 年 7 月，意大利 Eremo\nInformation is power. But like all power, there are those who want to keep it for themselves. The world\u0026rsquo;s entire scientific and cultural heritage, published over centuries in books and journals, is increasingly being digitized and locked up by a handful of private corporations. Want to read the papers featuring the most famous results of the sciences? You\u0026rsquo;ll need to send enormous amounts to\npublishers like Reed Elsevier.\nThere are those struggling to change this. The Open Access Movement has fought valiantly to ensure that scientists do not sign their copyrights away but instead ensure their work is published on the Internet, under terms that allow anyone to access it. But even under the best scenarios, their work will only apply to things published in the future. Everything up until now will have been lost.\nThat is too high a price to pay. Forcing academics to pay money to read the work of their colleagues? Scanning entire libraries but only allowing the folks at Google to read them? Providing scientific articles to those at elite universities in the First World, but not to children in the Global South? It\u0026rsquo;s outrageous and unacceptable.\n\u0026ldquo;I agree,\u0026rdquo; many say, \u0026ldquo;but what can we do? The companies hold the copyrights, they make enormous amounts of money by charging for access, and it\u0026rsquo;s perfectly legal - there\u0026rsquo;s nothing we can do to stop them.\u0026rdquo; But there is something we can, something that\u0026rsquo;s already being done: we can fight back.\nThose with access to these resources - students, librarians, scientists - you have been given a privilege. You get to feed at this banquet of knowledge while the rest of the world is locked out. But you need not - indeed, morally, you cannot - keep this privilege for yourselves. You have a duty to share it with the world. And you have: trading passwords with colleagues, filling download requests for friends.\nMeanwhile, those who have been locked out are not standing idly by. You have been sneaking through holes and climbing over fences, liberating the information locked up by the publishers and sharing them with your friends.\nBut all of this action goes on in the dark, hidden underground. It\u0026rsquo;s called stealing or piracy, as if sharing a wealth of knowledge were the moral equivalent of plundering a ship and murdering its crew. But sharing isn\u0026rsquo;t immoral - it\u0026rsquo;s a moral imperative. Only those blinded by greed would refuse to let a friend make a copy.\nLarge corporations, of course, are blinded by greed. The laws under which they operate require it - their shareholders would revolt at anything less. And the politicians they have bought off back them, passing laws giving them the exclusive power to decide who can make copies.\nThere is no justice in following unjust laws. It\u0026rsquo;s time to come into the light and, in the grand tradition of civil disobedience, declare our opposition to this private theft of public culture.\nWe need to take information, wherever it is stored, make our copies and share them with the world. We need to take stuff that\u0026rsquo;s out of copyright and add it to the archive. We need to buy secret databases and put them on the Web. We need to download scientific journals and upload them to file sharing networks. We need\nto fight for Guerilla Open Access.\nWith enough of us, around the world, we\u0026rsquo;ll not just send a strong message opposing the privatization of knowledge - we\u0026rsquo;ll make it a thing of the past.\nWill you join us?\nAaron Swartz\nJuly 2008, Eremo, Italy\n","description":"","id":31,"section":"talks","tags":[""],"title":"My Awesome links","uri":"https://vhope.cf/zh/talks/mylinks/"},{"content":"Sample images about life.\n","description":"my gallery","id":33,"section":"gallery","tags":[""],"title":"life","uri":"https://vhope.cf/zh/gallery/life/"},{"content":"between 40 and 240 in movies\ngood movies！🎥\n","description":"my gallery","id":34,"section":"gallery","tags":[""],"title":"movie","uri":"https://vhope.cf/zh/gallery/movie/"},{"content":"一个测试视频:  ","description":"","id":38,"section":"talks","tags":[""],"title":"B站视频","uri":"https://vhope.cf/zh/talks/blibli/"}]