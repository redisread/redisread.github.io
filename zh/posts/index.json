[{"content":"工作💻 作为Java后端开发，开发仓储库存管理系统。\n看书📚 正在看 《创造：用非传统方式做有价值的事》\nWhat else? 还没想到\u0026hellip;\n","description":"","id":2,"section":"","tags":null,"title":"我现在在做什么？","uri":"https://hugo.jiahongw.com/zh/now/"},{"content":" Freenom 是目前为数不多的免费域名提供商，提供 .ga, .ml, .gq, .tk, .cf 五个免费顶级域。当然也有一些付费的域名，对于普通人来说，免费域名就够了。😏\n另外，本文后面还提供了一种自动续租 Freenom 免费域名的方法。\n1 找域名 Freenom 地址：freenom.com\n打开Freenom，登陆后直接在搜索栏搜索自己想要的域名名字，然后系统会返回可以使用的免费域名，选择一个结算即可\n2 配置解析服务 这一步是可选的，也可以直接使用 Freenom 自己的 DNS 解析服务，或者不使用 cloudflare，用其他的 DNS 解析服务也可以。\n使用cloudflare解析服务 Cloudflare 网址：cloudflare.com\n打开cloudflare，首先需要注册一个账号。然后他会要求输入需要解析的域名\n填写相应的 DNS 信息，并且将下面的 NS 信息填写到 freenom 的custom nameservers\n等待个几分钟就好了。Over 🤞\n3 自动续租 参考：\nluolongfei/freenom: Freenom 域名自动续期。Freenom domain name renews automatically. 常见问题：\nfreenom 域名注册失败的解决办法_未名编程的博客-CSDN 博客_some of your domains could not be registered becau 参考这个github 仓库进行下面的操作：\n通过 Koyeb 部署：通过 Koyeb 部署 · luolongfei/freenom Wiki\n注册 Koyeb 账户\n在新标签页打开链接 https://app.koyeb.com/auth/signup ，完成注册，并登录\n一键部署\n右击在新标签页打开链接 ，来到部署画面：\n主要填写 token 和 freenom 的账号和密码，token 是登陆后台的密码，需要自己保存。\n然后点击 deploy 或者 create service。\n点击应用地址，跳到工具管理画面：\n输入 token 值进行验证（点击送信）：\n返回类似下面的结果：\n默认会周期进行定时调用，不需要手动触发，上面只是为了展示进行触发的。\nReference：\nThe fastest way to deploy applications globally - Koyeb ","description":"","id":3,"section":"posts","tags":["域名","freenom"],"title":"Freenom 免费域名申请 \u0026 自动域名续费","uri":"https://hugo.jiahongw.com/zh/posts/hugo/freenom-domain/"},{"content":" 创建线程池的方法：\n1 2 3 4 ExecutorService executorService = Executors.newCachedThreadPool(); ExecutorService executorService = Executors.newFixedThreadPool(3); ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3); ExecutorService executorService = Executors.newSingleThreadExecutor(); https://www.cnblogs.com/pcheng/p/13540619.html\n多线程的问题 线程任务是实现了Runnable接口，或者直接写个类继承Thread,但是这两种方法只能通过共享对象或者文件来得到返回的结果，无法直接返回。并且Runnable接口中的run方法无法抛出异常。\n回调地狱（Callback hell）问题\nJava 5 提供了执行器框架，其思想类似于一个高层的线程池，可以充分发􏴁线程的能力。执行器使得程序员有机会解􏳽任务的提交与任务的执行。\n无论什么时候，任何任务(或者线程)在方法 调用中启动时，都会在其返回之前调用同一个方法。换句话说，线程创建以及与其匹配的 join() 在调用返回的嵌套方法调用中都以嵌套的方式成对出现。这种思想被称为􏶖􏶗 fork/join。\nJava中的Future代表了什么？\nFuture是Java的接口，类似于容器保存了Callable的返回结果。我们把子任务放入线程池之后，直接返回，进行其他处理，然后再调用Future的get方法来获取结果，Future还可以控制子任务的执行。\nFuture 我们使用Runnable对象来定义在线程内执行的任务。虽然定义任务使用Runnable很方便，但受限于任务不能返回结果。\nJava 提供了一个Callable接口来定义返回结果的任务。Callable类似于Runnable并且它可以返回结果并抛出异常。\nCallable 接口有一个简单的方法call() 用于包含由线程执行的代码。简单的例子：\n1 2 3 4 5 6 7 8 Callable\u0026lt;String\u0026gt; callable = new Callable\u0026lt;String\u0026gt;() { @Override public String call() throws Exception { // Perform some computation Thread.sleep(2000); return \u0026#34;Return some result\u0026#34;; } }; 请注意，使用Callable，您不需要Thread.sleep()被 try/catch 块包围，因为与 Runnable 不同，Callable 可以抛出checked异常。\n更方便的定义一个Callable，使用Lambda表达式：\n1 2 3 4 5 Callable\u0026lt;String\u0026gt; callable = () -\u0026gt; { // Perform some computation Thread.sleep(2000); return \u0026#34;Return some result\u0026#34;; }; Callable的定义如下：\n1 2 3 4 5 6 7 8 9 10 @FunctionalInterface public interface Callable\u0026lt;V\u0026gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception; } 可以发现它是可以带返回值的，并且能够抛出异常。\nRunnable接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @FunctionalInterface public interface Runnable { /** * When an object implementing interface \u0026lt;code\u0026gt;Runnable\u0026lt;/code\u0026gt; is used * to create a thread, starting the thread causes the object\u0026#39;s * \u0026lt;code\u0026gt;run\u0026lt;/code\u0026gt; method to be called in that separately executing * thread. * \u0026lt;p\u0026gt; * The general contract of the method \u0026lt;code\u0026gt;run\u0026lt;/code\u0026gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } Runnable接口是没有返回值，也不能抛出异常的。因为run()方法是Runnable接口里面的方法,而Runnable接口在定义run()方法的时候没有抛出任何异常,所以子类在重写run()方法的时候要小于或等于父类(Runnable)的run()方法的异常,所以父类没有抛出异常,子类不能抛出异常。\nThread类中的run方法定义如下：\n1 2 3 4 5 6 @Override public void run() { if (target != null) { target.run(); } } 同理，继承Thread的线程子类也不能够抛出异常，因为如果父类或者接口的方法中，没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。发生异常必须进行try处理。\n使用（Callable结合Future） 像Runnable一样，你可以submit一个Callable给executor service去执行。executor service的 submit() 方法 会将任务提交给线程执行。但是，它不知道提交的任务什么时候结束。因此，它返回一种称为 Future 的特殊类型的值，可用于在可用时获取任务的结果。\nFuture 的概念类似于 Javascript 等其他语言中的 Promise。它表示将在以后的某个时间点完成的计算结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.concurrent.*; public class FutureAndCallableExample { public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable\u0026lt;String\u0026gt; callable = () -\u0026gt; { // Perform some computation System.out.println(\u0026#34;Entered Callable\u0026#34;); Thread.sleep(2000); return \u0026#34;Hello from Callable\u0026#34;; }; System.out.println(\u0026#34;Submitting Callable\u0026#34;); Future\u0026lt;String\u0026gt; future = executorService.submit(callable); // This line executes immediately System.out.println(\u0026#34;Do something else while callable is getting executed\u0026#34;); System.out.println(\u0026#34;Retrieve the result of the future\u0026#34;); // Future.get() 会阻塞知道Future中得到了返回的结果 String result = future.get(); System.out.println(result); executorService.shutdown(); } } 或者可以使用这个例子进行测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 mport java.util.concurrent.*; public class FutureIsDoneExample { public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executorService.submit(() -\u0026gt; { Thread.sleep(2000); return \u0026#34;Hello from Callable\u0026#34;; }); while(!future.isDone()) { System.out.println(\u0026#34;Task is still not done...\u0026#34;); Thread.sleep(200); } System.out.println(\u0026#34;Task completed! Retrieving the result\u0026#34;); String result = future.get(); System.out.println(result); executorService.shutdown(); } } 输出结果如下：\n# Output Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task completed! Retrieving the result Hello from Callable 在没有得到结果的时候，isDone()的返回值都是false，这将导致阻塞。\n取消Future 你可以使用Future.cancel()方法取消一个Future。它试图取消任务的执行，如果成功取消则返回true，否则返回false。\n您可以使用isCancelled()方法来检查任务是否被取消。此外，取消任务后，isDone() 将始终为真。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.concurrent.*; public class FutureCancelExample { public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newSingleThreadExecutor(); long startTime = System.nanoTime(); Future\u0026lt;String\u0026gt; future = executorService.submit(() -\u0026gt; { Thread.sleep(2000); return \u0026#34;Hello from Callable\u0026#34;; }); while(!future.isDone()) { System.out.println(\u0026#34;Task is still not done...\u0026#34;); Thread.sleep(200); double elapsedTimeInSec = (System.nanoTime() - startTime)/1000000000.0; if(elapsedTimeInSec \u0026gt; 1) { future.cancel(true); } } System.out.println(\u0026#34;Task completed! Retrieving the result\u0026#34;); String result = future.get(); System.out.println(result); executorService.shutdown(); } } 跑上面的代码将会抛出异常，因为已经取消了Future，然后又实用get()方法获取Future的值。\nTask is still not done... Task is still not done... Task is still not done... Task is still not done... Task is still not done... Task completed! Retrieving the result Exception in thread \u0026#34;main\u0026#34; java.util.concurrent.CancellationException at java.util.concurrent.FutureTask.report(FutureTask.java:121) at java.util.concurrent.FutureTask.get(FutureTask.java:192) at com.sankuai.stafftraining.wujiahong.demo.springdemo.concurrency.MainApp.test3(MainApp.java:79) at com.sankuai.stafftraining.wujiahong.demo.springdemo.concurrency.MainApp.main(MainApp.java:12) 最好是通过下面这种方法进行判断：\n1 2 3 4 5 6 7 if(!future.isCancelled()) { System.out.println(\u0026#34;Task completed! Retrieving the result\u0026#34;); String result = future.get(); System.out.println(result); } else { System.out.println(\u0026#34;Task was cancelled\u0026#34;); } invokeAll方法 提交多个任务并等待所有任务完成。\n你可以通过向invokeAll()方法传递一个Callables的集合来执行多个任务。invokeAll()返回一个Futures的列表。任何对future.get()的调用都会被阻止，直到所有的Futures都完成。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.Arrays; import java.util.List; import java.util.concurrent.*; public class InvokeAllExample { public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newFixedThreadPool(5); Callable\u0026lt;String\u0026gt; task1 = () -\u0026gt; { Thread.sleep(2000); return \u0026#34;Result of Task1\u0026#34;; }; Callable\u0026lt;String\u0026gt; task2 = () -\u0026gt; { Thread.sleep(1000); return \u0026#34;Result of Task2\u0026#34;; }; Callable\u0026lt;String\u0026gt; task3 = () -\u0026gt; { Thread.sleep(5000); return \u0026#34;Result of Task3\u0026#34;; }; List\u0026lt;Callable\u0026lt;String\u0026gt;\u0026gt; taskList = Arrays.asList(task1, task2, task3); List\u0026lt;Future\u0026lt;String\u0026gt;\u0026gt; futures = executorService.invokeAll(taskList); for(Future\u0026lt;String\u0026gt; future: futures) { // The result is printed only after all the futures are complete. (i.e. after 5 seconds) System.out.println(future.get()); } executorService.shutdown(); } } 在上面的程序中，第一次调用 future.get() 语句会阻塞，直到所有的期货都完成。即结果将在 5 秒后打印。\n输出的结果为：\nResult of Task1 Result of Task2 Result of Task3 invokeAny方法 提交多个任务并等待其中任何一个完成.\ninvokeAny() 方法接受一个 Callables 集合并返回最快的 Callable 的结果。请注意，它不会返回 Future。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import java.util.Arrays; import java.util.List; import java.util.concurrent.*; public class InvokeAnyExample { public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newFixedThreadPool(5); Callable\u0026lt;String\u0026gt; task1 = () -\u0026gt; { Thread.sleep(2000); return \u0026#34;Result of Task1\u0026#34;; }; Callable\u0026lt;String\u0026gt; task2 = () -\u0026gt; { Thread.sleep(1000); return \u0026#34;Result of Task2\u0026#34;; }; Callable\u0026lt;String\u0026gt; task3 = () -\u0026gt; { Thread.sleep(5000); return \u0026#34;Result of Task3\u0026#34;; }; // Returns the result of the fastest callable. (task2 in this case) String result = executorService.invokeAny(Arrays.asList(task1, task2, task3)); System.out.println(result); executorService.shutdown(); } } 输出如下：\nResult of Task2 Future 的局限 不能手动完成。（Future调用的任务失败了不能手动进行完成） Future 的结果在非阻塞的情况下，不能执行更进一步的操作。（无法给 Future 植入一个回调函数） 多个 Future 不能串联在一起组成链式调用。 不能组合多个 Future 的结果。 没有异常处理。 CompletableFuture简介 并发与并行的区别：\n避免阻塞，应用通过 与各种网络服务通信，替用户实时整合需要的信息，或者将整合的信息作为进一步的网络服务 提供出去。这种工作方式被称为反应式编程。\nCompletableFuture能够解决什么问题？ CompletableFuture是Java8引入的，在Java8之前一般通过Future实现异步。(但是是阻塞的)\nFuture模式可以理解成：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。\nCompletableFuture具备什么功能？ 可组合。（提供thenCompose、thenCombine等各种then开头的方法） 异步。 比较 CompletableFuture是Java8引入的，在Java8之前一般通过Future实现异步。\nFuture用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的“回调地狱”。\nCompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。\n假设有三个操作存在依赖关系，step1 -\u0026gt; step2 -\u0026gt; step3需要前面步骤执行成功再执行后面步骤。\nFuture(ListenableFuture)的实现（回调地狱）如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ExecutorService executor = Executors.newFixedThreadPool(5); ListeningExecutorService guavaExecutor = MoreExecutors.listeningDecorator(executor); ListenableFuture\u0026lt;Object\u0026gt; future1 = guavaExecutor.submit(() -\u0026gt; { //step 1 System.out.println(\u0026#34;执行step1\u0026#34;); return true; }); Futures.addCallback(future1, new FutureCallback\u0026lt;Object\u0026gt;() { @Override public void onSuccess(Object step1Result) { ListenableFuture\u0026lt;Object\u0026gt; future2 = guavaExecutor.submit(() -\u0026gt; { System.out.println(\u0026#34;执行step 2\u0026#34;); return true; }); Futures.addCallback(future2, new FutureCallback\u0026lt;Object\u0026gt;() { @Override public void onSuccess(Object result) { ListenableFuture\u0026lt;Object\u0026gt; future3 = guavaExecutor.submit(() -\u0026gt; { System.out.println(\u0026#34;执行step 3\u0026#34;); return true; }); Futures.addCallback(future3, new FutureCallback\u0026lt;Object\u0026gt;() { @Override public void onSuccess(Object result) { System.out.println(\u0026#34;这是step 3执行结果\u0026#34;); } @Override public void onFailure(Throwable t) { } }, guavaExecutor); } @Override public void onFailure(Throwable t) { } }, guavaExecutor); System.out.println(\u0026#34;执行step2\u0026#34;); } @Override public void onFailure(Throwable throwable) { } }, guavaExecutor); CompletableFuture的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ExecutorService executor = Executors.newFixedThreadPool(5); CompletableFuture .supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;执行step 1\u0026#34;); return new Object(); }, executor) .thenApply(result1 -\u0026gt; { System.out.println(\u0026#34;执行step 2\u0026#34;); return new Object(); }) .thenApply(result1 -\u0026gt; { System.out.println(\u0026#34;执行step 3\u0026#34;); return new Object(); }); 显然，CompletableFuture的实现要更为简洁，可读性更好。\n使用 简单使用 创建CompletableFuture：\n1 CompletableFuture\u0026lt;String\u0026gt; completableFuture = new CompletableFuture\u0026lt;String\u0026gt;(); 表示创建了一个返回值为String的CompletableFuture的对象。\n同样，类似Future，CompletableFuture也使用get方法获取返回结果，这也是阻塞的，当我们直接运行下面的语句：\n1 String result = completableFuture.get() 它将一直处于阻塞状态。\n可以使用CompletableFuture.complete()手工的完成一个 Future:\n1 completableFuture.complete(\u0026#34;Future\u0026#39;s Result\u0026#34;); 所有等待这个 Future 的客户端都将得到一个指定的结果，并且 completableFuture.complete() 之后的调用将被忽略。\nrunAsync() 这个适用于无返回值的异步执行。\nCompletableFuture.runAsync()方法，它持有一个Runnable 对象，并返回 CompletableFuture\u0026lt;Void\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Run a task specified by a Runnable Object asynchronously. CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.runAsync(new Runnable() { @Override public void run() { // Simulate a long-running Job try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } System.out.println(\u0026#34;I\u0026#39;ll run in a separate thread than the main thread.\u0026#34;); } }); // Block and wait for the future to complete future.get() 或者：\n1 2 3 4 5 6 7 8 9 10 // Using Lambda Expression CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.runAsync(() -\u0026gt; { // Simulate a long-running Job try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } System.out.println(\u0026#34;I\u0026#39;ll run in a separate thread than the main thread.\u0026#34;); }); supplyAsync() 适用于有返回值的异步计算。\nCompletableFuture.supplyAsync() 持有supplier\u0026lt;T\u0026gt; 并且返回CompletableFuture\u0026lt;T\u0026gt;，T 是通过调用 传入的supplier取得的值的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Run a task specified by a Supplier object asynchronously CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(new Supplier\u0026lt;String\u0026gt;() { @Override public String get() { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \u0026#34;Result of the asynchronous computation\u0026#34;; } }); // Block and get the result of the Future String result = future.get(); System.out.println(result); 或者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Run a task specified by a Supplier object asynchronously CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(new Supplier\u0026lt;String\u0026gt;() { @Override public String get() { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \u0026#34;Result of the asynchronous computation\u0026#34;; } }); // Block and get the result of the Future String result = future.get(); System.out.println(result); 最好加上一个线程池的参数，不然默认从全局的 ForkJoinPool.commonPool()获得一个线程中执行这些任务。\n// Variations of runAsync() and supplyAsync() methods static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable) static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable, Executor executor) static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier) static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier, Executor executor) 上面的几个方法其实还是阻塞的。它会一直等到Future完成并且在完成后返回结果。这不是我们想要的，我们想要的是在它执行完成之后调用我们自己的逻辑。对于构建异步系统，我们应该附上一个回调给CompletableFuture，当Future完成的时候，自动的获取结果。\n可以使用 thenApply(), thenAccept() 和thenRun()方法附上一个回调给CompletableFuture。\nthenApply() 实现调用链。\n使用 thenApply() 处理和改变CompletableFuture的结果。持有一个Function\u0026lt;R,T\u0026gt;作为参数。Function\u0026lt;R,T\u0026gt;是一个简单的函数式接口，接受一个T类型的参数，产出一个R类型的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Create a CompletableFuture CompletableFuture\u0026lt;String\u0026gt; whatsYourNameFuture = CompletableFuture.supplyAsync(() -\u0026gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \u0026#34;Rajeev\u0026#34;; }); // Attach a callback to the Future using thenApply() CompletableFuture\u0026lt;String\u0026gt; greetingFuture = whatsYourNameFuture.thenApply(name -\u0026gt; { return \u0026#34;Hello \u0026#34; + name; }); // Block and get the result of the future. System.out.println(greetingFuture.get()); // Hello Rajeev thenAccept() 和 thenRun() 如果你不想从你的回调函数中返回任何东西，仅仅想在Future完成后运行一些代码片段，你可以使用thenAccept() 和 thenRun()方法，这些方法经常在调用链的最末端的最后一个回调函数中使用。\nCompletableFuture.thenAccept() 持有一个Consumer\u0026lt;T\u0026gt; ，返回一个CompletableFuture\u0026lt;Void\u0026gt;。它可以访问CompletableFuture的结果：\n1 2 3 4 5 6 // thenAccept() example CompletableFuture.supplyAsync(() -\u0026gt; { return ProductService.getProductDetail(productId); }).thenAccept(product -\u0026gt; { System.out.println(\u0026#34;Got product detail from remote service \u0026#34; + product.getName()) }); 虽然thenAccept()可以访问CompletableFuture的结果，但thenRun()不能访Future的结果，它持有一个Runnable返回CompletableFuture：\n1 2 3 4 5 6 // thenRun() example CompletableFuture.supplyAsync(() -\u0026gt; { // Run some computation }).thenRun(() -\u0026gt; { // Computation Finished. }); thenCompose()-组合 组合两个独立的future。\n原来假设想从一个远程API中获取一个用户的详细信息，一旦用户信息可用，你想从另外一个服务中获取他的贷方。代码是这样的：\n1 2 3 4 5 6 7 8 9 10 11 CompletableFuture\u0026lt;User\u0026gt; getUsersDetail(String userId) { return CompletableFuture.supplyAsync(() -\u0026gt; { UserService.getUserDetails(userId); }); } CompletableFuture\u0026lt;Double\u0026gt; getCreditRating(User user) { return CompletableFuture.supplyAsync(() -\u0026gt; { CreditRatingService.getCreditRating(user); }); } 使用了thenApply()可以进行异步调用，并且代码非常简洁：\n1 2 CompletableFuture\u0026lt;CompletableFuture\u0026lt;Double\u0026gt;\u0026gt; result = getUserDetail(userId) .thenApply(user -\u0026gt; getCreditRating(user)); 在更早的示例中，Supplier函数传入thenApply将返回一个简单的值，但是在本例中，将返回一个CompletableFuture。以上示例的最终结果是一个嵌套的CompletableFuture。\n如果你想获取最终的结果给最顶层future，使用 thenCompose()方法代替\n1 2 CompletableFuture\u0026lt;Double\u0026gt; result = getUserDetail(userId) .thenCompose(user -\u0026gt; getCreditRating(user)); thenCombine()-组合操作 虽然thenCompose()被用于当一个future依赖另外一个future的时候用来组合两个future。thenCombine()被用来当两个独立的Future都完成的时候，用来做一些事情。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 System.out.println(\u0026#34;Retrieving weight.\u0026#34;); CompletableFuture\u0026lt;Double\u0026gt; weightInKgFuture = CompletableFuture.supplyAsync(() -\u0026gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } return 65.0; }); System.out.println(\u0026#34;Retrieving height.\u0026#34;); CompletableFuture\u0026lt;Double\u0026gt; heightInCmFuture = CompletableFuture.supplyAsync(() -\u0026gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } return 177.8; }); System.out.println(\u0026#34;Calculating BMI.\u0026#34;); CompletableFuture\u0026lt;Double\u0026gt; combinedFuture = weightInKgFuture .thenCombine(heightInCmFuture, (weightInKg, heightInCm) -\u0026gt; { Double heightInMeter = heightInCm/100; return weightInKg/(heightInMeter*heightInMeter); }); System.out.println(\u0026#34;Your BMI is - \u0026#34; + combinedFuture.get()); 当两个Future都完成的时候，传给thenCombine()的回调函数将被调用。\n前面都是组合两个的CompletableFuture方法，可以使用以下两个方法组合任意数量的CompletableFuture。\n1 2 static CompletableFuture\u0026lt;Void\u0026gt; allOf(CompletableFuture\u0026lt;?\u0026gt;... cfs) static CompletableFuture\u0026lt;Object\u0026gt; anyOf(CompletableFuture\u0026lt;?\u0026gt;... cfs) CompletableFuture.allOf()-组合多个（全部） CompletableFuture.allOf的使用场景是当你一个列表的独立future，并且你想在它们都完成后并行的做一些事情。\n一般是一次数据的请求需要调用多个服务进行查询，可以使用这种方法加快操作的速度。但是，对于同一个服务的循环差其实没有实质性的提高。\n定义一个下载页面的方法:\n1 2 3 4 5 CompletableFuture\u0026lt;String\u0026gt; downloadWebPage(String pageLink) { return CompletableFuture.supplyAsync(() -\u0026gt; { // Code to download and return the web page\u0026#39;s content }); } 下载一个网站的100个不同的页面，使用allof方法：\n1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; webPageLinks = Arrays.asList(...) // A list of 100 web page links // Download contents of all the web pages asynchronously List\u0026lt;CompletableFuture\u0026lt;String\u0026gt;\u0026gt; pageContentFutures = webPageLinks.stream() .map(webPageLink -\u0026gt; downloadWebPage(webPageLink)) .collect(Collectors.toList()); // Create a combined Future using allOf() CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf( pageContentFutures.toArray(new CompletableFuture[pageContentFutures.size()]) ); 使用CompletableFuture.allOf()的问题是它返回CompletableFuture。但是我们可以通过写一些额外的代码来获取所有封装的CompletableFuture结果。\n1 2 3 4 5 6 // When all the Futures are completed, call `future.join()` to get their results and collect the results in a list - CompletableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; allPageContentsFuture = allFutures.thenApply(v -\u0026gt; { return pageContentFutures.stream() .map(pageContentFuture -\u0026gt; pageContentFuture.join()) .collect(Collectors.toList()); }); 当所有future完成的时候，我们调用了future.join()，因此我们不会在任何地方阻塞。\njoin()方法和get()方法非常类似，这唯一不同的地方是如果最顶层的CompletableFuture完成的时候发生了异常，它会抛出一个未经检查的异常。\n现在让我们计算包含关键字页面的数量。\n1 2 3 4 5 6 7 8 9 // Count the number of web pages having the \u0026#34;CompletableFuture\u0026#34; keyword. CompletableFuture\u0026lt;Long\u0026gt; countFuture = allPageContentsFuture.thenApply(pageContents -\u0026gt; { return pageContents.stream() .filter(pageContent -\u0026gt; pageContent.contains(\u0026#34;CompletableFuture\u0026#34;)) .count(); }); System.out.println(\u0026#34;Number of Web Pages having CompletableFuture keyword - \u0026#34; + countFuture.get()); CompletableFuture.anyOf()-组合多个（任意） CompletableFuture.anyOf()和其名字介绍的一样，当任何一个CompletableFuture完成的时候【相同的结果类型】，返回一个新的CompletableFuture。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u0026gt; { try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \u0026#34;Result of Future 1\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; future2 = CompletableFuture.supplyAsync(() -\u0026gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \u0026#34;Result of Future 2\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; future3 = CompletableFuture.supplyAsync(() -\u0026gt; { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { throw new IllegalStateException(e); } return \u0026#34;Result of Future 3\u0026#34;; }); CompletableFuture\u0026lt;Object\u0026gt; anyOfFuture = CompletableFuture.anyOf(future1, future2, future3); System.out.println(anyOfFuture.get()); // Result of Future 2 当三个中的任何一个CompletableFuture完成， anyOfFuture就会完成。因为future2的休眠时间最少，因此她最先完成，最终的结果将是future2的结果。\nCompletableFuture.anyOf()传入一个Future可变参数，返回CompletableFuture。CompletableFuture.anyOf()的问题是如果你的CompletableFuture返回的结果是不同类型的，这时候你讲会不知道你最终CompletableFuture是什么类型。\n异常处理 1. 使用 exceptionally() 回调处理异常\nexceptionally()回调给你一个从原始Future中生成的错误恢复的机会。你可以在这里记录这个异常并返回一个默认值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Integer age = -1; CompletableFuture\u0026lt;String\u0026gt; maturityFuture = CompletableFuture.supplyAsync(() -\u0026gt; { if(age \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;Age can not be negative\u0026#34;); } if(age \u0026gt; 18) { return \u0026#34;Adult\u0026#34;; } else { return \u0026#34;Child\u0026#34;; } }).exceptionally(ex -\u0026gt; { // 在此处打印相关的日志，返回值需要特别注意，可以返回一个指定的值，然后在后面进行过滤 System.out.println(\u0026#34;Oops! We have an exception - \u0026#34; + ex.getMessage()); return \u0026#34;Unknown!\u0026#34;; }); System.out.println(\u0026#34;Maturity : \u0026#34; + maturityFuture.get()); 2. 使用 handle() 方法处理异常\nAPI提供了一个更通用的方法 - handle()从异常恢复，无论一个异常是否发生它都会被调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Integer age = -1; CompletableFuture\u0026lt;String\u0026gt; maturityFuture = CompletableFuture.supplyAsync(() -\u0026gt; { if(age \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;Age can not be negative\u0026#34;); } if(age \u0026gt; 18) { return \u0026#34;Adult\u0026#34;; } else { return \u0026#34;Child\u0026#34;; } }).handle((res, ex) -\u0026gt; { if(ex != null) { System.out.println(\u0026#34;Oops! We have an exception - \u0026#34; + ex.getMessage()); return \u0026#34;Unknown!\u0026#34;; } return res; }); System.out.println(\u0026#34;Maturity : \u0026#34; + maturityFuture.get()); 如果异常发生，res参数将是 null，否则，ex将是 null。\n区别 supplyAsync：\n当只是指定第一个参数，默认使用的线程池是 ForkJoinPool.commonPool() 当指定第二个线程池的参数，使用的是自定义的线程 supplyAsync表示开启一个有返回值的异步任务。\n可以使用 thenAccept 和 thenApply 给它增加回调函数。同样，thenAccept 和 thenApply 也有同样的异步函数thenAcceptAsync 和 thenApplyAsync ，可以让逻辑执行在设定的线程池上。\n同步和异步的区别：\n假设我们想一次向同一个接收者发送两条消息。\n1 2 3 4 CompletableFuture\u0026lt;String\u0026gt; receiver = CompletableFuture.supplyAsync(this::findReceiver); receiver.thenApply(this::sendMsg); receiver.thenApply(this::sendOtherMsg); 在上面的例子中，一切都将在同一个线程上执行。这导致最后一条消息等待第一条消息完成。\n考虑这个代码:\n1 2 3 4 5 CompletableFuture\u0026lt;String\u0026gt; receiver = CompletableFuture.supplyAsync(this::findReceiver); receiver.thenApplyAsync(this::sendMsg); receiver.thenApplyAsync(this::sendMsg); 通过使用async后缀，每个消息被作为单独的任务提交给ForkJoinPool.commonPool()。这导致在完成前面的计算时，sendMsg的回调都被执行。\n一个测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //thenApply和thenApplyAsync的区别 System.out.println(\u0026#34;-------------\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; supplyAsyncWithSleep = CompletableFuture.supplyAsync(()-\u0026gt;{ try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;supplyAsyncWithSleep Thread Id : \u0026#34; + Thread.currentThread(); }); CompletableFuture\u0026lt;String\u0026gt; thenApply = supplyAsyncWithSleep .thenApply(name -\u0026gt; name + \u0026#34;------thenApply Thread Id : \u0026#34; + Thread.currentThread()); CompletableFuture\u0026lt;String\u0026gt; thenApplyAsync = supplyAsyncWithSleep .thenApplyAsync(name -\u0026gt; name + \u0026#34;------thenApplyAsync Thread Id : \u0026#34; + Thread.currentThread()); System.out.println(\u0026#34;Main Thread Id: \u0026#34;+ Thread.currentThread()); System.out.println(thenApply.get()); System.out.println(thenApplyAsync.get()); System.out.println(\u0026#34;-------------No Sleep\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; supplyAsyncNoSleep = CompletableFuture.supplyAsync(()-\u0026gt;{ return \u0026#34;supplyAsyncNoSleep Thread Id : \u0026#34; + Thread.currentThread(); }); CompletableFuture\u0026lt;String\u0026gt; thenApplyNoSleep = supplyAsyncNoSleep .thenApply(name -\u0026gt; name + \u0026#34;------thenApply Thread Id : \u0026#34; + Thread.currentThread()); CompletableFuture\u0026lt;String\u0026gt; thenApplyAsyncNoSleep = supplyAsyncNoSleep .thenApplyAsync(name -\u0026gt; name + \u0026#34;------thenApplyAsync Thread Id : \u0026#34; + Thread.currentThread()); System.out.println(\u0026#34;Main Thread Id: \u0026#34;+ Thread.currentThread()); System.out.println(thenApplyNoSleep.get()); System.out.println(thenApplyAsyncNoSleep.get()); 分别测试执行不同处理速度的代码，thenApply 和 thenApplyAsync 使用的是哪个线程：\n------------- Main Thread Id: Thread[main,5,main] supplyAsyncWithSleep Thread Id : Thread[ForkJoinPool.commonPool-worker-9,5,main]------thenApply Thread Id : Thread[ForkJoinPool.commonPool-worker-9,5,main] supplyAsyncWithSleep Thread Id : Thread[ForkJoinPool.commonPool-worker-9,5,main]------thenApplyAsync Thread Id : Thread[ForkJoinPool.commonPool-worker-9,5,main] -------------No Sleep Main Thread Id: Thread[main,5,main] supplyAsyncNoSleep Thread Id : Thread[ForkJoinPool.commonPool-worker-2,5,main]------thenApply Thread Id : Thread[main,5,main] supplyAsyncNoSleep Thread Id : Thread[ForkJoinPool.commonPool-worker-2,5,main]------thenApplyAsync Thread Id : Thread[ForkJoinPool.commonPool-worker-2,5,main] 可以看到\nsupplyAsync方法执行速度慢的话thenApply方法执行线程和supplyAsync 执行线程相同 supplyAsync 方法执行速度快的话，那么thenApply方法执行线程和Main方法执行线程相同 返回值 方法名 是否可获得前一个任务的返回值 是否有返回值 thenApply 能获得 有 thenAccept 能获得 无 thenRun 不可获得 无 所以一般来说thenAccept 、thenRun 这两个方法在调用链的最末端使用。\n二元依赖 thenCombine:两个异步方法得出来值的情况下才能进行计算 thenCompose:二个定时任务需要用到第一个定时任务的返回值 runAfterBoth 二选一：acceptEither\nfirstSource.acceptEither(secondSource, this::sendMsg);\n总结 CompletableFuture使用get方法和join方法会阻塞后续的操作。 不阻塞的话并且不需要返回值可以直接不显示的使用get方法和join方法。 使用场景 你以前可能接触过 CompletableFuture 对象背后的概念，在其他语言中这被 叫作延迟对象或约定。在Google Guava类库和Spring框架中，这被叫作 ListenableFutures。\n多服务调用 实际的情况可能是这样子\n多线程组装数据。 每一个分片数据都用一个CompletableFuture执行。\nJoin，它的作用和 get 方法 是一样的，而且它没有使用 get 方法时令人倒胃口的检查异常。\njoin抛出unchecker异常，而get抛出checked异常\n混合使Stream和CompletableFuture的时候需要注意⚠️：\n考虑操作之间的延迟特性，如何你在单一流水线中处理流，每个创建CompletableFuture 对象只能在前一个操作结束之后才能创建。\n最好是将CompletableFuture先聚集到一个列表中。然后再屌用join。\n原理 通常，设计和理解并发系统最好的方式是使用图形:\n上面的图形可以使用下面的代码来实现：\n1 2 int t = p(x); System.out.println( r(q1(t), q2(t)) ); 使用Future方法：\n1 2 3 4 int t = p(x); Future\u0026lt;Integer\u0026gt; a1 = executorService.submit(() -\u0026gt; q1(t)); Future\u0026lt;Integer\u0026gt; a2 = executorService.submit(() -\u0026gt; q2(t)); System.out.println( r(a1.get(),a2.get())); CompletableFuture使用的是一种观察者模式进行实现的。\n使用CompletableFuture也是构建依赖树的过程，一个CompletableFuture的完成会触发另外一系列依赖它的CompletableFuture的执行：\nJava实战 我们实际的开发过程中，总是需要调用多个服务，假如没有使用并发进行编程，那么，在一个服务返回结果之前，这都是阻塞的，不能执行其他的任务。然而，你并不希望由于要等待远程服务的响应，阻塞现有的计算任务并白白浪费 CPU 中数十亿个宝贵的时􏲁􏵑期。譬 如，你不应该由于要等待 Facebook 数据的返回而􏵒止对 Twitter 数据的处理。\nJava的并发之路 一开始就提供了锁(通过 synchronized 类和方法)、Runnable 以及线程。 2004 年， Java 5 又引入了 java.util.concurrent 包。（引入ExecutorService、Callable以及 Future） Java 7 为了使用 fork/join 实现分而􏵬之算法，新 增了java.util.concurrent.RecursiveTask Java 8则增加了对流和流的并行处理(依赖于新增的 Lambda 表达式)的支持 Java 8还支持组合式的Future(基于Java 8CompleteFuture实现的Future） Java 9 提供了对分布式异步编程的显式支持。（通过 java.util.concurrent.Flow 接口） CompletableFuture 及 java.util.concurrent.Flow 的关键理念是提供一种程序结构，让相互独立的任务尽可能地并发执行，通过这种方式最大化地利用多核或者多台机器提供的并发能力。\n多线程并发内幕 在一个多核的环境中，单用户登录的笔记本电脑上可能只启动了一个用户进程，这种程序永远不能充分发挥计算机的处理能力，除非使用多线程。虽然每个核可以服务一个或多个进程或线程，但是如果你的程序并未使用多线程，那它同一时刻能有效使用的只有处理器众多核中的一个。\n这需要我们在编写代码的时候注意使用多线程并发编程，以充分发挥计算机的处理能力。\n线程的问题\nJava 线程直接访问操作系统的线程。这里主要的问题在于创建和􏳒除操作系统线程的代价很 大(涉及页表操作)，并且一个系统中能创建的线程数目是有限的。如果创建的线程数超过操作系统的限制，很可能导致 Java 应用莫名其妙地崩溃，因此你需要特别留意，不要在线程运行时 持续不断地创建新线程。并且操作系统(以及 Java)的线程数都远远大于硬件线程数，因此即便一些操作系统线程被阻塞了，或者处于睡眠状态。\n线程池的优势\nJava 的 ExecutorService 提供了一个接口，用户可以提交任务并获取它们的执行结果。新创建 的线程会被放入一个线程池，每次有新任务请求时，以先来先到的􏵼略从线程池中选取未被使用 的线程执行提交的任务请求。任务执行完毕之后，这些线程又会被归还给线程池。这种方式的最大优势在于能以很低的成本向线程池提交上千个任务，同时保证硬件匹配的任务执行。\n线程池的不足\n使用 k 个线程的线程池只能并发地执行 k 个任务\n提交的任务如果超过这个限制，线程池不会创建新线程去执行该任务，这些超限的任务会被加入等待队列，直到现有任务执行 完毕才会重新调度空闲线程去执行新任务。\n采用这种方式时你 需要特别留意任务是否存在会进入睡眠、等待 I/O 结􏰅或者等待网络连接的情况。一旦发 生阻塞式 I/O，这些任务占用了线程，却会由于等待无法执行有价值的工作。\n例如，假如CPU有4个硬件线程，你创建了一个大小为5的线程池，你一次性提交了 20 个执行任务，希望这20个任务并发的执行，直到所有 20 个任务执行完毕。假设首批提交的 线程中有 3 个线程进入了阻塞状态或者在等待 I/O，那就只剩2 个线程可以服务剩下的 15 个任务了。如此一来，你只能取得你之前预期吞吐量的一半(如果你创建的线程池中工 作线程数为 8，那么还是能取得同样预期吞吐量的)。\n通常情况下，Java 从 main 返回之前，都会等待所有的线程执行完毕，从而避免误杀正在执行关键代码的线程。\n实际操作时的一个好习惯是在退出程序执行之前，确保关闭每一个线程池。\n你希望采用线程技术理程序的结构，以便在需要的时候享受程序并行带来的好处，生成足够多的任务以充分利用所有硬件线程。这意味着你需要对程序进行切分。\n使多线程的演进过程 多于函数 f(x) 和 g(x)，分别使用一个线程去并发执行。\n使用Runnable：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class ThreadExample { public static void main(String[] args) throws InterruptedException { int x = 1337; Result result = new Result(); Thread t1 = new Thread(() -\u0026gt; { result.left = f(x); } ); Thread t2 = new Thread(() -\u0026gt; { result.right = g(x); }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(result.left + result.right); } private static class Result { private int left; private int right; } } 使用线程池和Future：\n1 2 3 4 5 6 7 8 9 10 public class ExecutorServiceExample { public static void main(String[] args) throws ExecutionException, InterruptedException { int x = 1337; ExecutorService executorService = Executors.newFixedThreadPool(2); Future\u0026lt;Integer\u0026gt; y = executorService.submit(() -\u0026gt; f(x)); Future\u0026lt;Integer\u0026gt; z = executorService.submit(() -\u0026gt; g(x)); System.out.println(y.get() + z.get()); executorService.shutdown(); } } 然而，这段代码依然受到了显式调用 submit 时使用的模板代码的污染。也就是说，其实这个枯燥的操作其实也是可以省略的。\n解决这个问题的答案是将 API 由同步 API 变为步 API，也就是增加异步的API函数。\n使用线程池和CompletableFuture：\n1 2 3 4 5 6 7 8 9 10 11 public class ExecutorServiceExample { public static void main(String[] args) throws ExecutionException, InterruptedException { int x = 1337; ExecutorService executorService = Executors.newFixedThreadPool(2); CompletableFuture\u0026lt;Integer\u0026gt; y = CompletableFuture.supplyAsync(() -\u0026gt; f(x),executorService); CompletableFuture\u0026lt;Integer\u0026gt; z = CompletableFuture.supplyAsync(() -\u0026gt; g(x),executorService); CompletableFuture\u0026lt;Integer\u0026gt; result = y.thenCombine(z,(y_val,z_val) -\u0026gt; {return y_val + z_val;} ) System.out.println(result.get()); executorService.shutdown(); } } 使用反应式的API：(基于回调函数)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class CallbackStyleExample { public static void main(String[] args) { System.out.println((result.left + result.right)); int x = 1337; Result result = new Result(); f(x, (int y) -\u0026gt; { result.left = y; }); g(x, (int z) -\u0026gt; { result.right = z; System.out.println((result.left + result.right)); 7 }); } } 注意，反应式编程允许方法 f 和 g 多次调用它们的回调函数 dealWithResult。而原始版\n本的 f 和 g 使用 return 返回结果，return 只能被调用一次。Future 与此类似，它也只能完 成一次，执行 Future 的计算结果可以通过 get()方法获取。\n可能阻塞线程的因素 阻塞式操作可以分为两类:\n一类是等待另一个任务执行，譬如调用 Future 的 get()方法; 另一类是等待与外部交互的返回，譬如从网络、数据库服务器或者键盘这样的人机接口读取数据。 睡眠也会阻塞。\n学习并发的模式 通常，设计和理解并发系统最好的方式是使用图形。我们将这种技术称线程-管道 (box-and-channel)模型。\n这其实是观察者模式的一种实现。\n使用CompletableFuture CompletableFuture和并行流的实现方式类似的，它们内部都是调用多线程进行执行，然而CompletableFuture可以允许设置线程池，指定线程的数量（线程池的大小），并且支持组合模式。\n并行流是把内容拆分成多个数据块，用不同线程处理每个数据块的数据。这样以来，就可以自动的把工作的负荷分配到多核处理器的所有核，让他们都忙起来。\n使用Async还是同步API的判断标准：\n一般情况下操作不涉及远程服务和I/O操作，可以采用同步API 其他耗时的操作可以使用异步API。 通常而言，名称中不带Async的方法和它的前一个任务一样，在同一个线程中运行，而名称以Async结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。对于不复杂的延迟低的操作，尽量复用同一个进程，减少进程间切换的开销。\nJava中的线程池 参考：《Java并发编程的艺术》\n线程池的好处 降低资源损耗。 提高响应速度。 提高线程的可管理性。 Reference:\n彻底理解Java的Future模式 - 大诚挚 - 博客园 CompletableFuture的原理与实践-记外卖商家端API的异步化 Java 8 CompletableFuture 教程 - SegmentFault 思否 关于实现Runnable接口不能抛异常只能捕获异常原因_小林子的博客-CSDN博客 Java Callable and Future Tutorial | CalliCoder ~ Java可调用和未来教程 | CalliCoder 使用CompletableFuture异步组装数据 Java: Writing asynchronous code with CompletableFuture Java8——异步编程 - Mr.墨斗的博客 | MoDou Blog ","description":"CompletableFuture使用观察者模式封装了多线程的并发，方便开发人员的使用。","id":4,"section":"posts","tags":["java","CompletableFuture","开发方法论"],"title":"CompletableFuture使用笔记","uri":"https://hugo.jiahongw.com/zh/posts/dev/completable-future/"},{"content":" 原则 设计原则 单一职责原则\nSingle Responsibility Principle，一个类应该只负责一个职责。\n开闭原则\nOpen-Closed Principle, OCP，一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。\n里氏替换原则\nLiskov Substitution Principle, LSP，所有引用基类（父类）的地方必须能透明地使用其子类的对象。（其实就是使用多态）\n依赖注入原则\nDependence Inversion Principle, DIP，抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n关键点为：\n高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 接口分离原则\nInterface Segregation Principle, ISP，使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n迪米特原则\nLaw of Demeter 又名Least Knowledge Principle, LoD，一个软件实体应当尽可能少地与其他实体发生相互作用。\n体现了封装的思想。\n设计模式分类一览 单例模式 单例模式: 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点 定义：\n单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n架构：比较简单，不画了。\n使用场景：\n线程池 缓存 对话框 注册表对象 日志对象 状态模式 状态模式: 状态模式允许对象在内部状态发生改变时改变它的行为 定义：\n状态模式允许对象在内部状态发生改变时改变它的行为。（对象看起来好像改变了它的类）\n架构：\n实现方法：\n分支逻辑法 查表法 状态模式 使用场景：\n状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。或者在一些单据的流转上也可以使用状态模式。 状态模式可以随着时间改变状态，从而执行不同的行为；但是策略模式是事先准备好多种策略，在开始的时候选择了一种策略就是一直使用这种策略进行处理。（可以说，状态模式运行时使用了所有的状态，而策略模式在运行时只使用了一种策略） 策略模式 策略模式: 策略模式定义了算法族，分别封装起来，让他们之间可以互相替换 定义：\n策略模式定义了算法族，分别封装起来，让他们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。\n架构：\n策略定义：\nclassDiagram Strategy \u0026lt;|-- StrategyA : implements Strategy \u0026lt;|-- StrategyB : implements Strategy : algorithmInterface() StrategyA : algorithmInterface() StrategyB : algorithmInterface() 策略创建：\nclassDiagram Strategy \u0026lt;|-- StrategyA : implements Strategy \u0026lt;|-- StrategyB : implements Strategy : algorithmInterface() StrategyA : algorithmInterface() StrategyB : algorithmInterface() StrategyFactory --\u0026gt; Strategy : 关联 StrategyFactory : getStrategy(type) 无状态策略：无状态的策略因为不会变，可以进行缓存，一开始就创建好所有的策略即可。（直接从map中拿取） 有状态策略：有状态的策略因为会改变，所以每次创建都需要是一个最新的策略对象。（在工厂类中存在if-else判断） 策略使用：\n​\ngraph TD; 拿取策略:getStrategy--\u0026gt;使用策略接口:algorithmInterface; 从工厂类中拿取策略。 调用策略对应的接口函数。 使用场景：\n避免冗长的if-else或switch分支判断 提供框架的扩展点 模版方法模式 模版方法模式: 模板方法模式是对抽象的有一种体现，这次，抽象的是算法流程。模板方法定义了一个算法的步骤，将允许子类为一个或者多个步骤提供实现 定义：\n模板方法模式在一个方法中定义一个算法的架构，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。\n架构：\n使用场景：\n复用\n因为模板方法是基于继承实现，可以将固定的算法步骤封装在抽象类，抽象类可以实现一些固定的步骤，子类直接进行复用就可以了。\n框架拓展性\nHttpServlet的service()方法就是一个模板方法，它实现了整个http请求的执行流程，而doGet()和doPost()是模板中可以由子类自定义的部分。相当于框架为用户提供了拓展点，使得不需要修改框架源码就能将拓展点添加到框架中。 Junit框架也提供了一些功能拓展点setUp()和setDown()，可以在开始和结束的时候做一些事情，而runBase()函数是一个模板方法，定义了执行测试用例的整体流程。 策略模式和模板方法模式都封装算法，但是一个组合，一个继承。 工厂方法是模板方法的一个特殊版本。 适配器模式 适配器使得新的调用可以适配老的接口而不需要修改旧的代码。达到了对拓展开发，对修改关闭的设计原则。\n定义：\n适配器将一个类的接口，转换成客户端期望的另一个接口。适配器让原本不兼容的类达到兼容。（可以让客户从实现的接口解耦）\nUSB转接头就是一个适配器！\n架构:\n在支持多重继承的语言中，可以使用类适配器是这样的：\n使用场景：\n一般来说，适配器模式可以看作是一宗“补偿模式”，用来补救设计上的缺陷，也是一种无奈之举。一般也不会优先推荐使用这种模式。 封装有缺陷的接口\n例如外部引入的接口都是静态方法，会影响代码的可测试性。此时使用适配器进行适配接口，将静态方法都“封装“起来，这样就可以进行测试了。\n”缺陷“可以理解为在某些方面不足。通过封装之后达到解决问题的效果就是适配器作用。\n替换依赖的外部系统\n当需要将外部依赖的一个系统替换成另一个系统的时候，也就是一些系统迁移或者接口切换的场景，使用适配器模式可以减少对代码的改动。\n兼容老版本的接口\n在进行一些版本升级的时候，对于一些废弃的接口，我们不会直接删除，而是暂时保留，并且标注为deprecate，并且将内部实现逻辑委托为新的实现逻辑。\n例如JDK中包含一个遍历集合容器的类Enumeration，JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是如果将Enumeration直接从JDK2.0删除，那么那些从JDK1.0升级到JDK2.0的项目，就会编译报错。但是修改散落在各处的Enumeration调用又多又杂，导致升级困难。为了避免这种情况，可以暂时保留Enumeration类，并且将其内部实现替换为Iterator的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Collections { public static Emueration emumeration(final Collection c) { return new Enumeration() { Iterator i = c.iterator(); public boolean hasMoreElments() { return i.hashNext(); } public Object nextElement() { return i.next(): } } } } 装饰器包装一个实现同一个接口的类对象，添加一些责任，并且接口不变；适配器则包装实现不同接口的被适配的对象，进行接口的转换和适配，以达到兼容的效果。 工厂方法模式 工厂方法模式: 相对于直接new来创建对象，用工厂模式来创建会更加灵活 当我们使用new创建一个对象的时候，需要指定一个具体类，这就是针对实现进行编程。当我们将创建对象的过程封装成一个方法或者接口的时候，就可以避免针对实现编程，变成针对接口编程。\n定义：\n工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法将实例化推迟到子类。\n核心在将创建对象的过程解耦出来。\n架构：\n工厂模式体现了一个原则：依赖倒置原则。（Spring叫依赖反转）\n关键点:\n工厂只有一个功能——创建指定的类。（单一职责） 将原来的if-else判断，转换成对象进行处理。 抽象成一个方法 -》 抽象成一个类 -〉 抽象成一个接口 抽象工厂模式\n定义：抽象工厂模式提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类\n架构：\nclassDiagram class AbstractFactory { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; + createProductA() + createProductB() } class ConcreteFactoory1 { + createProductA() + createProductB() } class ConcreteFactoory2 { + createProductA() + createProductB() } class AbstractProductA { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProducttA1 class ProducttA2 ProducttA1 ..|\u0026gt; AbstractProductA : 实现 ProducttA2 ..|\u0026gt; AbstractProductA : 实现 class AbstractProductB { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProducttB1 class ProducttB2 ProducttB1 ..|\u0026gt; AbstractProductB : 实现 ProducttB2 ..|\u0026gt; AbstractProductB : 实现 AbstractFactory \u0026lt;|.. ConcreteFactoory1 : 实现 AbstractFactory \u0026lt;|.. ConcreteFactoory2 : 实现 ConcreteFactoory1 --\u0026gt;ProducttA1 : 创建 ConcreteFactoory1 --\u0026gt;ProducttB1 : 创建 ConcreteFactoory2 --\u0026gt;ProducttA2 : 创建 ConcreteFactoory2 --\u0026gt;ProducttB2 : 创建 抽象工厂模式类似于一个二维的分类，将更加复杂的系统进行整理并且划分。以达到解耦的效果。\n使用场景：\n建造者模式 建造者模式: 建造者模式主要是为了解决调用构造函数的时候，参数太多，并且有一些是可选参数不填的情况。这种情况下，使用建造者模式会更加灵活。 待补充\u0026hellip;\u0026hellip;\n命令模式 命令模式: 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也可以支持撤销的操作。 定义：\n命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也可以支持撤销的操作。\n命令模式主要是将“命令的请求者”从“命令的执行者”对象中解耦。\n架构：\n命令模式对象可以包含接受者的引用，也可以不包含，因为在远程调用的情况下，不能获取引用。\n使用场景：\n异步、延迟、排队执行命令、撤销重做命令、存储命令、命令记录日志 Hystix熔断框架就用到了命令模式 redis使用命令模式处理指令 组合模式 z组合模式: 组合模式跟我们之前讲的面向对象设计中的“组合关系(通过组合来组装两个类)”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据 定义：\n组合模式允许你将对象组合成树形结构来表示“整体/部分”的层次结构。组合能够让客户以一致的方式处理个别对象以及对象组合。\n架构：\n使用场景：\n使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。\n需要理解“整体和部分”的关系。\n装饰器模式 装饰器模式: 装饰器模式动态的将责任附加到对象上，若要拓展功能，装饰者提供了比继承更有弹性的替代方案 定义：\n装饰器模式动态的将责任附加到对象上，若要拓展功能，装饰者提供了比继承更有弹性的替代方案。\n架构：\nclassDiagram class Component { \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; + methodA() + methodB() } class ConcreateComponent { + methodA() + methodB() } class Decrator { \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; + methodA() + methodB() } class ConcreateDecratorA { + methodA() + methodB() + newMethod() } class ConcreateDecratorB { + methodA() + methodB() } ConcreateComponent --|\u0026gt; Component : 继承 Decrator --|\u0026gt; Component : 继承 ConcreateDecratorA --|\u0026gt; Decrator : 继承 ConcreateDecratorB --|\u0026gt; Decrator : 继承 装饰的技巧可以在不修改任何底层代码的情况下增强功能。\n使用场景：\nJava IO类库（InputStream、OutputStream）\n在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n使用装饰器模式，常常造成设计中有大量的类 迭代器模式 迭代器模式: 迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示 定义：\n迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。\n迭代器模式封装了遍历。并且迭代器模式还将在元素之间进行游走的责任交给迭代器，使得职责更加单一。\n架构：\n使用场景：\nJava Iterator 解耦容器代码和遍历代码，使得职责更加单一 观察者模式 观察者模式: 一个比喻，报纸订阅（出版者和订阅者） 定义：\n观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。\n一个比喻：报纸订阅（出版者和订阅者）\n架构：\nclassDiagram class Subject { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; + registerObserver() + removeObserver() + notifyObserver() } class ConcreteSubject { - List\u0026lt;Observer\u0026gt; observers + registerObserver() + removeObserver() + notifyObserver() } class Observer { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; + update() } class ConcreteObeserver { - Subject subject + update() } Subject --\u0026gt; Observer : 多个观察者 ConcreteSubject ..|\u0026gt; Subject : 实现 ConcreteObeserver ..|\u0026gt; Observer : 实现 ConcreteObeserver --\u0026gt; ConcreteSubject : 订阅主题 观察者依赖主题。观察者模式提供了一种对象设计，让主题和观察者之间松耦合。他们依然可以交互，但是不必清楚彼此的细节。\n使用场景：\n消息队列 回调就是一种观察者模式 Google EventBus 邮件订阅 RSS 反应式RxJava JDK(CompletableFuture) 代理模式 代理模式: 代理模式为另一个对象提供一个替身或者占位符以控制这个对象的访问 定义：\n代理模式为另一个对象提供一个替身或者占位符以控制这个对象的访问。\n架构：\n使用场景：\n远程代理：远程代理可以作为另一个JVM上对象的本地代表。常见的是RPC框架。 虚拟代理：虚拟代理作为创建开销大的对象的代表。当对象没有得到的情况下执行一些操作。常见的是图片的加载。 缓存代理：缓存代理会维护之前的对象，在可能的情况下会返回缓存对象。 保护代理：可以根据客户的角色来决定是否允许客户访问特定的方法。（Java动态代理） 其他代理：\n防火墙代理：控制网络资源的访问，保护访问坏网络。 智能引用代理：例如计算一个对象被引用的次数。 同步代理：在多线程的情况下为主题提供安全的访问。 写入时复制代理：用于控制对象的复制，方法是延迟对象的复制，发那个客户真的需要（也就是需要写入时）才进行复制。是虚拟代理的变体。（Java5的CopyOnWriteArrayList） 装饰器模式是为对象增加行为，而代理模式是控制对象的访问。 适配器会改变对象适配的接口，而代理则实现相同的接口 外观模式 外观模式: 外观模式也叫做门面模式，外观模式定义了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用 定义：\n外观模式定义了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。\n外观模式可以解决接口的复用性和易用性的问题，并且，外观模式可以让层级更加清晰，满足最少知识原则，让暴露的接口或者函数更加少。\n架构：\n使用场景：\n解决易用性\n当接口越来越多，越来越复杂的时候，提供一层更加简单易用，更加高层的接口。例子：Linux系统调用函数封装了Linux内核调用、Linux的Shell命令封装了复杂的系统调用。\n单独起起一个API网关层服务做转发和聚合也很类似门面设计模式。\n解决性能问题\n将多个接口调用封装成一个简单的门面接口，在一些需要多次请求的网络通信中可以减少通信的次数，降低网络通信的成本，提高APP响应的速度。\n解决分布式事务问题\n门面接口可以将一个事务的多个接口封装在一个接口中，方面进行事务的回滚或者重试。\n适配器是做接口转换，解决的是原接口和目标接口不匹配的问题。门面模式做接口整合，解决的是多接口调用带来的问题。 适配器模式注重的是兼容性，而门面模式注重的是易用性。 复合模式 复合模式属于是模式的模式了。复合模式在一个解决方案中结合两个或者多个模式，以解决一般或者重复发生的问题。\nMVC架构（模型、视图、控制器）就使用了多种设计模式的复合。其中包括：观察者模式、策略模式、组合模式。\n观察者模式：模型通知视图和控制器关于自己的改变。 策略模式：视图和控制器实现了策略模式，视图可以有多个控制器，相当于有多个策略行为可以互相替换。 组合模式：视图内通过组合模式管理窗口显示。 Reference:\n","description":"设计模式是前人总结的经验。","id":5,"section":"posts","tags":["设计模式","开发方法论"],"title":"理解设计模式","uri":"https://hugo.jiahongw.com/zh/posts/dev/design-pattern/"},{"content":"出发前的准备 我这里列了一个大致的攻略（虽然最后崂山没去成）：\n青岛攻略\n还准备了一个行程路线：\n第一站 我们下车的地方是青岛站，一下来，就是一种欧式建筑的感觉，这就是青岛的特色吗\n看海 来青岛怎么能不看海，青岛三面环海，来的这几天，海浪还挺大，吹着挺舒服\n波涛汹涌\n有意境的一瞬间\n青岛标志性建筑——栈桥\n吃海鲜 在青岛吃海鲜🦞，喝🍺啤酒。\n买海鲜\n找别人加工\n逛青岛街头 在十月份的青岛树木非常绿，而且青岛的街道也很有特色，就是那种林荫道的感觉，让人很舒服\n青岛的道路命名很有意思，都是拿其他省名作为道路名，据说青岛的版图就是一个小型的中国\n夜晚在教堂还有人组织一起看电影，好久没有这样的文艺活动了\n光圈内的人\n夜晚的街道和行人\n总结 青岛是一个非常漂亮的城市，非常适合旅游。青岛不仅有海，有海鲜，还有很多美女。此行前前后后也做了一些攻略，其实攻略是次要的，不一定非要将攻略中的各个景点都逛了才算完美，在行程中享受过程才是更重要的。\n彩蛋～\n","description":"国庆期间，去了一趟青岛。","id":6,"section":"posts","tags":["青岛","生活","旅行"],"title":"青岛之旅","uri":"https://hugo.jiahongw.com/zh/posts/life/qingdao-travel/"},{"content":"The photo about Beijing with me.📹\n","description":"记录北京的照片生活","id":7,"section":"gallery","tags":[null],"title":"北京","uri":"https://hugo.jiahongw.com/zh/gallery/beijing/"},{"content":"配置信息 git的config的信息又一个全局的配置文件，也有一个局部（当前git项目）的配置文件。他们的位置分别在：\n全局配置文件.gitconfig：~/.gitconfig(用户根目录下)\n局部配置文件.gitconfig：.git/config(当前项目下相对路径)\n配置文件内容：\n[core] editor = vim [color \u0026#34;diff\u0026#34;] whitespace = red reverse [include] path = ~/.gitconfig.user [user] name = xxx email = xxx@xxx.com 配置文件的信息主要包括：\ngit使用的编辑器\ndiff的配置\ninclude可以包括用户的自定义信息\n用户的信息（用户名和邮箱）\n配置多个账号：\nMac配置多个Git账号，例如一个公司账号，一个个人账号。\nhttps://www.jianshu.com/p/698f82e72415\n首先unset全部全局的数据，然后参考上面的分别设置多个账号的公钥。最后设置config的时候，公司的不设置，直接设置成global的。\n其他无需更改。\n通过命令行进行配置 设置用户信息：\n1 2 3 # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026#34;[name]\u0026#34; $ git config [--global] user.email \u0026#34;[email address]\u0026#34; 查看git配置信息：\n1 2 3 4 # 局部配置信息 git config --list # 全局配置信息 git config --global --list 编辑git配置信息可以使用命令行打开：\n1 2 # 编辑Git配置文件 $ git config -e [--global] 修改远程仓库的地址信息：\n1 2 3 4 5 6 # 设置远程地址 git remote set-url origin [url] # 删除本地地址 git remote rm origin # 没有设置远程地址的情况下使用此命令添加远程仓库地址 git remote add origin [url] 通过配置文件进行修改 [user] name = 用户名 email = 邮箱 [remote \u0026#34;origin\u0026#34;] url = 远程仓库地址 fetch = +refs/heads/*:refs/remotes/origin/* [branch \u0026#34;master\u0026#34;] remote = origin merge = refs/heads/master 配置git代理源 常见的 github 加速方法如修改 hosts 文件、魔法上网、设置 proxy 等方法。\n加速地址一览 **fastgit.org：**https://doc.fastgit.org/ **cnpmjs.org：**https://github.com.cnpmjs.org/ **gitclone.com：**https://gitclone.com/ **gitee：**https://gitee.com/mirrors GitHub 文件加速：https://gh.api.99988866.xyz/ Github 仓库加速：https://github.zhlh6.cn/ Github 仓库加速：http://toolwa.com/github/ github 国内镜像服务加速 不进行多余网络配置的情况下，直接使用提供了 github 国内镜像服务的网站进行 github 各种资源拉取加速。\n加速clone：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 方法一：手动替换地址 #原地址 $ git clone https://github.com/kubernetes/kubernetes.git #改为 $ git clone https://github.com.cnpmjs.org/kubernetes/kubernetes.git #或者 $ git clone https://hub.fastgit.org/kubernetes/kubernetes.git #或者 $ git clone https://gitclone.com/github.com/kubernetes/kubernetes.git # 方法二：配置git自动替换 $ git config --global url.\u0026#34;https://hub.fastgit.org\u0026#34;.insteadOf https://github.com # 测试 $ git clone https://github.com/kubernetes/kubernetes.git # 查看git配置信息 $ git config --global --list # 取消设置 $ git config --global --unset url.https://github.com/.insteadof 加速 release:\n1 2 3 4 5 6 # 原地址 wget https://github.com/goharbor/harbor/releases/download/v2.0.2/harbor-offline-installer-v2.0.2.tgz # 加速下载方法一 wget https://download.fastgit.org/goharbor/harbor/releases/download/v2.0.2/harbor-offline-installer-v2.0.2.tgz # 加速下载方法二 wget https://hub.fastgit.org/goharbor/harbor/releases/download/v2.0.2/harbor-offline-installer-v2.0.2.tgz 加速 raw:\n1 2 3 4 5 6 # 原地址 $ wget https://raw.githubusercontent.com/kubernetes/kubernetes/master/README.md # 加速下载方法一 $ wget https://raw.staticdn.net/kubernetes/kubernetes/master/README.md # 加速下载方法二 $ wget https://raw.fastgit.org/kubernetes/kubernetes/master/README.md 设置proxy 命令行设置和取消代理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 git config --global --unset http.proxy git config --global --unset https.proxy #只对github.com git config --global http.https://github.com.proxy socks5://127.0.0.1:1080 #取消代理 git config --global --unset http.https://github.com.proxy) npm config delete proxy 配置文件配置：\n[http] proxy = socks5://127.0.0.1:1080 [https] proxy = socks5://127.0.0.1:1080 #只对github.com 方案2 [http \u0026#34;https://github.com\u0026#34;] proxy = socks5://192.168.10.120:7890 注意：\n1, https.proxy设置是无用的, 只需要设置http.proxy\n2, socks5h://更好, 远端DNS\nRef：\n无需代理直接加速各种 GitHub 资源拉取 | 国内镜像赋能 | 助力开发 - Frytea\u0026rsquo;s Blog git 设置和取消代理 Linux安装并使用ssr客户端 - 灰鹦鹉 关键命令 下图展示了常用的git命令：\n基本操作 1 2 3 4 5 6 7 8 9 # 初始化git仓库 git init # 添加文件到暂存区域 git add filename #添加所有更改的文件到暂存区 git add . (git add --all) # 提交 git commit # 提交到远程仓库 删除git add操作的文件\n1 2 3 4 # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] .. # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 撤销更改 未commit，需要取消更改 已经git add的情况下，使用git checkout . 取消更改。\n已commit，需要取消更改 关键字：checkout，clean\n$ git checkout # 撤销项目下所有的修改 $ git checkout . # 撤销当前文件夹下所有的修改 $ git checkout xx/xx.py xx/xx2.py # 撤销某几个文件的修改 $ git clean -f # untracked状态，撤销新增的文件 $ git clean -df # untracked状态，撤销新增的文件和文件夹 最好不要使用git clean这个命令。\n删除commit\n版本回退 hash_value是在git log查询到的对应提交的哈希值。\ngit reset --hard hash_value 也可以\n$ git reset --hard origin/master # 回退与本地远程仓库一致 $ git reset --hard HEAD^ # 回退到本地仓库上一个版本 $ git reset --hard \u0026lt;hash code\u0026gt; # 回退到任意版本 $ git reset --soft/git reset # 回退且回到已修改状态，修改仍保留在工作区中。 Git标签tag的使用 git stash使用 Git区域 工作区(Working Area) 暂存区(Stage) 本地仓库(Local Repository) 远程仓库(Remote Repository) 状态 未修改(Origin) 已修改(Modified)\u0026amp;未追踪(Untracked) 已暂存(Staged) 已提交(Committed) 已推送(Pushed) git add . 是把文件添加到暂存区中。\ngit commit 把暂存区中的所有内容提交到当前分支。\ngit push 是将本版本库库中的当前的修改版本推送到远程仓库。\ngit pull 将远程仓库的修改版本推送到本地版本库中\n取消commit：\n# 不删除工作空间改动代码 git reset --soft HEAD^ 几个参数：\n–mixed：不删除工作空间改动代码，撤销conmit，并且撤销git add .操作。（这个参数为默认参数） –soft：不删除工作空间改动代码，撤销commit，不撤销git add . –hard：删除工作空间改动代码，撤销commit，撤销git add . 添加远程仓库：\n冲突解决 强制提交：git push origin branch-name \u0026ndash;force 在进行pull和push的时候或者merge的时候，可能会发生冲突，这个时候需要我们手动进行修改冲突的内容。\ngit 合并多个commit 最简单的单步操作方法：\n# 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] 重置上次commit的信息：\n# 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 压缩当前版本到指定版本之间的commit为一个commit（不包括命令中的commit）：\ngit log git rebase -i 版本 版本不参与合并，文件中最上边的commit不需要修改s。\n可以删除不需要的commit\n之后选择需要合并的commit的前面的pick改为s，然后保存推出，有冲突按照提示修改即可。\nGit将单个commit拆分成多个commit 参考：Git : 如何将一个commit拆分成多个 | 一个程序员的自我修养\nGit查看某次提交的内容 1 git show commitId 查看某个文件某次提交的内容:\n1 git show commitId fileName git 分支操作 游戏学习分支操作：https://learngitbranching.js.org/?locale=zh_CN\nHEAD表示当前的分支节点：\n使用 ^ 向上移动 1 个提交记录 使用 ~\u0026lt;num\u0026gt; 向上移动多个提交记录，如 ~3 我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:\ngit branch -f main HEAD~3 上面将main分支移动到当前节点的前三个提交。\nclone指定分支：\n1 git clone -b master http://gitslab.yiqing.com/declare/about.git 更新远程分支：\n1 git remote update origin --prune rebase的坑\n撤销操作：\n虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！\n为了撤销更改并分享给别人，我们需要使用 git revert。来看演示：\n这里要注意下，如果你的remote branch不是在origin下，按你得把origin换成你的名字。\n合并分支到此分支:\n1 2 # 合并master分支到此分支 git merge master 合并到目标分支：\n1 2 # 合并此分支到master分支 git rebase master 列出所有分支：\n# 列出本地所有分支 git branch # 列出本地和远程所有分支 git branch -a 删除分支：\n# 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 新建和切换分支：\n1 2 3 4 5 6 7 8 9 10 # 创建dev分支 git branch dev # 切换到dev分支 git checkout dev # 创建dev分支并且切换到该分支 git checkout -b dev # 新建一个分支，指向指定commit git branch [branch] [commit] # 切换到上一个分支 git checkout - 重命名分支（本地不存在feature/ones分支）：\n# 把远端feature/ones分支名称重命名为feature/12345/ones git checkout -b feature/ones origin/feature/ones git pull 重命名feature/ones分支\ngit branch -m feature/ones feature/12345/ones 提交分支 提交到feature/12345/ones分支\ngit push origin feature/12345/ones 删除远端分支 删除远端feature/ones分支\ngit push -d feature/ones 合并分支 将文件合并到master，即合并dev分支到master中去\ngit merge dev 拉取远程分支：\n1 2 3 4 # 拉取远程分支并创建本地分支 git checkout -b 本地分支名x origin/远程分支名x # 拉取远程分支，但是不切换到该分支 git fetch origin 远程分支名x:本地分支名x 查看本地分支与远程分支的映射关系\n1 git branch -vv 建立当前分支与远程分支的映射关系:\n1 2 git branch -u origin/addFile git branch --set-upstream-to origin/addFile 撤销本地分支与远程分支的映射关系:\n1 2 git branch --unset-upstream ref:git upstream\n\u0026lt;++\u0026gt;\n代码回滚 冲突解决 生成发布压缩包\ngit archive 标签使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] Git规范 分支命名 master 分支\nmaster 为主分支，也是用于部署生产环境的分支，确保master分支稳定性\nmaster 分支一般由develop以及hotfix分支合并，任何时间都不能直接修改代码\ndevelop 分支\ndevelop 为开发分支，始终保持最新完成以及bug修复后的代码\n一般开发的新功能时，feature分支都是基于develop分支下创建的\nfeature 分支\n开发新功能时，以develop为基础创建feature分支\n分支命名: feature/ 开头的为特性分支， 命名规则: feature/user_module、 feature/cart_module\nrelease分支\nrelease 为预上线分支，发布提测阶段，会release分支代码为基准提测 当有一组feature开发完成，首先会合并到develop分支，进入提测时，会创建release分支。\n如果测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。\n当测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。\n复制代码\nhotfix 分支\n分支命名: hotfix/ 开头的为修复分支，它的命名规则与 feature 分支类似\n线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支\n日志规范 当前业界应用的比较广泛的是 Angular Git Commit Guidelines\nCommit message格式：\n每次提交，Commit message 都包括三个部分：header，body 和 footer。\n\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; 其中，header 是必需的，body 和 footer 可以省略。\ntype: 本次 commit 的类型，诸如 bugfix docs style 等\nscope: 本次 commit 波及的范围\nsubject: 简明扼要的阐述下本次 commit 的主旨，在原文中特意强调了几点 1. 使用祈使句，是不是很熟悉又陌生的一个词，来传送门在此 祈使句 2. 首字母不要大写 3. 结尾无需添加标点\nbody: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，如需换行，则使用 |\nfooter: 描述下与之关联的 issue 或 break change，详见案例\nHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。\nfeat: 添加新特性 fix: 修复bug docs: 仅仅修改了文档 style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor: 代码重构，没有加新功能或者修复bug perf: 增加代码进行性能测试 test: 增加测试用例 chore: 改变构建流程、或者增加依赖库、工具等 使用gitmoji：🔨 [git]: Write better commits with Gitmoji - DEV Community\n最佳实践 本地代码双分支，一个提交分支，一个开发分支。\n假如从远程仓库那边拉取的分支是\ngit commit \u0026ndash;amend修改push到远程分支的提交\nhttps://blog.csdn.net/ecjtuhq/article/details/80358656\n参考：\nhttps://blog.csdn.net/ivan820819/article/details/78816578\nhttps://segmentfault.com/a/1190000007748862\nhttps://www.jianshu.com/p/964de879904a\nhttps://blog.csdn.net/huangjhai/article/details/109557946\nhttps://juejin.cn/post/6844903635533594632\nhttps://segmentfault.com/a/1190000009048911\nhttps://www.cnblogs.com/jiuyi/p/7690615.html\nhttps://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n","description":"记录git的常用操作和一些实际遇到的问题。","id":8,"section":"posts","tags":["git","开发方法论"],"title":"git使用笔记","uri":"https://hugo.jiahongw.com/zh/posts/dev/git-note/"},{"content":" Youtube中的一个非常有意思的视频活动。在芝加哥的大街上，看看路人能否解决一些初级的编程问题，解决问题的能够得到100美元，非常有意思。对于我们来说这些问题非常的简单，但是对于普通人来说，还是有一定的难度的。似乎在芝加哥的街头上也会编程的也不是挺多人，或者，程序猿都在上班吧🐶。\n在第二期的问题变得比较难一点，是college水平的，解决问题的能够得到200美元。后面那个熟悉的判断回文串😄。\n想象这个活动要是在中国试一试，感觉街头很多人能够做出来，因为中国的程序员越来越多了。\n","description":"Youtube中的一个非常有意思的视频活动。在芝加哥的大街上，看看路人能否姐姐一些初级的编程问题。","id":9,"section":"posts","tags":["编程","youtube"],"title":"街头代码编程","uri":"https://hugo.jiahongw.com/zh/posts/see/code-problem-solving-onstreet/"},{"content":"极化编码的基本思想是：只在$Z\\left( W_{N}^{\\left( i \\right)} \\right)$近于0的坐标信道$W_{N}^{\\left( i \\right)}$上发送数据比特。极化码具有一般的二元线性分组码的基本编码要素，因而可以通过显示地写出其生成矩阵来完成编码：\n$$\nx_{1}^{N}=u_{1}^{N}{G_{N}}\n$$\n其中，编码生成矩阵${G_{N}}\\text{=}{B_{N}}{F^{\\otimes n}}$，$B_{N}$是排序矩阵，完成比特的反序操作，$F^{\\otimes n}$表示矩阵$F$进行$n$次$Kronecker$积操作，有递归公式${F^{\\otimes n}}=F\\otimes {F^{\\otimes \\left( n-1 \\right)}}$且${F^{\\otimes 1}}\\text{=}F=\\left[ \\begin{matrix}\n1 \u0026amp; 0 \\\n1 \u0026amp; 1 \\\n\\end{matrix} \\right]$。\n主要的步骤为：\n可靠性估计 可靠性估计就是极化码的构造，这个过程我们选出信道容量高的子信道进行传输，信道容量低的子信道传输冻结比特。\n常见的几种可靠性估计的方法（极化码构造方法）有：\n巴士参数估计法。\n蒙特卡洛法。\n密度进化法。\n高斯近似法。\n比特混合 假设通过错误概率进行极化码构造之后得到极化序列为$\\left{ 3,5,6,7,0,1,2,4 \\right}$ ，选择前面K个信道即$A=\\left{ 3,5,6,7\\right}$发送信息比特；另外的信道集合${A^{c}}=\\left{ 0,1,2,4\\right}$作为固定比特传输。设信息比特集合为$\\left( {i_{0}},{i_{1}},{i_{2}},{i_{3}} \\right)=\\left( 1,1,1,1 \\right)$，固定比特设置为0，则最终得到待编码的信息比特：\n$$\nu_{0}^{7}=\\left[ 0,0,0,{i_{0}},0,{i_{1}},{i_{2}},{i_{3}} \\right]=\\left[ 0,0,0,1,0,1,1,1 \\right]\n$$\n经过上面的过程我们就完成了对信息位和冻结位的比特混合。\n构造生成矩阵 首先我们求出排序矩阵$B_{N}$，其有递归式：\n$$\n{B_{N}}={R_{N}}\\left( {I_{2}}\\otimes {B_{N/{2};}} \\right)\n$$\n$$\n{B_{2}}={I_{2}}\n$$\n我们得到排序矩阵$B_{N}$，对输入序列完成奇序元素和偶序元素的分离，即先排奇序元素，再排偶序元素，其作为效果如下:\n$$\n\\left( {u_{1}},{u_{2}},{u_{3}},{u_{4}},\u0026hellip;,u{}{N} \\right)\\times {R {N}}=\\left( {u_{1}},{u_{3}},{u_{5}},\u0026hellip;,{u_{N-1}},{u_{2}},{u_{4}},{u_{6}},\u0026hellip;,{u_{N}} \\right)\n$$\n$F$矩阵我们可以根据下面的递归式进行求解：\n$$\n{F^{\\otimes n}}=F\\otimes {F^{\\otimes \\left( n-1 \\right)}}\n$$\n$$\nF=\\left[ \\begin{matrix}\n1 \u0026amp; 0 \\\n1 \u0026amp; 1 \\\n\\end{matrix} \\right]\n$$\n最后，我们将求得的排序矩阵和$F$矩阵相乘，得到生成矩阵$G_{N}$：\n$$\n{G_{N}}={B_{N}}{F^{\\otimes n}}\n$$\n假设我们求得的生成矩阵是：\n生成极化码 将信息比特与生成矩阵$G_{N}$相乘得到最终编码后的极化码，例如：\n参考：\nPolar Code（2）编码原理 | Marshall - Comm. Tech. Blog ","description":"极化码的编码就是一些简单的线性运算，通过矩阵进行简化多维的运算，归根到底还是基于基本的异或操作。","id":10,"section":"posts","tags":["极化码"],"title":"极化码-编码","uri":"https://hugo.jiahongw.com/zh/posts/polarcode/polar-code-encode/"},{"content":"基本概念 信噪比 信噪比，英文名称叫做SNR（SIGNAL-NOISE RATIO )，是指一个电子设备或者电子系统中信号与噪声的比例。信噪比的计算可以为有用信号功率与噪声功率的比 ：\n$$\nSNR = \\frac {P_{signal}} {P_{noise}}\n$$\n它的单位一般使用分贝，其值为十倍对数信号与噪声功率比:\n$$\nSNR(dB) = 10\\log_{10}(\\frac {P_{sibnal}} {P_{noise}})\n$$\n其中，$P_{signal}$为信号功率，$P_{noise}$为噪声功率。\n转移概率 一个二进制输入离散无记忆信道（B-DMC）可表示为$W:X\\to Y$，$X$是输入符号集合，$Y$是输出符号集合，转移概率为$W\\left( y|x \\right),x\\in X,y\\in Y$。由于信道是二进制输入，集合$X=\\left{ 0,1 \\right}$；$Y$和$W\\left( y|x \\right)$是任意值。对信道$W$的$N$次使用后的信道可表示为${W^{N}}$，则信道${W^{N}}:{X^{N}}\\to {Y^{N}}$的转移概率为：\n$$\n{W^{N}}\\left( y_1^{N}|x_{1}^{N} \\right)=\\prod\\nolimits_{i=1}^{N}{W\\left( y|x \\right)}\n$$\n对称容量 对称容量是对信道速率的度量，记作$I(W)$，表示信道$W$在等概率输入下的可靠传输时的最大速率,计算公式如下：\n$$\nI\\left( W \\right)\\triangleq \\sum\\limits_{y\\in Y}{\\sum\\limits_{x\\in X}{\\frac{1}{2}}}W\\left( y|x \\right)\\log \\frac{W\\left( y|x \\right)}{\\frac{1}{2}W\\left( y|0 \\right)+\\frac{1}{2}W\\left( y|1 \\right)}\n$$\n当码长$N$趋近于无穷的时候，信道容量趋近于1的分裂信道比例约为$K=N×I(W)$，这部分是用来传输信息比特的信道数量，而信道容量趋近于0的比例约为$N×(1−I(W))$，这部分表示冻结比特的信道数量。对于信道容量为1的可靠信道，可以直接放置消息比特而不采用任何编码，即相当于编码速率为$R=1$；而对于信道容量为0的不可靠信道，可以放置发送端和接收端都事先已知的冻结比特，即相当于编码速率为$R=0$。那么当码长$N \\to\\infty$时，极化码的可达编码速率$R= \\frac {K}{N}= \\frac {N×I(W)}{N}=I(W)$，即在理论上，极化码可以被证明是可达信道容量的。\n信道极化 信道极化分为信道联合和信道分裂两个阶段。对于长度为$N={2^{n}}$（$n$为任意整数）的极化码，它利用信道$W$的$N$个独立副本，进行信道联合和信道分裂，得到新的$N$个子信道$\\left{ W_{N}^{\\left( 1 \\right)},W_{N}^{\\left( 2 \\right)},\u0026hellip;,W_{N}^{\\left( N \\right)} \\right}$。随着码长的增加，分裂之后的信道将向两个极端发展：其中一部分分裂信道会趋近于完美信道，即信道容量趋近于1的无噪声信道；而另一部分分裂信道会趋近于完全噪声信道，即信道容量趋近于0的信道。\n我们主要研究二进制离散无记忆信道，将上面的信道模型（包括BEC、BSC、AWGN）进行抽象，我们可以得出下面的信道传输模型：\n图中的W可以是BEC信道，也可以是BSC信道或者AWGN信道，其中I(W)为信道容量。\n信道联合 信道联合是将多个子信道进行蝶形的异或操作的过程。对于码长为N=2的极化码，我们可以通过下面的蝶形异或操作将两个信道进行混合：\n由上图可以发现，进行信道联合之后，坐标不同信道的信道容量发生了极化现象，有一个比特的信道信道容量$I(W)$增加了，另外一个比特的信道容量$I(W)$减少了。信道容量小的，我们称为差信道，信道容量大的，我们称为号好信道。因为进行了信道联合之后，因为要求得左边的信道$u1$，必须是在右边的信道$y1$和$y2$同时都收到的情况下才能够得出$u1$，所以$u1$的信道容量就是信道$y1$和$y2$的信道容量乘积；相应的，对于信道$u2$，只有$y1$和$y2$都收不到的情况下，才接收不到信道，所以它的信道容量$I(W)$为$2*0.5 - 0.5^{2}$。\n我们也可以使用一个二维表格来计算它们传输的概率：\ny1 y2 u1 u2 √ √ √ √ √ x x √ x √ x √ x x x x 由表格1可以发现，对于接收方收到的信号y1和y2，总共有4种情况，X表示该信道发生错误，未收到信道；√表示该信道收到了信道。对于子信道u1，在四种情况中，只有一种情况能够接受得到u1，也就是同时接收到y1和y2的情况,所以信道容量为1/4；而对于u2,只要能够收到y1或y2的任意一个它就能够解出来,根据信道极化理论，我们在进行极化的过程中，就已经知道信道u1的信道容量比较小，我们会把它作为冻结比特，填充为0，不传输信息比特，仅传输冻结比特，所以在没有接收到y2的情况下我们也能够得出u2。\n对于N=4的码长，我们可以递归的进行信道联合，如图，只不过相比于N=2的码长的极化码，我们需要增加一次的信道联合过程：\n按照这样不断的递归下去，到n级之后，可以得到递归的一般式：${W_{N/{2};}}$的2个独立副本联合产生信道${W_{N}}$，我们可以的到任意码长为$N=2^{n}$的极化码。\n信道分裂 信道分裂体现在信道联合之中 ，参考文献中对于信道分裂的解释，其大致过程是将两个信道$W_{N/2}$联合成一个信道$W_N$之后，再将联合的信道$W_N$分裂成两个子信道$W_{N/2}$，此时，这两个子信道的转移概率也改变了，这样极化码就完成了信道分裂。更具体的来说，它存在以下两个递推公式计算子信道的转移概率：\n$$\nW_{N}^{\\left( 2i-1 \\right)}\\left( y_{1}^{N},u_{1}^{2i-2}|{u_{2i-1}} \\right)=\\sum\\limits_{u_{2i}}{\\frac{1}{2}W_{N/{2};}^{\\left( i \\right)}\\left( y_{1}^{N/{2};},u_{1,o}^{2i-2}\\oplus u_{1,e}^{2i-2}|{u_{2i-1}}\\oplus {u_{2i}} \\right)\\cdot W_{N/{2};}^{\\left( i \\right)}\\left( y_{N/{2};+1}^{N},u_{1,e}^{2i-2}|{u_{2i}} \\right)}\n$$\n$$\nW_{N}^{\\left( 2i \\right)}\\left( y_{1}^{N},u_{1}^{2i-1}|{u_{2i}} \\right)=\\frac{1}{2}W_{N/{2};}^{\\left( i \\right)}\\left( y_{1}^{N/{2};},u_{1,o}^{2i-2}\\oplus u_{1,e}^{2i-2}|{u_{2i-1}}\\oplus {u_{2i}} \\right)\\cdot W_{N/{2};}^{\\left( i \\right)}\\left( y_{N/{2};+1}^{N},u_{1,e}^{2i-2}|{u_{2i}} \\right)\n$$\n参考：\n《“太极混一”——极化码原理及5G应用》 ","description":"介绍关于极化码的一些基本的数学与计算原理，包括如何进行概率的转移的。","id":11,"section":"posts","tags":["极化码"],"title":"极化码-基本原理","uri":"https://hugo.jiahongw.com/zh/posts/polarcode/polar-code-fundamentals/"},{"content":"在通信过程中，物理层传输的就是电信号，假如我们只用0和1传输信号，并且这些信道互相都没有关系，我们称为二进制离散无记忆信道。信道模型是研究信道编码的基础，常见的几种信道模型分别有：二进制删除信道（BEC）、二进制对称信道（BSC）、高斯信道（AWGN）。设信道的输入和输出分别是长为N的序列，输入是x，输出是y，其信道的转移概率满足：\n$$\np\\left( {y|x} \\right) = \\sum_{i=1}^N p\\left( {y_{i} | x_{i}} \\right)\n$$\n无损信道 无论发送任何消息，接受方都能够准确无误的接收到，并且不会发生错误，那么这个信道就可以说是一个无损信道。最简单的的就是下面这个模型，不管发送者发送的是0还是1，接收者接受的都是一致的。\n假如我们随机进行传输0或者1的数据，其传输的数值图为下面：\n二进制删除信道 二进制删除信道，简记为BEC（Binary Erasure Channel ）。ϵ称为删除概率，表示有ϵ的概率这个信号会丢失。当接收方得到一个位，它是100%确定的位是正确的。只有当位被擦除时，才会出现唯一的混淆。对于二进制离散无记忆信道，我们有ϵ的概率丢失0或者1的比特位。\nBEC的信道容量为：\n$$\nC= 1 - \\epsilon\n$$\n二进制对称信道 二进制对称信道，简记为BSC（Binary Symmetric Channel ）。p称为交叉概率，表示有p的概率会导致传输过程中0信号和1信号的错乱。（错乱的意思是发送0，收到却是1；或者发送1，收到却是0）\nBSC的信道容量为：\n$$\nC = \\log n + q\\log q + (1-q) \\log \\frac {1-q}{n-1}\n$$\n加性高斯白噪声信道 高斯信道，常指加权高斯白噪声（AWGN）信道。这种噪声假设为在整个信道带宽下功率谱密度（PDF）为常数，并且振幅符合高斯概率分布。\n一般来说，高斯信道需要配合BPSK机制进行调制，在传输之前，我们对0和1比特进行变换，比特0会变成1，比特1变成-1，而这个将比特进行转换的过程就是BPSK调制，最后在BPSK调制后再加上高斯噪声，实际的模型如下：。\n通过BPSK调制之后0比特和1比特都会向1和-1这两个临界线靠经，在这个情况下传入高斯信道，即使存在高斯噪声进行影响，我们也能够减小它的影响，在解码端对码字进行BPSK解调，能够得到较高的准确率。\n由图可以发现，值靠近1的信号表示原来的信号是0，值靠近-1的信号表示原来的信号是1。这样的好处是在传输过程中减少高斯噪声的干扰，让传输的信号更加稳定。\n特别的，5G标准要求信道编码至少能够在加性高斯白噪声信道（AWGN）下进行传输。\n","description":"在信息论中，信道是指信息传输的通道。我们在实际通信中所利用的各种物理通道是信道的最典型的例子，如电缆、光纤、电波传布的空间、载波线路等等。但是极化码的信道模型将他们进行了抽象，将信道分成了几类：BEC、BSC、AWGN。","id":12,"section":"posts","tags":["极化码","信道模型"],"title":"极化码-信道模型","uri":"https://hugo.jiahongw.com/zh/posts/polarcode/polar-code-channel-model/"},{"content":"Arıkan教授在文献[1]提出了串行抵消SC译码算法。SC译码算法类似一个深度优先搜索的算法，其根据两个判决函数进行迭代计算最大似然对数比LLR，两个判决函数分别叫做f函数和g函数。下面是这两个公式的计算方法：\n$$\n\\begin{align}\nf\\left( a,b \\right)=\\ln \\left( \\frac{1+{ {e}^{a+b}}}{ { {e}^{a}}+{ {e}^{b}}} \\right)\n\\end{align}\n$$\n$$\n\\begin{align}\ng\\left( a,b,{ {u}{s}} \\right)={ {\\left( -1 \\right)}^{ { {u} {s}}}}a+b\n\\end{align}\n$$\n其中，$a,b\\in R,{ {u}_{s}}\\in \\left{ 0,1 \\right}$。LLR的递归运算借助函数f和g表示如下：\n$$\n\\begin{align}\nL_{N}^{\\left( 2i-1 \\right)}\\left( y_{1}^{N},\\hat{u}{1}^{2i-2} \\right)=f\\left( L {N/2}^{\\left( i \\right)}\\left( y_{1}^{ {N}/{2};},\\hat{u}{1,o}^{2i-2}\\oplus \\hat{u} {1,e}^{2i-2} \\right),L_{N/2}^{\\left( i \\right)}\\left( y_{ {N}/{2};+1}^{N},\\hat{u}_{1,e}^{2i-2} \\right) \\right)\n\\end{align}\n$$\n$$\n\\begin{align}\nL_{N}^{\\left( 2i \\right)}\\left( y_{1}^{N},\\hat{u}{1}^{2i-1} \\right)=g\\left( L {N/2}^{\\left( i \\right)}\\left( y_{1}^{ {N}/{2};},\\hat{u}{1,o}^{2i-2}\\oplus \\hat{u} {1,e}^{2i-2} \\right),L_{N/2}^{\\left( i \\right)}\\left( y_{ {N}/{2};+1}^{N},\\hat{u}{1,e}^{2i-2} \\right),{ { {\\hat{u}}} {2i-1}} \\right)\n\\end{align}\n$$\n递归的终止条件为当$N=1$时，即到达了信道$W$端，此时$L_{1}^{\\left( 1 \\right)}\\left( { {y}{j}} \\right)=\\ln \\frac{W\\left( { {y}{j}}|0 \\right)}{W\\left( { {y}_{j}}|1 \\right)}$。\nSC译码算法依靠一个蝶形单元，如图10，在计算的时候不断进行递归，但是必须是先计算出蝶形单元的上行比特，才能够调用g函数求出下行比特。即图10中必须使用f函数计算出u1，之后才能够通过g函数求出u2。在实际的计算过程中，从接收的比特进行递归执行f函数和g函数，其中假如编码每次进行一次极化，在译码阶段都会多一次递归的计算，中间的计算值就是进行极化的临时值，在一整个蝶形结构中体现，是一个深度优先的算法。\nSCL译码算法[3]类似树的广度优先遍历，它的好处就是能够进行剪枝操作，不用计算所有的节点。它从根节点开始往树底部进行广度遍历搜索，每一层会计算出一个估计比特，然后在这个估计比特的基础上往下进行估计下一个比特的值，另外，SCL译码算法还增加了惩罚因子，对于惩罚因子过高的节点，我们可以直接跳过它以及它子节点的计算，因为它是正确的码的可能性极低，这样排除了不可能的路径，同时，这也能达到对树进行剪枝的效果，提高译码的速度。图11展示了进行SCL译码的基本过程：\n","description":"译码和编码类似，基于递归的结构。","id":13,"section":"posts","tags":["极化码"],"title":"极化码-译码","uri":"https://hugo.jiahongw.com/zh/posts/polarcode/polar-code-decode/"},{"content":"出发前的准备 冲锋衣（防风，防晒，防雨，防寒） 登山鞋或者越野鞋 登山杖 帽子 防晒霜 一次性内裤和一次性雨衣 相机 厚的衣服 口罩 学生证 身份证 驾驶证 基本路线 小环线+稻城亚丁\n川西美景 合照 some word 大学四年一下就过去了，很高兴遇见了一群很棒的朋友。希望未来的我们也更加优秀！旅游真是一件又累又让人重新认识世界事情啊！\n","description":"在大学的最后一次和朋友的旅行......","id":14,"section":"posts","tags":["生活"],"title":"毕业旅行-川西","uri":"https://hugo.jiahongw.com/zh/posts/life/biyeluxing/"},{"content":"川西毕业旅行的图片。\n","description":"川西毕业旅行","id":15,"section":"gallery","tags":null,"title":"川西旅行","uri":"https://hugo.jiahongw.com/zh/gallery/chuanxi/"},{"content":"5G下的极化码 这个专栏介绍极化码的相关原理，一方面是因为我目前的毕业设计是关于5G极化码方向的，另一方面我想将自己所学的一些知识记录或者分享起来。\n首先，我想要说的是，极化码是一种编码方式，它的目的是为了使得在传输过程中传输更多有效的消息，也可以理解为让传输更可靠的编码方式。当然，对于信道编码来讲，那最主要的就是编码和解码这两个板块。那什么是信道编码呢？可以这样理解：发送方先对发送的信息进行编码，通过信道进行传输，然后在接受方那边进行解码，得到消息，这就是信道编码的基本过程。我会在之后的文章中分析这些过程。\n主要分为如下几个板块：\n信道模型 极化码基本原理 极化码的编码 极化码的译码 极化码的构造（信道的选择） 极化码实现 ","description":"极化码已经入选5G的标准，是唯一一个被证明可以达到香农极限的一种编码方式。","id":16,"section":"posts","tags":["PolarCode"],"title":"5G下的极化码","uri":"https://hugo.jiahongw.com/zh/posts/polarcode/polar-code-intro/"},{"content":"需要从 UGameViewportClient 类继承 修改返回值为true,路径：\\Source\\Runtime\\Engine\\Private\\GameViewportClient.h\n1 virtual bool RequiresHitProxyStorage() override { return true; } 在FViewportClient类中新建DrawHitProxy函数 文件UnrealClient.h\n在GameViewportClient类中声明并且实现 声明：\\Source\\Runtime\\Engine\\Private\\GameViewportClient.h\n将GameViewportClient类中的函数Draw()内容复制到该函数DrawHitProxy，修改下面的的地方：\n修改FViewport类中的GetRawHitProxyData函数 在GetRawHitProxyData函数中进行以下的修改：Engine\\Source\\Runtime\\Engine\\Private\\UnrealClient.cpp\n调用\u0026ndash;获取屏幕坐标Hitproxy 相关类型 HHitProxy：用于检测用户界面命中的基类\nFHitProxyMap：从2D坐标到缓存命中代理的地图。\n参考：\nHow to select an actor in-game using GetHitProxy? UE4 编辑器的光标拾取 编辑器Viewport窗口中的鼠标拾取原理 场景基本对象 渲染总流程 https://docs.unrealengine.com/zh-CN/Programming/Rendering/MeshDrawingPipeline/index.html Unreal Mesh Drawing源码分析 白袍笑道 ","description":"","id":18,"section":"posts","tags":["c++","UE4","游戏引擎"],"title":"UE编辑器下模拟使用HitProxy","uri":"https://hugo.jiahongw.com/zh/posts/ue/ue-hitproxy/"},{"content":"在UE4中获取深度缓存，调用渲染命令读取。\n获取深度缓存 深度像素格式 键入命令vis scenedepthz uv0以查看实际使用的深度缓冲区。UE4对场景使用“反向”深度缓冲区。\nWay1：直接使用ENQUEUE_RENDER_COMMAND命令获取(效率较低) 在任意tick函数或者其他函数添加以下的命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct DepthPixel\t//定义深度像素结构体 { float depth; char stencil; char unused1; char unused2; char unused3; }; float* cpuDataPtr;\t// Texture深度值数组首地址 TArray\u0026lt;DepthPixel\u0026gt; mydata;\t//最终获取色深度值数据 FIntPoint buffsize;\t//深度长宽大小X和Y ENQUEUE_RENDER_COMMAND(ReadSurfaceFloatCommand)(\t// 将读取深度数据的命令推给渲染线程进行执行 [\u0026amp;cpuDataPtr, \u0026amp;mydata, \u0026amp;buffsize](FRHICommandListImmediate\u0026amp; RHICmdList) //\u0026amp;cpuDataPtr, \u0026amp;mydata, \u0026amp;buffsize为传入的外部参数 { FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, 1); FTexture2DRHIRef uTex2DRes = FSceneRenderTargets::Get(RHICmdList).GetSceneDepthSurface();\tbuffsize = uTex2DRes-\u0026gt;GetSizeXY(); uint32 sx = buffsize.X; uint32 sy = buffsize.Y; mydata.AddUninitialized(sx * sy); uint32 Lolstrid = 0; cpuDataPtr = (float*)RHILockTexture2D(uTex2DRes,0,RLM_ReadOnly,Lolstrid,true);\t// 加锁 获取可读depth Texture深度值数组首地址 memcpy(mydata.GetData(), cpuDataPtr, sx * sy * sizeof(DepthPixel));\t//复制深度数据 RHIUnlockTexture2D(uTex2DRes, 0, true);\t//解锁 FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, -1);\t}); FlushRenderingCommands();\t//等待渲染线程执行 mydata; //最终获取深度数据 最终返回的mydata数据就是最终的深度值数组，其中每个深度值的结构是DepthPixel，其中一个成员为depth，另外四个不不使用。其中使用上面的几个命令需要添加\u0026quot;RHI.h\u0026ldquo;头文件\nWay2：写个请求类读取 UML图：\n流程图：\n1. 首先在项目的build.cs文件添加： 添加引擎源码地址\n1 2 3 4 5 6 7 8 9 // 添加引擎源码地址 string EnginePath = \u0026#34;C:/Program Files (x86)/UE4+VS2017/UnrealEngine/\u0026#34;; PrivateIncludePaths.AddRange( new string[] { EnginePath + \u0026#34;Source/Runtime/Renderer/Private\u0026#34;, EnginePath + \u0026#34;Source/Runtime/Renderer/Private/CompositionLighting\u0026#34;, EnginePath + \u0026#34;Source/Runtime/Renderer/Private/PostProcess\u0026#34; } ); 添加引依赖项\n2. 类实现 将下面类代码复制到PostProcessing.h文件任意位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /*****************************************Get Depth Class*******************************************************/ /*\t存储一个像素的缓存 depth 深度缓存 stencil （抠图缓存）*/ struct DepthPixel { float depth; char stencil; char unused1; char unused2; char unused3; }; /*\t存储整个视窗的缓存 data\t像素缓存数组 bufferSizeX\t缓存大小X bufferSizeY\t缓存大小Y pixelSizeBytes\t像素缓存字节数*/ struct DepthResult { TArray\u0026lt;DepthPixel\u0026gt; data; int bufferSizeX; int bufferSizeY; int pixelSizeBytes; }; /*\t获取深度缓存的类\t*/ class RENDERER_API DepthCapture { public: /*\t静态成员，当用户发出一个获取深度缓存的请求后，waitForCapture长度加1，新增DepthResult内容为空 当系统完成一个深度缓存的请求后，waitForCapture长度减一 */ static TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; waitForCapture; /*\t静态成员，当系统完成一个深度缓存的请求后，finishedCapture长度加1， 新增DepthResult含有深度缓存信息\t*/ static TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; finishedCapture; public: /*用户发出一个获取深度缓存的请求时调用*/ static void AddCapture() { waitForCapture.Enqueue(new DepthResult()); } /*系统完成一个深度缓存请求后调用*/ static void FinishedCapture(DepthResult *result) { finishedCapture.Enqueue(result); } /*返回是否存在已经完成的请求*/ static bool HasFinishedCapture() { return !finishedCapture.IsEmpty(); } /*如果存在已完成的请求，返回一个深度结果*/ static DepthResult* GetIfExistFinished() { DepthResult* result = NULL; if (!finishedCapture.IsEmpty()) { finishedCapture.Dequeue(result); } return result; } /*返回是否存在等待系统执行的请求*/ static bool HasCaptureRequest() { return !waitForCapture.IsEmpty(); } /*如果存在待完成的请求，返回一个深度结果（为空）*/ static DepthResult* GetIfExistRequest() { DepthResult* result = NULL; if (!waitForCapture.IsEmpty()) { waitForCapture.Dequeue(result); } return result; } //friend void AddPostProcessingPasses(FRDGBuilder\u0026amp; GraphBuilder, const FViewInfo\u0026amp; View, const FPostProcessingInputs\u0026amp; Inputs); }; /*****************************************end******************************************************/ 将下面类中静态成员初始化和添加执行获取代码代码复制到PostProcessing.cpp文件任意位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /*类静态成员的定义*/ TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; DepthCapture::waitForCapture; TQueue\u0026lt; DepthResult *, EQueueMode::Mpsc\u0026gt; DepthCapture::finishedCapture; /*获取深度缓存*/ void AddDepthInspectorPass(FRDGBuilder\u0026amp; GraphBuilder, const FViewInfo\u0026amp; View, DepthResult* result) { RDG_EVENT_SCOPE(GraphBuilder, \u0026#34;DepthInspector\u0026#34;); { // 获取渲染对象 FSceneRenderTargets\u0026amp; renderTargets = FSceneRenderTargets::Get(GRHICommandList.GetImmediateCommandList()); // 定义拷贝参数 uint32 striped = 0; FIntPoint size = renderTargets.GetBufferSizeXY(); result-\u0026gt;bufferSizeX = size.X; result-\u0026gt;bufferSizeY = size.Y; result-\u0026gt;data.AddUninitialized(size.X * size.Y); // 获取视窗某一帧的深度缓存对象 FRHITexture2D* depthTexture = (FRHITexture2D *)renderTargets.SceneDepthZ-\u0026gt;GetRenderTargetItem().TargetableTexture.GetReference(); // 执行拷贝深度缓存操作，将GPU显存中的缓存信息拷贝到CPU内存中，返回指向这块CPU内存的首地址 void* buffer = RHILockTexture2D(depthTexture, 0, EResourceLockMode::RLM_ReadOnly, striped, true); // 将缓存结果拷贝到result，用于输出 memcpy(result-\u0026gt;data.GetData(), buffer, size.X * size.Y * 8); // 必须执行解锁语句，否则被锁住的GPU缓存信息将不能释放 RHIUnlockTexture2D(depthTexture, 0, true); // 拷贝结果入队 DepthCapture::FinishedCapture(result); } } //////////////////////////////////////// PostProcessing.cpp中该位置添加以下代码：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 // Capture depth buffer，otherwise the buffer will be changed if (DepthCapture::HasCaptureRequest()) { DepthResult *reuslt; reuslt = DepthCapture::GetIfExistRequest(); if (reuslt) { AddDepthInspectorPass(GraphBuilder, View, reuslt); } } 3. 调用 使用以下的代码可以获取深度值，获取的结果为result：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int tickcount = 0; // Called every frame void ATestPawn::Tick(float DeltaTime) { tickcount++; if (tickcount % 2 == 0)\t// 设计几帧调用 DepthCapture::AddCapture(); // 定时发出获取深度缓存的请求 // 如果存在已完成的深度缓存请求 if (DepthCapture::HasFinishedCapture()) { DepthResult *result; // 获取已完成的深度缓存结果 result = DepthCapture::GetIfExistFinished(); if (result) { int n = result-\u0026gt;data.Num(); //this is test GEngine-\u0026gt;AddOnScreenDebugMessage(-1, -1, FColor::Blue, FString::Printf(TEXT(\u0026#34;Get Depth Size: %d \u0026#34;), n)); } } } ","description":"","id":19,"section":"posts","tags":["c++","UE4","游戏引擎"],"title":"UE4获取深度值","uri":"https://hugo.jiahongw.com/zh/posts/ue/ue-depth/"},{"content":"探索UE4游戏线程的进入\n游戏线程 \u0026amp; 渲染线程 UE4游戏线程启动 游戏线程每一帧更新所有内容。\n这个tick是哪里打开的？\n头文件：Engine\\Source\\Runtime\\Launch\\Private\\Launch.cpp\nLauch.cpp定义了一个全局的变量FEngineLoop GEngineLoop;\n该类路径：Engine\\Source\\Runtime\\Launch\\Public\\LaunchEngineLoop.h，继承一个接口类IEngineLoop，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 /** * Implements the main engine loop.\t*/ class FEngineLoop #if WITH_ENGINE : public IEngineLoop #endif { public: /** Default constructor. */ FEngineLoop(); virtual ~FEngineLoop() { } public: /** * Pre-Initialize the main loop, and generates the commandline from standard ArgC/ArgV from main(). * * @param ArgC The number of strings in ArgV. * @param ArgV The command line parameters (ArgV[0] is expected to be the executable name). * @param AdditionalCommandLine Optional string to append to the command line (after ArgV is put together). * @return Returns the error level, 0 if successful and \u0026gt; 0 if there were errors. */ int32 PreInit(int32 ArgC, TCHAR* ArgV[], const TCHAR* AdditionalCommandline = nullptr); /** * Pre-Initialize the main loop - parse command line, sets up GIsEditor, etc. * * @param CmdLine The command line. * @return The error level; 0 if successful, \u0026gt; 0 if there were errors. */ int32 PreInit(const TCHAR* CmdLine); /** First part of PreInit. */ int32 PreInitPreStartupScreen(const TCHAR* CmdLine); /** Second part of PreInit. */ int32 PreInitPostStartupScreen(const TCHAR* CmdLine); /** Load all modules needed before Init. */ void LoadPreInitModules(); /** Load core modules. */ bool LoadCoreModules(); /** Clean up PreInit context. */ void CleanupPreInitContext(); #if WITH_ENGINE /** Load all core modules needed at startup time. */ bool LoadStartupCoreModules(); /** Load all modules needed at startup time. */ bool LoadStartupModules(); /** * Initialize the main loop (the rest of the initialization). * * @return The error level; 0 if successful, \u0026gt; 0 if there were errors. */ virtual int32 Init() override; /** Initialize the timing options from the command line. */ void InitTime(); /** Performs shut down. */ void Exit(); /** Whether the engine should operate in an idle mode that uses no CPU or GPU time. */ bool ShouldUseIdleMode() const; // Advances the main loop.推进主循环 virtual void Tick() override; /** Removes references to any objects pending cleanup by deleting them. */ virtual void ClearPendingCleanupObjects() override; #endif // WITH_ENGINE /** RHI post-init initialization */ static void PostInitRHI(); /** Pre-init HMD device (if necessary). */ static void PreInitHMDDevice(); public: /** Initializes the application. */ static bool AppInit(); /** * Prepares the application for shutdown. * * This function is called from within guarded exit code, only during non-error exits. */ static void AppPreExit(); /** * Shuts down the application. * * This function called outside guarded exit code, during all exits (including error exits). */ static void AppExit(); private: /** Utility function that processes Slate operations. */ void ProcessLocalPlayerSlateOperations() const; protected: /** Holds a dynamically expanding array of frame times in milliseconds (if FApp::IsBenchmarking() is set). */ TArray\u0026lt;float\u0026gt; FrameTimes; /** Holds the total time spent ticking engine. */ double TotalTickTime; /** Holds the maximum number of seconds engine should be ticked. */ double MaxTickTime; /** Holds the maximum number of frames to render in benchmarking mode. */ uint64 MaxFrameCounter; /** Holds the number of cycles in the last frame. */ uint32 LastFrameCycles; #if WITH_ENGINE /** Holds the objects which need to be cleaned up when the rendering thread finishes the previous frame. */ FPendingCleanupObjects* PendingCleanupObjects; #endif //WITH_ENGINE private: #if WITH_ENGINE /** Holds the engine service. */ FEngineService* EngineService; /** Holds the application session service. */ TSharedPtr\u0026lt;ISessionService\u0026gt; SessionService; #endif // WITH_ENGINE FPreInitContext PreInitContext; }; 该文件只需#include \u0026quot;CoreMinimal.h\u0026quot;，最多加上#include \u0026quot;UnrealEngine.h\u0026quot;\n接口类，位于路径Engine\\Source\\Runtime\\Engine\\Public\\UnrealEngine.h：\n1 2 3 4 5 6 7 8 9 /** Public interface to FEngineLoop so we can call it from editor or editor code */ class IEngineLoop { public: virtual int32 Init() = 0; virtual void Tick() = 0; /** Removes references to any objects pending cleanup by deleting them. */ virtual void ClearPendingCleanupObjects() = 0; }; 开启Tick函数之前需要初始化，初始化函数在Launch.cpp这个文件中：\n1 2 3 4 5 6 /* Inits the engine loop */ int32 EngineInit() { int32 ErrorLevel = GEngineLoop.Init(); return( ErrorLevel ); } GEngineLoop.Init()函数：\n其中会判断是进入那种引擎模式，分为Game模式与Editor模式。\n结束引擎的函数为：\n1 2 3 4 5 6 7 8 9 10 /** * Shuts down the engine */ void EngineExit( void ) { // Make sure this is set RequestEngineExit(TEXT(\u0026#34;EngineExit() was called\u0026#34;)); GEngineLoop.Exit(); } 也在Launch.cpp\nLaunch.cpp中的函数多次使用GEngine这个外部变量，这个变量在上面的初始化函数会自定设置为相应的引擎，即Game引擎或者Editor引擎：\n所在文件Engine.h\n在FEngineLoop::Tick()函数会调用GEngine的Tick函数：\n也就是本文开始的那个Tick函数。\n","description":"","id":20,"section":"posts","tags":["c++","UE4","游戏引擎"],"title":"UE游戏、渲染线程","uri":"https://hugo.jiahongw.com/zh/posts/ue/ue-game-render/"},{"content":"大概介绍以下UE4的主要渲染过程。\nUE4渲染过程 延迟渲染 所谓延迟渲染，是指将一个场景的几何体（3D模型、多边形）的光照、阴影、质感搁置到一旁，先着手于绘画，然后在后半段再对光照、阴影、质感进行处理的处理方式。即给人一种把原本的多边形先绘制出来的印象，实际上不仅要绘制多边形，前者的参数还需要配合后面光照和阴影的处理。其输出目标，在成为复数缓冲时具有普遍性，但是这里的缓冲我们称之为\u0026quot;物理缓冲\u0026quot;。物体缓冲是指使用后照明和后处理特效的中间过渡环节\n相关术语 RHI\n渲染硬件接口，是为不同平台抽象出不同图形API的一层。所有渲染命令均通过RHI层传递，以转换为适用的渲染器。\n延迟渲染\n虚幻引擎4中的默认渲染器。它因将照明/阴影计算推迟到全屏过程而不是绘制每个网格时而得名。\n顶点工厂\n顶点工厂是封装顶点数据源并链接到顶点着色器上的输入的类。静态网格物体，骨架网格物体和过程网格组件均使用不同的顶点工厂。\n着色器\n在虚幻引擎中，着色器是HLSL代码（以.ush / .usf文件的形式）和材质图的内容的组合。在Unreal中创建材质时，它会根据设置（如着色模式）和用法来编译多个着色器排列。\n渲染数据 相关的渲染的数据包括深度值及一些Gbuffer，如下图：\n几个Pass Z Pre Pass UE4的渲染管道，是在Bass Pass的物体缓冲写出来之前，在仅预处理深度值（Z值）之后，运行Z预阶段。\n事先预处理深度值的目的，是将最终影像和同一深度缓冲的内容结果，在透视前获得。Z预阶段之后的Base Pass则是，参考预先得出的深度值缓冲进行Z预测试，因此通过在最终的画面里不留下像素痕迹（即编写后又被消去的像素），以回避像素着色器的运行。\nBase Pass\n使用Base Pass输出物体缓冲需要注意的两点：\n不绘制没进入视线的对象\n这种\u0026quot;投影剔除\u0026quot;（Frustum Culling），一般是通过CPU端来处理；为了整体覆盖被称为\u0026quot;包围球\u0026quot;（Bounding sphere）的各个3D对象，对象是否在视野内的判定标准，是通过预先设定的包围球来实行的。\n什么程度的剔除会成功，可以通过Stat初始视图（Stat InitViews）指令的\u0026quot;视锥体裁剪基元（Frustum Culled Primitives）\u0026ldquo;进行确认。\n不计算多余的像素\n在图像处理的流程中，使用像素着色器实际处理前，会有运行深度测试（Z 测试）的\u0026quot;Pre Z 测试\u0026quot;这一步骤。从这里着手处理的像素，会因为被某个东西所遮挡而无法绘制出来，这时可以进行撤销处理。\n但是，像半透明对象这种会伴随α测试的绘制、视差遮蔽映射这种像素着色器处理后会重新编写深度值的情况，就不进行Pre Z测试，而通过处理实行分路迂回。\nUE4 绘制策略DrawingPolicy\n绘制策略在UE4渲染中使用很多， 中文也不好翻译。 其实就是根据策略 使用了哪些 着色器 。\n\u0026hellip;\u0026hellip;\u0026hellip;.\nUE4渲染一帧 渲染管道 首先，虚幻的渲染由三个线程共同完成。分别是CPU线程，DRAW线程，和GPU线程。\n知乎：https://zhuanlan.zhihu.com/p/57158725\nRender模块 调用Render()函数在Render模块RendererModule.h中，以下函数：\n1 2 3 4 5 class FRendererModule : public IRendererModule { // 开始渲染视图族 virtual void BeginRenderingViewFamily(FCanvas* Canvas,FSceneViewFamily* ViewFamily) override; } ==谁最终调用了Render？==\n实时渲染流程图： part1:https://i.loli.net/2020/05/30/qU8vN2WZVbt9hkF.jpg\npart2:https://i.loli.net/2020/05/30/3trKVpOMU5sTQfB.jpg\n渲染函数Render 路径：Engine \\ Source \\ Runtime \\ Renderer \\ Private \\ DeferredShadingRenderer.cpp（660）\n函数：FDeferredShadingSceneRenderer :: Render（）渲染路径\n全局系统纹理初始化 DeferredShadingRenderer.cpp（677） GSystemTextures.InitializeTextures（） 保护 必要的渲染目标您是否已确保可以保护的最大目标数目？ DeferredShadingRenderer.cpp（680） GSceneRenderTargets.Allocate（） 初始化每个视口 设置视口显示的对象，选择使用动态阴影时显示的对象，对半透明对象进行排序 DeferredShadingRenderer.cpp（683） InitViews()（） FXSystem预处理 GPU粒子正在被仿真 DeferredShadingRenderer.cpp（758） FXSystem-\u0026gt; PreRender（） 启用Z Pre-Pass时执行的早期Z绘制 不绘制Tile渲染的硬件（移动设备，Android或iOS）对于 PC或PS4，将生成深度缓冲区和HiZ，因此后续绘制速度很快成为？ DeferredShadingRenderer.cpp（768） RenderPrePass（） 安全GBuffer DeferredShadingRenderer.cpp（774） GSceneRenderTargets.AllocGBufferTargets（） 透明光传播量 DeferredShadingRenderer.cpp（779） ClearLPVs（） 使用DBuffer时绘制延期贴图单击此处获取 DBuffer和延期贴图 DeferredShadingRenderer.cpp（796） GCompositionLighting.ProcessBeforeBasePass（） 如有必要，请 在绘制线框图时清除GBuffer透明颜色缓冲区， 有些游戏在发行游戏时无法清除GBuffer或屏幕。 DeferredShadingRenderer.cpp（805） SetAndClearViewGBuffer（） DeferredShadingRenderer.cpp（816） RHICmdList.Clear（） 渲染不透明的对象渲染 项目，这些项目根据它们是Masked还是Default，是否有LightMap等按每种排序顺序进行了精细分类 DeferredShadingRenderer.cpp（828） RenderBasePass（） 清除 GBuffer 的未绘制部分如果事先清除GBuffer，则不必要。 DeferredShadingRenderer.cpp（851） ClearGBufferAtMaxZ（） 绘制 自定义深度请参见此处以获取自定义深度 DeferredShadingRenderer.cpp（860） RenderCustomDepthPass（） 在这里再次模拟GPU粒子除了在这里 处理使用深度缓冲区执行碰撞检测的 粒子外，还对GPU粒子进行排序 DeferredShadingRenderer.cpp（865） 场景-\u0026gt; FXSystem-\u0026gt; PostRenderOpaque（） 为SceneDepthTexture创建一个半分辨率（每个方面为1/4分辨率）的缓冲区 DeferredShadingRenderer.cpp（875） UpdateDownsampledDepthSurface（） 执行阻塞测试 HZB的构建，执行提交 的HZB Attotempkinder的这篇文章指 DeferredShadingRenderer.cpp（881） BeginOcclusionTests（） 开始写 因为有点复杂，所以要写一些细节 DeferredShadingRenderer.cpp（890） 不使用DBuffer绘制延迟的贴图 CompositionLighting.cpp（293） AddDeferredDecalsBeforeLighting（） 在屏幕空间中绘制环境光遮挡 CompositionLighting.cpp（300） AddPostProcessingAmbientOcclusion（） 后期处理环境立方体贴图 CompositionLighting.cpp（305） AddPostProcessingAmbientCubemap（） 到这里为止的一系列处理 DeferredShadingRenderer.cpp（904） GCompositionLighting.ProcessAfterBasePass（） 透明的体积光缓冲液可提高透明度 DeferredShadingRenderer.cpp（908） ClearTranslucentVolumeLighting（） 从此处开始的主要照明设备 收集要绘制的灯光并将其排序 不要投影，不使用灯光功能的灯光将使用“ 基于图块” 绘制（如果可能）如果不能使用“ 基于图块”关于延迟渲染，这是味o，但请参见此处 LightRendering.cpp（312-348） LightRendering.cpp（423） RenderTiledDeferredLighting（） LightRendering.cpp（429） RenderSimpleLightsStandardDeferred（） 它不会阴影，也不会使用灯光功能，但是似乎无法使用TBDR绘制的灯光 被称为标准延迟灯光。 LightRendering.cpp（445） RenderLight（） 如果用于半透明的体积光是有效的，则将每个光注入到体积光中 ，从而在3D纹理上绘制光效果。 LightRendering.cpp（455） InjectTranslucentVolumeLightingArray（） LightRendering.cpp（461） InjectSimpleTranslucentVolumeLightingArray（） 使用灯光功能投射阴影的灯光将单独处理 LightRendering.cpp（468-552） 首先，我在投射阴影时 绘制了一个阴影贴图；在这里我还绘制了一个 半透明的阴影贴图；我记得半透明的当然是傅立叶不透明度贴图。 LightRendering.cpp（495） RenderTranslucentProjectedShadows（） LightRendering.cpp（497） RenderProjectedShadows（） 使用LPV时绘制反射阴影贴图 LightRendering.cpp（508） RenderReflectiveShadowMaps（） 灯光功能图 阴影指示器图 LightRendering.cpp（515） RenderLightFunction（） LightRendering.cpp（522） RenderPreviewShadowsIndicator（） 衰减缓冲器中的分辨 光的衰减信息是否曾经被吸入另一个缓冲器中？ LightRendering.cpp（534） GSceneRenderTargets.FinishRenderingLightAttenuation（） 注入体积光以获得半透明 LightRendering.cpp（541） InjectTranslucentVolumeLighting（） 这 是使用光功能投射阴影的光处理的结束。 LightRendering.cpp（550） RenderLight（） 这 是每个光的LPV 的主要注入照明过程的结尾 LightRendering.cpp（561-593） Lpv-\u0026gt; InjectLightDirect（） 注入体积光以实现环境立方体贴图的半透明 DeferredShadingRenderer.cpp（916） InjectAmbientCubemapTranslucentVolumeLighting（） 过滤体积光以获得半透明 DeferredShadingRenderer.cpp（919） FilterTranslucentVolumeLighting（） LPV传输过程 此外，第921行的注释上写有“ copypimis”，例如“ Clear LPV buffer”。 DeferredShadingRenderer.cpp（924） PropagateLPVs（） 动态天光绘图 DeferredShadingRenderer.cpp（928） RenderDynamicSkyLighting（） 延迟的反射图形 捕获的反射图形而不是屏幕空间 DeferredShadingRenderer.cpp（931） RenderDeferredReflections（） LPV的GI绘图 CompositionLighting.cpp（344） AddPostProcessingLpvIndirect（） 屏幕空间次表面散射（SSSSS）的后处理 CompositionLighting.cpp（347-376） 如果启用了“光轴”，则绘制“光轴遮挡” DeferredShadingRenderer.cpp（953） RenderLightShaftOcclusion（） 大气雾图 DeferredShadingRenderer.cpp（977） RenderAtmosphere（） 绘图雾 这是高度雾吗？ DeferredShadingRenderer.cpp（986） RenderFog（） 画一个半透明的物体 在这里也画一个单独的半透明的东西 DeferredShadingRenderer.cpp（1000） RenderTranslucency（） 折射变形处理 DeferredShadingRenderer.cpp（1008） RenderDistortion（） 光轴的起霜处理 DeferredShadingRenderer.cpp（1013） RenderLightShaftBloom（） 距离场AO处理不能在 当前不支持多个视口 的分屏游戏中使用吗？ DeferredShadingRenderer.cpp（1019） RenderDistanceFieldAOSurfaceCache（） 它只是在查看网格的“距离场”的可视化处理结果吗？ DeferredShadingRenderer.cpp（1024） RenderMeshDistanceFieldVisualization（） 由于速度模糊而绘制运动对象的速度 DeferredShadingRenderer.cpp（1034） RenderVelocities（） 从这里到最后的发布过程， 这也很复杂而且很长 DeferredShadingRenderer.cpp（1047） GPostProcessing.Process（） 使用BeforeTranslucency设置绘制后处理材料 PostProcessing.cpp（878） AddPostProcessMaterial（） 景深处理 通过高斯模糊进行DOF 处理之后，正在执行散焦处理（使用指定的光圈形状的纹理进行绘制）， 在此阶段似乎合并了单独的半透明缓冲区 PostProcessing.cpp（888） AddPostProcessDepthOfFieldGaussian（） PostProcessing.cpp（898） AddPostProcessDepthOfFieldBokeh（） PostProcessing.cpp（905） FRCPassPostProcessBokehDOFRecombine （如果未启用模糊） 使用BeforeTonemapping设置绘制后处理材料 PostProcessing.cpp（913） AddPostProcessMaterial（） 如果要使用TemporalAA ，请在此处绘制，如果使用FXAA，请稍后再绘制 PostProcessing.cpp（921） AddTemporalAA（） PostProcessing.cpp（928） AddTemporalAA（） （如果不使用速度缓冲区，请单击此处） 运动模糊处理 设置，分辨率下采样，高斯模糊，运动模糊绘制，组合处理 PostProcessing.cpp（932-994） FRCPassPostProcessMotionBlurSetup FRCPassPostProcessDownsample RenderGaussianBlur（） FRCPassPostProcessMotionBlur FRCPassPostProcessMotionBlurRecombine SceneColor下采样 PostProcessing.cpp（1000） FRCPassPostProcessDownsample 直方图 PostProcessing.cpp（1006-1040） FRCPassPostProcessHistogram FRCPassPostProcessHistogramReduce 此处需要眼睛适应图直方图 PostProcessing.cpp（1046） AddPostProcessEyeAdaptation（） 布卢姆绘图 PostProcessing.cpp（1057） AddBloom（） PostProcessing.cpp（1060-1148） （对于移动设备，请单击此处） 色调映射 仅替换ReplacecingTonemapper设置工程图的一种后处理材料，但是 如果存在该材料，则执行默认色调映射 PostProcessing.cpp（1155） AddSinglePostProcessMaterial（） PostProcessing.cpp（1171） AddTonemapper（） （默认色调映射） 如果启用了FXAA，请在此处处理 PostProcessing.cpp（1177） AddPostProcessAA（） 绘制一些编辑器（如选定的轮廓）， 然后使用AfterTonemapping设置绘制后期处理材料 PostProcessing.cpp（1244） AddPostProcessMaterial（） 用于地下和GBuffer的可视化 调试 PostProcessing.cpp（1246-1254） 用于HMD的后处理 Oculus或Morpheus PostProcessing.cpp（1256-1277） FRCPassPostProcessHMD FRCPassPostProcessMorpheus 之后，调试和高分辨率屏幕截图功能等。 之后，进行后处理并结束！ 谢谢！ PostProcessing.cpp（1279-） 哦，很长。\n参考链接：\n如何在C ++中从UTexture2D读取数据\nhttps://forums.unrealengine.com/development-discussion/c-gameplay-programming/1422920-casting-converting-frhitexture-to-utexture\nUnreal渲染相关的缓冲区\nhttps://qiita.com/mechamogera/items/a0c369a3b853a3042cae\nhttps://answers.unrealengine.com/questions/17862/access-color-and-depth-buffer-of-each-frame.html\nhttps://segmentfault.com/a/1190000012737548\nGbuff数据\n渲染系统概述 图片\n","description":"","id":21,"section":"posts","tags":["c++","UE4","游戏引擎"],"title":"UE4渲染过程","uri":"https://hugo.jiahongw.com/zh/posts/ue/ue4-render/"},{"content":"RSA算法 RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。\n对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到当前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。\n公钥/双密钥/非对称 加密 涉及到两个密钥的使用:\n一个公钥, 可以被任何人知道，用于加密消息和验证签名 一个私钥, 只有接收方才知道，用于解密消息和创造签名 RSA实现过程 1. 公钥与私钥的产生 生成公钥e和私钥d的步骤如下：\n随意选择两个大的质数$p$和$q$，$p$不等于$q$，计算$n=pq$。 根据欧拉函数，求$r = \\varphi (N) = \\varphi (p)\\varphi (q) = (p - 1)(q - 1)$ 选择一个小于$r$的整数$e$，使$e$与$r$互质。并求得$e$关于$r$的模反元素，命名为$d$(求$d$令$ed \\equiv 1(\\bmod ;r)$)。(模反元素存在，当且仅当$e$与$r$互质) 将$p$和$q$的记录销毁 经过上面四个步骤最终可以得到公钥$(n,e)$和私钥$(n,d)$。\n接收消息的人将自己的公钥$(n,e)$发送给发送消息的人,发送的人使用这个公钥加密信息发送给接收方，而接收方将私钥$(n,d)$保存起来用于解密。\n下面实现RSA类\n参考资料：\n米勒-拉宾素性检验 RSA加密算法 C++实现 实验步骤与结果 1.实现大整数类 因为该加密算法涉及的数可能很大，而C++中并没有像Java一样，内置大整数类BigInteger，故需自己实现，这里我参考了网上的一些资料设计了BigInteger类，实现了加减乘除以及模幂等运算，也实现了运算符重载，具体参考实现的方法如下：\n2. 设计RSA类 编写rsa.h头文件，定义RSA类，其中包含的成员以及成员函数如下：\n下面分别实现上述的各个方法\n首先要生成密钥对，即生成公钥和私钥，那么，我们首先需要生成两个大素数p和q,显然，素数是不可能是偶数的，故定义一个生成随机奇数的函数BigInteger createOddNum(unsigned len)参数为奇数的长度。\n使用16进制的随机字母，然后随机选取其中的len/4个得到一个随机的大奇数，只需要末尾那个数为奇数即可，最后返回BigInteger类型的奇数大整数，关键代码如下：\n然后定义一个生成素数的函数，其中用到米勒-拉宾素性检验算法判断生成的素数是否为素数素数：\n米勒-拉宾素性检测算法 基于以下定理：\n费马小定理 要测试$N$是否为素数，首先将$N−1$分解为$2^{s}d$。在每次测试开始时，先随机选一个介于$[1,N−1]$的整数$a$，之后如果对所有的$r∈[0,s−1]$，若${a^d}\\bmod N \\ne 1$且${a^{{2^r}d}}\\bmod N \\ne - 1$，则$N$是合数。否则，$N$有$3/4$的概率为素数。\n关键代码如下：\n生成素数的逻辑就是首先使用函数createOddNum生成一个大奇数，然后调用isPrime判断是否为一个素数，是的话就可以return，不然继续寻找，知道生成一个素数。\n接下来计算n值，n值的计算很简单，直接使用$n = p * q$ 这个式子就能够计算出来；计算欧拉值也一样，可以使用$\\varphi(n) = (p-1) * (q-1)$得出。其中比较难的是生成的私钥d。\n下面定义一个RSA类的初始化函数init()​，生成p、q以及密钥对，如下：\n在创建公钥e和私钥d的函数createExponent(eul)中，首先创建一个比欧拉值小的公钥e，其中e为一个素数，直接调用函数createPrime()生成，然后使用大整数类中的求模逆元，即求出私钥d。\n扩展欧几里得算法 逆元\n逆元是模运算中的一个概念，我们通常说 A 是 B 模 C 的逆元，实际上是指 A * B = 1 mod C，也就是说 A 与 B 的乘积模 C 的余数为 1。可表示为 A = B^(-1) mod C。\n打个比方，7 模 11 的逆元，即：7^(-1) mod 11 = 8，这是因为 7 × 8 = 5 × 11 + 1，所以说 7 模 11 的逆元是 8。\n扩展欧几里得算法是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式\n$$\nax{\\rm{ }} + {\\rm{ }}by{\\rm{ }} = {\\rm{ }}gcd\\left( {a,b} \\right).\n$$\n在RSA算法中求私钥中的整数d时，需要使得 (e * d ) % n = 1，该方程等价于 e * d = 1 + y * n （y为整数），也等价于 e * d - y * n = 1。\n因此求解d的过程就是求解该二元一次方程组（e和n已知，求解d），即求e模n的逆元。\n关键代码如下：\n我们知道，RSA的加密与解密其实就是一个模幂的运算，而这个模幂的运算已经在大整数类中实现了，如下：\n使用RSA类进行加密解密的函数只需要调用这个模幂运算即可，例如私钥加密可以这样调用：\n以上就设计完了RSA类的相关操作，主要是包括密钥的生成。下面将RSA加密解密的操作封装在一个类中。\n3. 设计加密解密类EncryptDecrypt 主要的方法及成员如下：\n实现RSA加密解密字符串 加密字符串的逻辑是，先将字符串以每两个字符 一组，转化为一个16进制数据序列，使用vector容器保存，之后调用rsa的公钥加密函数进行加密，如下是关键代码：\n解密函数其实是接受一个加密后的16进制序列，然后对这个序列调用RSA的私钥解密函数进行解密，然后得到解密后的16进制数据序列，最后还有一步就是需要将这个16进制序列最终转化为原来的字符串，只需要根据ascii码的数值即可得到，这里编写了一个hex2string函数，关键代码如下：\n实现效果\n首先显示密钥：\n加密字符串\n解密字符串\n实现RSA加密解密文件 实现RSA加密解密文件时基于RSA加密解密字符串实现的，其中主要的加密逻辑就是将一个文件看作是一行一行的字符串文本，没每读取一行，就调用加密字符串的函数进行加密，然后将加密得到的16进制序列写入到另外一个文件中，而这个文件也就是加密后的文件，主要关键代码如下：\n解密文件的函数稍微有点不一样，是从打开的待解密文件中循环读取每一个16进制数据，然后对每一个16进制数据调用解密函数得到解密后的16进制数据，将16进制数据转为字符串后再相继的写到另外一个文件中，即解密后的文件，关键代码如下：\n实现效果\n加密文件\n解密文件\n加密文件解密文件对比\n实现RSA数字签名及验证 实现数字签名方案，按照以下的流程图进行操作。\n首先需要对文件进行信息的摘要，得到Hash值，这里选择的Hash算法是SHA512算法，可以直接对文件进行信息摘要。\n可以直接include C++ 实现的\u0026quot;sha512.h\u0026quot;文件头，然后使用以下的语句就能够生成一个长度为512的Hash值，如下：\n可以在命令行输出文件的Hash摘要值如下:\n数字签名的实现类似字符串加密，对文件的hash值进行加密得到后面的16进制序列，然后将16进制序列伴随文件发送出去，签名的关键代码就是对hash值进行加密，如下：\n验证函数直接将16进制序列进行解密，然后还原成字符串再与收到的文件的hash值进行比较，如果相等，那么验证成功；否则验证失败，关键代码如下：\n实现效果\n数字签名\n验证数字签名\n","description":"","id":22,"section":"posts","tags":["rsa","密码学"],"title":"RSA加密算法","uri":"https://hugo.jiahongw.com/zh/posts/cryptography/rsa/"},{"content":"AES算法是继DES之后比较快且比较简单的加密算法.⚖\n对称加密 对称加密模型 如下图，发送者和接收者共享一个一样的密钥，相当于现实生活中的锁，\n对称加密的使用要求 一个强加密算法 只有发送发和接收方知道私钥 加密算法是公开的，不需保密；并且解密算法本质上是加密算法的反向执行。\n但是，如何安全的分发安全密钥呢？——————安全分发不可能单靠对称加密算法，常常使用的是非对称加密算法。\n所以，对称加密的安全性取决于密钥的保密性而非算法的保密性，通常认为已知密文和加密/加密算法的基础上不能够破译信息。\nAES算法 算法原理： AES密码与分组密码Rijndael基本上完全一致，Rijndael分组大小和密钥大小都可以为128位、192位和256位。然而AES只要求分组大小为128位，因此只有分组长度为128Bit的Rijndael才称为AES算法。\n下面是分组长度为128位的AES算法,而key位数可以是128/192/256,本次实验选择key的大小位128位.\n特点 明文分组被描述为一个字节方阵并复制到状态数组，在每轮替换和移位时都并行处理整个状态分组。 矩阵中字节的顺序是按列排序的，例如128比特的明文分组的前4个字节占输入矩阵的第一列，接下来的4个字节占第二列，依次类推。扩展子密钥数组也类似操作。 假设AES使用128比特的密钥，其密钥被描述为一个字节方阵并将扩展成为一个子密钥数组w[i]（具有44个32比特字），4个不同的字（共128比特）用作每轮的轮密钥。 AES在每轮运算中将进行4个不同的步骤，1个是移位，3个是替换。 数学知识 在AES算法中的MixColumn层中会用到伽罗瓦域中的乘法运算，而伽罗瓦域的运算涉及一些数学知识。\n素域 有限域有时也称伽罗瓦域，它指的是由有限个元素组成的集合，在这个集合内可以执行加、减、乘和逆运算。而在密码编码学中，我们只研究拥有有限个元素的域，也就是有限域。域中包含元素的个数称为域的阶。只有当m是一个素数幂时，即$m=p^n$(其中n为正整数是p的次数，p为素数)，阶为m的域才存在。p称为这个有限域的特征。\n例如，有限域中元素的个数可以是11(p=11是一个素数,n=1)、可以是81(p=3是一个素数，n=4)、也可以是256(p=2是一个素数，n=8)\u0026hellip;..但有限域的中不可能拥有12个元素，因为12=2·2·3，因此12也不是一个素数幂。因此满足p是一个素数且满足$m = p^n$这个公式，m才是一个素数幂。\n有限域中最直观的例子就是阶为素数的域，即n=1的域。域GF(p)的元素可以用整数0、1、\u0026hellip;、p-1l来表示。域的两种操作就是模整数加法和整数乘法模p。加上p是一个素数，整数环Z表示为GF(p)，也成为拥有素数个元素的素数域或者伽罗瓦域。GF(p)中所有的非零元素都存在逆元，GF(p)内所有的运算都是模p实现的。\n素域内的算数运算规则如下 加法和乘法都是通过模p实现的； 任何一个元素a的加法逆元都是由a+(a的逆元)=0 mod p得到的； 任何一个非零元素a的乘法逆元定义为a·a的逆元=1。 举个例子，在素域GF(5)={0、1、2、3、4}中，2的加法逆元为3，这是因为2+(3)=5，5mod5=0,所以2+3=5mod5=0。2的乘法逆元为3，这是因为2·3=6，6mod5=1，所以2·3=6mod5=1。(在很多地方a的加法逆元1用$-a$表示，a的乘法逆元2用$1/a$表示)\n注：GF(2)是一个非常重要的素域，也是存在的最小的有限域，由于GF(2)的加法，即模2加法与异或(XOR)门等价，GF(2)的乘法与逻辑与(AND)门等价，所以GF(2)对AES非常重要。\n模2加法与异或(XOR)门等价:\n$$\n(1 + 0) \\mod 2 = 1\\\\\n(0 + 1) \\mod 2 = 1\\\\\n(0 + 0) \\mod 2 = 0\\\\\n(1 + 1) \\mod 2 = 0\\\\\n$$\n乘法与逻辑与(AND)门等价:\n$$\n(1 \\times 0) \\mod 2 = 0\\\\\n(0 \\times 1) \\mod 2 = 0\\\\\n(0 \\times 0) \\mod 2 = 0\\\\\n(1 \\times 1) \\mod 2 = 1\\\\\n$$\n扩展域 如果有限域的阶不是素数，则这样的有限域内的加法和乘法运算就不能用模整数加法和整数乘法模p表示。而且m\u0026gt;1的域被称为扩展域，为了处理扩展域，我们就要使用不同的符号表示扩展域内的元素，使用不同的规则执行扩展域内元素的算术运算。\n在扩展域$GF(2^m)$中，元素并不是用整数表示的，而是用系数为域$GF(2)$中元素的多项式表示。这个多项式最大的度(幂)为m-1​，所以每个元素共有m个系数，在AES算法使用的域$GF(2^8)$中，每个元素$A∈GF(2^8)$都可以表示为：\n$$\nA(x) = a_7x^7 + a_6x^6 + a_5x^5 + a_4x^4 + a_3x^3 + a_2x^2+a_1x + a_0,x_i \\in GF(2) = 0,1\n$$\n注意：在域GF(2^8)中这样的多项式共有256个，这256个多项式组成的集合就是扩展域GF(2^8)。每个多项式都可以按一个8位项链的数值形式存储：\n$$\nA = (a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0)\n$$\n像$x^7$、$x^6$等因子都无需存储，因为从位的位置就可以清楚地判断出每个系数对应的幂。\n扩展域$GF(2^m)$内的加减法 在AES算法中的密钥加法层中就使用了这部分的知识，但是不是很明显，因为我们通常把扩展域中的加法当作异或运算进行处理了，因为在扩展域中的加减法处理都是在底层域GF(2)内完成的，与按位异或运算等价。假设$A(x)$、$B(x)∈GF(2^m)$，计算两个元素之和的方法就是：\n$$\nC(x) = A(x) + B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i + b_i) \\mod 2\n$$\n而两个元素之差的计算公式就是：\n$$\nC(x) = A(x) - B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i - b_i) \\mod 2 = (a_i + b_i) \\mod 2\n$$\n注：在减法运算中减号之所以变成加号，这就和二进制减法的性质有关了，大家可以试着验算下。从上述两个公式中我们发现在扩展域中加法和减法等价，并且与XOR等价(异或运算也被称作二进制加法)。\n扩展域GF(2^m)内的乘法 扩展域的乘法主要运用在AES算法的列混淆层(Mix Column)中，也是列混淆层中最重要的操作。我们项要将扩展域中的两个元素用多项式形式展开，然后使用标准的多项式乘法规则将两个多项式相乘：\nAES步骤详解 AES算法主要有四种操作处理，分别是密钥加法层(也叫轮密钥加，英文Add Round Key)、字节代换层(SubByte)、行位移层(Shift Rows)、列混淆层(Mix Column)。而明文x和密钥k都是由16个字节组成的数据(当然密钥还支持192位和256位的长度)，它是按照字节的先后顺序从上到下、从左到右进行排列的。而加密出的密文读取顺序也是按照这个顺序读取的，相当于将数组还原成字符串的模样了，然后再解密的时候又是按照4·4数组处理的。AES算法在处理的轮数上只有最后一轮操作与前面的轮处理上有些许不同(最后一轮只是少了列混淆处理)，在轮处理开始前还单独进行了一次轮密钥加的处理。在处理轮数上，只考虑128位密钥的10轮处理。\n其中字节排列方式需要按照如下转换:\nAES算法流程图如下:\n实现步骤及代码 按照AES流程图,对每一层的代码进行实现.\n密钥加法层 在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。在扩展域中加减法操作和异或运算等价，所以这里的处理也就异常的简单了，只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n如下图：\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4 * 4], word k[4]) { for (int i = 0; i \u0026lt; 4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i + 4] = mtx[i + 4] ^ byte(k2.to_ulong()); mtx[i + 8] = mtx[i + 8] ^ byte(k3.to_ulong()); mtx[i + 12] = mtx[i + 12] ^ byte(k4.to_ulong()); } } AES密钥生成 首先定义位置变换函数RotWord(),作用是接受一个字 $[a0, a1, a2, a3] $作为输入，循环左移一个字节后输出$ [a1, a2, a3, a0]$,代码如下:\n1 2 3 4 5 6 word RotWord(const word \u0026amp;w) { word result(0x0); result = (w \u0026lt;\u0026lt; 8) | (w \u0026gt;\u0026gt; 24); return result; } 定义S盒变换函数SubWord()，接受一个字 $[a0, a1, a2, a3]$ 作为输入，然后每一个byte，例如a0，前四个字节为行，后四个字节为列，从S_Box中查找并且返回四个元素。，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 word SubWord(const word\u0026amp; sw) { word temp; for(int i=0; i\u0026lt;32; i+=8) { int row = sw[i+7]*8 + sw[i+6]*4 + sw[i+5]*2 + sw[i+4]; int col = sw[i+3]*8 + sw[i+2]*4 + sw[i+1]*2 + sw[i]; byte val = S_Box[row][col]; for(int j=0; j\u0026lt;8; ++j) temp[i+j] = val[j]; } return temp; } 轮常数Rcon[]作为一个常量数组，每一轮生成密钥的时候需要作为参数异或\n1 2 3 // 轮常数，密钥扩展中用到。（AES-128只需要10轮） word Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000}; 密钥拓展函数KeyExpansion(),接受一个参数为外部密钥，另外一个为需要拓展的轮密钥数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1),Nr为轮数 void KeyExpansion(byte key[4 * N_key], word w[4 * (N_round + 1)]) { word temp; int i = 0; while (i \u0026lt; N_key)\t//前四个word就是输入的key { w[i] = ToWord(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); ++i; } i = N_key; while (i \u0026lt; 4 * (N_round + 1)) { temp = w[i - 1]; //记录前一个word if (i % N_key == 0) { //temp先位置表换RotWord，再S盒变换，然后与轮常数异或，最后w[i-N_key] 异或 w[i] = w[i - N_key] ^ SubWord(RotWord(temp)) ^ Rcon[i / N_key - 1]; } else { w[i] = w[i - N_key] ^ temp; } i++; } } 字节替换层 S盒字节替换，主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，读取S_box数据的方法就是要将输入数据的每个字节的高四位作为第一个下标，第四位作为第二个下标。然后返回数据，字节替换主要是为了扰乱数据。\nS盒：\n逆S盒：\n图解如下：\n正向S盒变换代码如下：\n1 2 3 4 5 6 7 8 9 10 //S盒变换 - 前4位为行号，后4位为列号 void SubBytes(byte mtx[4 * 4]) { for (int i = 0; i \u0026lt; 16; ++i) { int row = mtx[i][7] * 8 + mtx[i][6] * 4 + mtx[i][5] * 2 + mtx[i][4]; int col = mtx[i][3] * 8 + mtx[i][2] * 4 + mtx[i][1] * 2 + mtx[i][0]; mtx[i] = S_Box[row][col]; } } 反向S盒变换代码如下:\n1 2 3 4 5 6 7 8 9 10 // 逆S盒变换 void InvSubBytes(byte mtx[4*4]) { for(int i=0; i\u0026lt;16; ++i) { int row = mtx[i][7]*8 + mtx[i][6]*4 + mtx[i][5]*2 + mtx[i][4]; int col = mtx[i][3]*8 + mtx[i][2]*4 + mtx[i][1]*2 + mtx[i][0]; mtx[i] = Inv_S_Box[row][col]; } } 行移位层 将输入数据作为一个$4·4$的字节矩阵进行处理，然后将这个矩阵的字节进行位置上的置换。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在$4·4$矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。最终结束。\n正向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //正向行变换 - 按字节循环移位 void ShiftRows(byte mtx[4 * 4]) { // 第二行循环左移一位 byte temp = mtx[4]; for (int i = 0; i \u0026lt; 3; ++i) mtx[i + 4] = mtx[i + 5]; mtx[7] = temp; // 第三行循环左移两位 for (int i = 0; i \u0026lt; 2; ++i) { temp = mtx[i + 8]; mtx[i + 8] = mtx[i + 10]; mtx[i + 10] = temp; } // 第四行循环左移三位 temp = mtx[15]; for (int i = 3; i \u0026gt; 0; --i) mtx[i + 12] = mtx[i + 11]; mtx[12] = temp; } 反向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 逆行变换 - 以字节为单位循环右移 void InvShiftRows(byte mtx[4*4]) { // 第二行循环右移一位 byte temp = mtx[7]; for(int i=3; i\u0026gt;0; --i) mtx[i+4] = mtx[i+3]; mtx[4] = temp; // 第三行循环右移两位 for(int i=0; i\u0026lt;2; ++i) { temp = mtx[i+8]; mtx[i+8] = mtx[i+10]; mtx[i+10] = temp; } // 第四行循环右移三位 temp = mtx[12]; for(int i=0; i\u0026lt;3; ++i) mtx[i+12] = mtx[i+13]; mtx[15] = temp; } 列混淆层 列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。\n在加密的正向列混淆中，我们要将输入的$4·4$矩阵左乘一个给定的$4·4$矩阵。而它们之间的加法、乘法都在扩展域$GF(2^8)$中进行，,在矩阵相乘计算中，出现了加法和乘法，而前面提到了在拓展域中加法等同于异或运算，而对于乘法，需要特殊的方式进行处理，于是将+号换成^号，然后将伽罗瓦域的乘法定义成一个有两个参数的函数，并让他返回最后计算结果，最后列混淆代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //正向列变换 void MixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x02, arr[0]) ^ GFMul(0x03, arr[1]) ^ arr[2] ^ arr[3]; mtx[i+4] = arr[0] ^ GFMul(0x02, arr[1]) ^ GFMul(0x03, arr[2]) ^ arr[3]; mtx[i+8] = arr[0] ^ arr[1] ^ GFMul(0x02, arr[2]) ^ GFMul(0x03, arr[3]); mtx[i+12] = GFMul(0x03, arr[0]) ^ arr[1] ^ arr[2] ^ GFMul(0x02, arr[3]); } } 在解密的逆向列混淆中与正向列混淆的不同之处在于使用的左乘矩阵不同，它与正向列混淆的左乘矩阵互为逆矩阵，也就是说，数据矩阵同时左乘这两个矩阵后，数据矩阵不会发生任何变化。下面是图解：\n正向混淆处理：\n逆向混淆处理：\n反向列变换代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //反向列混淆 void InvMixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]); mtx[i+4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]); mtx[i+8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]); mtx[i+12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]); } } 密钥加法层 这一层主要是明文矩阵盒子密钥矩阵进行异或操作,在密钥加法层中有两个输入的参数，分别是明文和子密钥，而且这两个输入都是128位的。只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4*4], word k[4]) { for(int i=0; i\u0026lt;4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i+4] = mtx[i+4] ^ byte(k2.to_ulong()); mtx[i+8] = mtx[i+8] ^ byte(k3.to_ulong()); mtx[i+12] = mtx[i+12] ^ byte(k4.to_ulong()); } } 实现加密函数 加密函数按照流程图,首先开始是先进行一次轮密钥加,然后开始9轮的字节替换+行移位+列混淆+轮密钥加的操作,循环之后再做一次字节替换+行移位+轮密钥加就完成加密操作了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void encrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); for(int round=1; round\u0026lt;N_round; ++round) { SubBytes(in); ShiftRows(in); MixColumns(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); } SubBytes(in); ShiftRows(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); } 实现解密函数 解密函数与加密差不多,只不过将行移位变成反向行移位,列混淆变成反向列混淆,字节替换变成逆字节替换即可.\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void decrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); for(int round=N_round-1; round\u0026gt;0; --round) { InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); InvMixColumns(in); } InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); } 测试加密解密函数 可以发现上面面的测试中明文与解密之后的明文是完全正确的,说明加密函数与解密函数正确!\n测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void Aes_test() { byte key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}; byte plain[16] = {0x32, 0x88, 0x31, 0xe0, 0x43, 0x5a, 0x31, 0x37, 0xf6, 0x30, 0x98, 0x07, 0xa8, 0x8d, 0xa2, 0x34}; // 输出密钥 cout \u0026lt;\u0026lt; \u0026#34;Key is : \u0026#34;; for (int i = 0; i \u0026lt; 16; ++i) cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; key[i].to_ulong() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; word w[4 * (N_round + 1)]; KeyExpansion(key, w); // 输出待加密的明文 cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;the plaintext to encrypy:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 加密，输出密文 encrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;cipher : \u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 解密，输出明文 decrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;plain arter decrypt:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } 实现加解密文件 加密文件函数,返回加密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 string encryptFile(string oname, string suffix, word w[4 * (N_round + 1)]) { string outputfilename = oname + \u0026#34;_cipher.bin\u0026#34;; bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining encrypy...........\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); // 将文件加密到 oname + cipher.bin 中 ifstream in; ofstream out; in.open(oname + suffix, ios::binary); //输入文件 out.open(outputfilename, ios::binary); //输出加密文件 while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); encrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0 } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;encrypy finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;encrypy cost time : \u0026#34; \u0026lt;\u0026lt; (end - start) \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; //返回加密之后的文件 } 解密文件函数,返回解密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 string decryptFile(string filename, string oname, string suffix, word w[4 * (N_round + 1)]) { ifstream in; ofstream out; in.open(filename, ios::binary); string outputfilename = oname + \u0026#34;_decrypt\u0026#34; + suffix; out.open(outputfilename, ios::binary); bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining decrypt............\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); decrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0 } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;decrypt finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;decrypt cost time : \u0026#34; \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; } 实现效果:\n加密txt文件:\n加密jpg文件:\n加密mp3文件:\n加密doc文件:\nAES五种加密模式 实现五种加密方式的密钥是一个置换表unsigned char Table[4] = {0x12, 0xb1, 0x53, 0x28};,加密函数是原文与密钥的异或.\nECB模式(电子密码本模式) 加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。\nECB模式由于每块数据的加密是独立的因此加密和解密都可以并行计算，ECB模式最大的缺点是相同的明文块会被加密成相同的密文块，这种方法在某些环境下不能提供严格的数据保密性。\n流程图如下:\n实现代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //电子密码本模式,分组大小为4 unsigned char* ECB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量 //密文 unsigned char *cipher = new unsigned char[N]; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for(int j = 0;j \u0026lt; groupSize;++j) temp[j] = plain[count++]; //加密 encrypt(temp,groupSize); for(int j = i*4;j \u0026lt; i*4 + 4;++j) cipher[j] = temp[j - i * 4]; } return cipher;//返回密文 } 解密方法也是让密文与密钥进行异或即可,实现效果如下:\nCBC模式(分组链接模式) CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。\n可用公式总结为:\n$$\nC_i = E_K(P_i XOR C_{i-1}) \\\nC_{-1} = IV\n$$\n流程图如下:\nCBC模式相比ECB有更高的保密性，但由于对每个数据块的加密依赖与前一个数据块的加密所以加密无法并行。与ECB一样在加密前需要对数据进行填充，不是很适合对流数据进行加密。\n代码如下:\n加密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //CCB加密函数 unsigned char *CCB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量 //密文 unsigned char *cipher = new unsigned char[N]; //设置初始向量 unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = plain[count++]; //加密 for (int j = 0; j \u0026lt; groupSize; ++j) //先与初始向量异或 temp[i] ^= C[i]; encrypt(temp, groupSize); //加密 for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { cipher[j] = temp[j - i * 4]; C[j - i * 4] = temp[j - i * 4];//设置新向量 } } return cipher; } 解密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //CCB解密函数 unsigned char *dCCB(unsigned char *cipher, int N) { int gNum = N / groupSize; //分组数量 //明文 unsigned char *plain = new unsigned char[N]; //设置初始向量 unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = cipher[count++]; //解密 encrypt(temp, groupSize); //先解密 for (int j = 0; j \u0026lt; groupSize; ++j) //然后与初始向量异或 temp[i] ^= C[i]; for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { plain[j] = temp[j - i * 4]; C[j - i * 4] = cipher[j];//设置新向量 } } return plain; } 实现效果:\nCFB模式(密文反馈模式) 与前面的模式不同,CFB模式可以将消息被当成是比特流.可以总结为如下的公式:\n$$\nC_i = P_i XOR E_K(C_{i-1})\\\nC_{-1} = IV\n$$\n流程图如下:\n加密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //密文反馈模式,加密函数 unsigned char *CFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2 //密文 unsigned char *cipher = new unsigned char[N]; //设置初始向量 unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节 int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文,大小为2 for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密 //先对初始向量进行加密 encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或 for(int j = 0;j \u0026lt; gsize;++j){ temp[j] ^= C[j]; S[j] = temp[j]; //获取密文的2bit } //设置密文 for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移 for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; } 解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //密文反馈解密 unsigned char *dCFB(unsigned char *cipher, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2 //明文 unsigned char *plain = new unsigned char[N]; //设置初始向量 unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节 int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组密文 for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = cipher[count++]; //解密 //先对初始向量进行加密 encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或 for(int j = 0;j \u0026lt; 2;++j){ S[j] = temp[j]; temp[j] = C[j] ^ temp[j]; } //设置明文 for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { plain[j] = temp[j - i * gsize]; } //设置新向量,新向量左移 for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j+gsize] = S[j]; } } return plain; } 实现效果:\nOFB模式(输出反馈模式) OFB是先用块加密器生成密钥流（Keystream），然后再将密钥流与明文流异或得到密文流，解密是先用块加密器生成密钥流，再将密钥流与密文流异或得到明文，由于异或操作的对称性所以加密和解密的流程是完全一样的。\nOFB与CFB一样都非常适合对流数据的加密，OFB由于加密和解密都依赖与前一段数据，所以加密和解密都不能并行。\n流程图如下:\n加密解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //输出反馈模式,加密解密函数相同 unsigned char *OFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2 //密文 unsigned char *cipher = new unsigned char[N]; //设置初始向量 unsigned char C[4] = {0xee, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节 int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文 for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密 //先对初始向量进行加密 encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或 for(int j = 0;j \u0026lt; 2;++j){ S[j] = C[j]; //取向量加密后的前两位 temp[j] ^= C[j]; } //设置密文 for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移 for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; } 实现效果:\nCTR模式(计数器模式) 类型于CFB，但是加密每个计数值，而不是任何反馈值,对每个明文分组，必须有不同的密钥和计数值 (从不重复使用),,可以用如下公式表示:\n$$\nO_i = E_K(i)\\\nC_i = P_i XOR O_i\n$$\n计数器模式流程图如下:\n计数器模式加密函数与解密函数一样,代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //计数器模式,加密函数 unsigned char *CTR(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量 //密文 unsigned char *cipher = new unsigned char[N]; //设置随机值 unsigned char Counter[groupSize*groupSize] = {0x44, 0xa9, 0x5d, 0x99, 0xe5, 0xf1, 0x3d, 0x91, 0x16, 0xa6, 0xe1, 0x33, 0x22, 0xdd, 0xab, 0x1f}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; //明文分组 unsigned char C[groupSize]; //分组随机值 for (int j = 0; j \u0026lt; groupSize; ++j) { temp[j] = plain[count++]; C[j] = Counter[i*4+j]; } //加迷 //首先加密随机值C encrypt(C, groupSize); //然后与明文进行异或 for(int j = 0;j \u0026lt; groupSize;++j) temp[j] ^= C[j]; //设置密文 for(int j = i*groupSize;j \u0026lt; i*groupSize+groupSize;j++) cipher[j] = temp[j-i*groupSize]; } return cipher; } 实现效果如下:\n参考:\nhttps://www.cnblogs.com/RabbitHu/p/bitset.html bitset用法 https://blog.csdn.net/liushu1231/article/details/8844631 bitset的空间大小 http://c.biancheng.net/cpp/html/2834.html 文件处理 https://bbs.pediy.com/thread-253884.htm AES算法带图解 https://blog.csdn.net/lisonglisonglisong/article/details/41909813 AES算法 CSDN https://blog.csdn.net/sinat_23338865/article/details/72869841 AES五种加密模式 设“+”为一个交换性的二元运算，即对于所有x,y，x+y=y+x。若该集内存在一个元素0，使得对于所有x，x+0=0+x=x，则此元素是唯一的。如果对于一个给定的x，存在一个x\u0026rsquo;使得x+x\u0026rsquo;=x\u0026rsquo;+x=0，则称x\u0026rsquo;是x的加法逆元。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n乘法逆元，是指数学领域群G中任意一个元素a，都在G中有唯一的逆元a‘，具有性质a×a\u0026rsquo;=a\u0026rsquo;×a=e，其中e为该群的单位元。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":23,"section":"posts","tags":["AES","密码学"],"title":"Aes-高级加密标准","uri":"https://hugo.jiahongw.com/zh/posts/cryptography/aes/"},{"content":"使用Scrapy爬取文章的一个小项目..\nScrapy 框架图：\n抓取小程序社区文章 创建爬虫项目 创建项目（项目名为MyTest）\n1 scrapy startproject MyTest 创建爬虫🪲(先进入到MyTest目录)\n1 scrapy genspider -t crawl wx wxapp-union.com wx为爬虫的名字，wxapp-union.com为爬取的域名，使用了模板crawl\n定义爬取的数据结构 爬取的数据结构类继承Item类，在items.py文件中，如下是设置需要爬取的数据结构，其中包括:标题、作者、时间、访问者、前言、正文。\n1 2 3 4 5 6 7 8 9 10 from scrapy import Item,Field # 定义文章数据结构 class ArticleItem(Item): title = Field() author = Field() _time = Field() visitors = Field() pre_talk = Field() article_content = Field() 编写爬虫规则与解析规则 爬虫的爬取网页的链接的规则和解析页面的规则都是在新建的spider文件中的类中，也即在wx.py中\n编写的spider类如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import scrapy from scrapy.linkextractors import LinkExtractor from scrapy.spiders import CrawlSpider, Rule from MyTest.items import ArticleItem class WxSpider(CrawlSpider): name = \u0026#39;wx\u0026#39; allowed_domains = [\u0026#39;wxapp-union.com\u0026#39;] start_urls = [\u0026#39;http://www.wxapp-union.com/portal.php?mod=list\u0026amp;catid=2\u0026amp;page=255\u0026#39;] rules = ( Rule(LinkExtractor(allow=r\u0026#39;.+mod=list\u0026amp;catid=2\u0026amp;page=\\d\u0026#39;), follow=True), Rule(LinkExtractor(allow=r\u0026#39;.+article-.+\\.html\u0026#39;),callback=\u0026#34;parse_item\u0026#34;,follow=False) ) def parse_item(self, response): title = response.xpath(\u0026#39;//h1[@class=\u0026#34;ph\u0026#34;]/text()\u0026#39;).get() author = response.xpath(\u0026#39;//p[@class=\u0026#34;authors\u0026#34;]//a\u0026#39;).get() _time = response.xpath(\u0026#39;//span[@class=\u0026#34;time\u0026#34;]/text()\u0026#39;).get() visitors = response.xpath(\u0026#39;//div[contains(@class,\u0026#34;focus_num\u0026#34;)]//a/text()\u0026#39;).get() pre_talk = response.xpath(\u0026#39;//div[@class=\u0026#34;blockquote\u0026#34;]//p/text()\u0026#39;).get() article_content = response.xpath(\u0026#39;//td[@id=\u0026#34;article_content\u0026#34;]\u0026#39;).get() item = ArticleItem(title=title,author=author,_time=_time,visitors=visitors,pre_talk=pre_talk,article_content=article_content) print(\u0026#39;*\u0026#39;*40) print(title) print(\u0026#39;*\u0026#39;*40) return item 首先rules定义了爬取链接规则，有两个规则，第一个规则是爬取页面的链接，每一页有多个文章的链接，而第二个规则则是定义爬取的具体文章内容的链接。 第一个规则需要Follow，因为需要根据每一页的内容查找文章的链接；而第二个规则是文章链接，故不需要继续Follow 第一个页面链接规则不需要回调函数，因为不需要解析，只需要获取文章链接；第二个文章链接规则则需要设置回调函数来对返回的文章网页内容进行解析。 parse_item说明：\nparse_item是解析页面返回内容的函数，其返回Item数据结构，使用Xpath分别获取数据结构各个元素的内容并且返回Item\n保存数据 pipelines是一个最后处理Item的管道\n在pipelines.py文件中新建pipleline对返回的Item进行处理，可以保存为文件，或者存储到数据库。\n首先文件中需要导入必要的库‘\n1 2 3 4 5 import re\t# 正则处理 from html2text import HTML2Text\t# 将网页转化为Markdown格式 from scrapy.exporters import JsonLinesItemExporter\t# 输出Json文件输出器 from urllib.parse import urljoin\t# 补全URL，因为有些URL只显示相对位置 import pymongo\t# MongoDB操作库 第一个Pipeline：保存到Json文件 程序的构造函数新建一个Json文件输出器，process_item进行数据的存储，关闭的时候close_spider会调用关闭文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 存储到Json文件中 class JsonPipeline(object): def __init__(self): self.f = open(\u0026#39;wxjc.json\u0026#39;,\u0026#39;wb\u0026#39;) self.exporter = JsonLinesItemExporter(self.f, ensure_ascii=False,encoding=\u0026#34;utf-8\u0026#34;) def process_item(self, item, spider): # 将内容转化为MarkDown格式 item[\u0026#39;article_content\u0026#39;] = convert_md(item[\u0026#39;article_content\u0026#39;]) self.exporter.export_item(item) return item def close_spider(self,spider): self.f.close() 第二个Pipeline：保存到Markdown文件 方法与第一发Pipeline类似，只是写文件使用最简单的追加方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 写入Markdown class MDPipeline(object): def __init__(self): self.f = open(\u0026#39;wx_teaches.md\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) def process_item(self,item,spider): if self.f: self.f.write(\u0026#39;\\n\u0026#39;) self.f.write(\u0026#34;# \u0026#34; + item[\u0026#39;title\u0026#39;] + \u0026#39;\\n\u0026#39;) header_info = \u0026#34;作者:{} 发布时间:{} Visitors:{}\\n\u0026#34;.format(item[\u0026#39;author\u0026#39;],item[\u0026#39;_time\u0026#39;],item[\u0026#39;visitors\u0026#39;]) self.f.write(header_info) self.f.write(\u0026#39;\u0026gt; \u0026#39; + item[\u0026#39;pre_talk\u0026#39;] + \u0026#39;\\n\u0026#39;) self.f.write(item[\u0026#39;article_content\u0026#39;]) return item def close_spider(self,spider): self.f.close() 第三个Pileline：保存到MongoDB 其中使用了类方法装饰器@classmethod,意思就是直接用类名调用该函数，就能够直接返回一个MongoPipeline类了，还定义了打开spider与关闭spider的操作，就是连接数据库与关闭数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 存储到MongoDB数据库 class MongoPipeline(object): def __init__(self,mongo_uri,mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls,crawler): return cls(mongo_uri = crawler.settings.get(\u0026#39;MONGO_URI\u0026#39;), mongo_db = crawler.settings.get(\u0026#39;MONGO_DB\u0026#39;)) def open_spider(self,spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db =self.client[self.mongo_db] def process_item(self,item,spider): name = item.__class__.__name__ # \u0026lt;a href=\\\u0026#34;space-uid-17761.html\\\u0026#34;\u0026gt;Rolan\u0026lt;/a\u0026gt; item[\u0026#39;author\u0026#39;] = re.search(\u0026#39;\u0026lt;a.*?\u0026gt;(.*?)\u0026lt;/a\u0026gt;\u0026#39;,item[\u0026#39;author\u0026#39;]).group(1) self.db[name].insert(dict(item)) return item def close_spider(self,spider): self.client.close() 最后需要在settings.py中添加如下字段:\n1 2 MONGO_URI = \u0026#39;localhost\u0026#39; MONGO_DB = \u0026#39;WX\u0026#39; 最后需要在settings.py中添加如下字段 1 2 3 4 5 6 7 8 9 ITEM_PIPELINES = { \u0026#39;MyTest.pipelines.JsonPipeline\u0026#39;: 300, \u0026#39;MyTest.pipelines.MDPipeline\u0026#39;: 301, \u0026#39;MyTest.pipelines.MongoPipeline\u0026#39;: 400, } # 修改为False ROBOTSTXT_OBEY = False # 设置延迟1s DOWNLOAD_DELAY = 1 开始爬取 可以在项目目录中新建一个脚本start.py，文件内容如下，自动运行脚本\n1 2 from scrapy import cmdline cmdline.execute(\u0026#39;scrapy crawl test\u0026#39;.split(\u0026#39; \u0026#39;)) 爬取结果 Json结果 Markdown结果 Markdown文件由于太大了使用Markdown文件打不开，只好使用文本编辑器打开\nMongoDB结果 ","description":"","id":24,"section":"posts","tags":["爬虫","scrapy"],"title":"使用Scrapy框架编写爬虫","uri":"https://hugo.jiahongw.com/zh/posts/dev/scrapy-exercise/"},{"content":" HUGO + Github + Github Action 持续集成部署个人博客\n安装 HUGO 本地环境 首先在 HUGO 的官网下载Hugo的 Windows 安装包，然后将路径添加到环境变量即可。\nstep1:下载 hugo\nstep2:配置环境变量\n其他系统安装 HUGO 的方法：\nMac：brew install hugo HUGO 站点配置及主题配置 创建站点 在目录下直接输入下面的代码即可创建一个名为 blog 的 hugo 站点(注意：新建的站点是没有自带主题的)\n1 hugo new site blog 或者进入 blog 文件夹内直接输入以下语句：\n1 hugo new site . 下载主题 可以在hugo theme下载主题，然后根据主题的文档进行配置\n放到站点文件夹 themes 内，配置 config.toml\n本地测试运行 输入hugo server测试\nGithub 配置 创建站点仓库并且设置 GithubPage 可以在 Setting 中看见如下：\n创建另一个存储项目的仓库 创建另一个存储项目的仓库，存储写的博客文章\n配置 Github Action 首先在项目仓库点击 action，选择Simple workflow，输入一下的配置代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 name: HUGO_CI #自动化的名称 on: push: # push的时候触发 branches: # 那些分支需要触发 - master jobs: build: runs-on: ubuntu-latest # 镜像市场 steps: - name: checkout # 步骤的名称 uses: actions/checkout@v3 #软件市场的名称 with: # 参数 submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2.2.2 with: hugo-version: \u0026#39;0.64.1\u0026#39; # 设置HUGO框架的版本 extended: true # 是否选择拓展版HUGO框架，选择是 - name: Build run: hugo -D - name: Deploy uses: peaceiris/actions-gh-pages@v2.5.1 env: ACTIONS_DEPLOY_KEY: ${{ secrets.ACTIONS_DEPLOY_KEY }} EXTERNAL_REPOSITORY: redisread/redisread.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public 准备部署，我们开发的项目及github pages实际是分开的，一个用于保存项目，相当于源代码，另外一个用于保存最终的网页文件。\n使用 git 生成 ssh key(相当于生成对密钥)\n1 2 3 4 ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) 假设 开发项目为 HUGO_blog 部署的项目为 redisread.github.io\n打开HUGO_blog仓库的 settings，再点击Secrets，然后添加刚刚生成的私钥，name 为ACTIONS_DEPLOY_KEY\n同理，打开redisread.github.io，点击Deploy keys，添加公钥，Allow write access一定要勾上，否则会无法提交\n然后，你就可以提交代码了，push 成功后，打开仓库actions，至此部署成功，大功告成！\n后续可以自己写文章然后 push 了，github action会自动帮你部署。\n","description":"Guide to set Hugo site.","id":26,"section":"posts","tags":["hugo","github"],"title":"部署HUGO博客","uri":"https://hugo.jiahongw.com/zh/posts/hugo/hugo_setup/"},{"content":"我是一个不够严谨的程序员🙉.\n我喜欢📖,还有🏓.\n或许有时候我想的不够远，但是有时候我想的很深入。\n我最喜欢的 Aaron Swartz 语录:\n在长大的过程中，我才慢慢发现，我身边的所有事，别人跟我说的所有事，那些所谓本来如此，注定如此的事，它们其实没有非得如此，事情是可以改变的。更重要的是，有些事既然错了，那就该做出改变。\n我对学校十分失望，我觉得老师们根本不懂自己所讲的是什么，他们居高临下，管这管那；作业就像是种把戏，就好像知识一种强制所有学生一起庸庸碌碌的手段。于是我就开始去阅读那些关于教育史和这套教育体系演变的书籍。然后你就能发现，如果要真正学到东西，那就不能机械重复老师所教的，这有点儿使得我渐渐学会了质疑。我质疑我所上的学校，我质疑简历这所学校的这个社会，我质疑学校教人们追求的那套事理，我质疑建立起这整个体系的政府。\n我总是深入思考，我希望别人也能想远一点。我为理想而工作，并从别人身上学习，我不喜欢拒人于外。我是个完美主义者，但我不会要求出版界也精益求精。除了教育和娱乐以外，我不会浪费时间在那些不会有影响的事情上。我试着和每个人都友好相处，但我讨厌人们不认真对待我。我不记恨他人，因为这于创造无益。但我从自身经历中学习，我想让世界变得更美好。\n我深深地觉得，光安生与当下这世界是不够的，那样子知识别人给什么你就照收，大人们说什么你就照做，你照着父母说的去做，照着社会说的去做。我觉得你应该总持有质疑，我觉得从科学的角度看，你所学的一切都知识暂时性的，任何所学都有改口、驳斥、质疑的余地。我觉得这情况对社会也适用。当我意识到社会上有着我能尽份力去解决的真正严重的、基础性的问题时，我没法去遗忘它、回避它。\n","description":"Zzo about page","id":27,"section":"","tags":null,"title":"About","uri":"https://hugo.jiahongw.com/zh/about/"},{"content":"盒子 支持 Markdown 语法的盒子 语法：\n或者：\n1 \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;This is \u0026lt;strong\u0026gt;boxmd\u0026lt;/strong\u0026gt; shortcode\u0026lt;/div\u0026gt; 渲染显示：\nThis is boxmd shortcode 简单盒子 语法：\n渲染显示：\nThis is **box** shortcode 代码选项卡 可以在不同的代码块之间切换，语法：\n渲染显示：\njava javascript 1 System.out.println(\u0026#39;Hello World!\u0026#39;); 1 console.log(\u0026#39;Hello World!\u0026#39;); 常规选项卡 这个和代码选项卡类似，不同的是，这种选项卡更加“常规”。语法：\n渲染显示：\nWindows MacOS Ubuntu Windows section 1 console.log(\u0026#39;Hello World!\u0026#39;); ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\nMacOS section Hello world! Ubuntu section Great! 展开栏 语法：\n渲染显示：\nExpand me Title contents Expand me2 Title2 contents2 彩色文本框 语法：\n渲染显示：\nthis is a text this is a text this is a text this is a text 彩色注意框 语法：\n渲染显示：\nsuccess text info text warning text error text 图片描述 使用语法：\n渲染显示：\nSample Image: Image with title, caption, alt, ... 按钮 语法：\n简单按钮：\nbutton 设置宽度高度：\nbutton 设置颜色：\nbutton ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":28,"section":"posts","tags":["shortcode","zzo","博客搭建"],"title":"Shortcodes使用参考","uri":"https://hugo.jiahongw.com/zh/posts/hugo/shortcodes/"},{"content":"A Short Video： ——以下 Aaron Swartz的宣言，我想这才是信息革命的真谛——\n信息就是力量。但就像所有力量一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 Reed Elsevier 这样的出版商大把钱。\n有人努力去改变这种状况。开放访问运动 (Open Access Movement) 奋勇斗争，确保科学家们没有将他们的版权签署给别人，而是将他们的成果发布到网络上，允许任何人访问它们。但即便是最好的情况，他们的行为也只作用于未来发布的东西。之前的都将失去。\n这样的代价实在太高。强制学者付钱以阅读他们同行的成果？扫描整个图书馆却只允许 Google 的人阅读它们？提供科学文章给那些第一世界的精英大学，却不给身在南半球的儿童？这实在蛮横且无法接受。\n“我同意，”有些人就说了，“但是我们能做什么呢？那些公司握有版权，他们靠限制访问赚取大把的钱，而且这是完全合法的 - 我们没有办法阻止他们。”但有些事我们能做，这些事我们已经在做：我们可以反击。\n那些能够访问这些资源的人 - 学生，图书管理员，科学家 - 你们被赋予了特权。你们能享受到这知识的盛宴，而其他人却被排除在外。但是你们不必 - 事实上，从道义层面来说，你们不能 - 为保留自己保留这份特权。你们有义务和全世界分享它。而且你们已经在做了：和同行们交换密码，回应朋友们的下载请求。\n同时，那些被拒之门外的人们并没有袖手旁观。你们溜过洞穴，翻越围墙，解放那些被出版商封锁的信息并分享给你的朋友们。\n但所有这些行动都是在黑暗中进行，隐藏于地底。它们被称作偷窃或盗版，仿佛分享大量的知识精神上等同于抢劫一艘船只并谋杀其船员。但是分享绝非不道德的，它是一种道德使命。只有那些利欲熏心的人才会拒绝让朋友复制一份。\n大公司，当然，就是利欲熏心。使它们运转的法律要求使然 - 稍微出点事投资人就得叛乱。它们收买的政治家们支持它们，通过法案让它们拥有专属的权力决定谁可以复制。\n遵从不公正的法律不会带来公正。步入光明的时候到了，在公民不服从的伟大传统下，宣告我们对这种私人盗窃公共文化的反抗。\n我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。\n只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？\n亚伦·斯沃茨 (Aaron Swartz)\n2008 年 7 月，意大利 Eremo\nInformation is power. But like all power, there are those who want to keep it for themselves. The world\u0026rsquo;s entire scientific and cultural heritage, published over centuries in books and journals, is increasingly being digitized and locked up by a handful of private corporations. Want to read the papers featuring the most famous results of the sciences? You\u0026rsquo;ll need to send enormous amounts to\npublishers like Reed Elsevier.\nThere are those struggling to change this. The Open Access Movement has fought valiantly to ensure that scientists do not sign their copyrights away but instead ensure their work is published on the Internet, under terms that allow anyone to access it. But even under the best scenarios, their work will only apply to things published in the future. Everything up until now will have been lost.\nThat is too high a price to pay. Forcing academics to pay money to read the work of their colleagues? Scanning entire libraries but only allowing the folks at Google to read them? Providing scientific articles to those at elite universities in the First World, but not to children in the Global South? It\u0026rsquo;s outrageous and unacceptable.\n\u0026ldquo;I agree,\u0026rdquo; many say, \u0026ldquo;but what can we do? The companies hold the copyrights, they make enormous amounts of money by charging for access, and it\u0026rsquo;s perfectly legal - there\u0026rsquo;s nothing we can do to stop them.\u0026rdquo; But there is something we can, something that\u0026rsquo;s already being done: we can fight back.\nThose with access to these resources - students, librarians, scientists - you have been given a privilege. You get to feed at this banquet of knowledge while the rest of the world is locked out. But you need not - indeed, morally, you cannot - keep this privilege for yourselves. You have a duty to share it with the world. And you have: trading passwords with colleagues, filling download requests for friends.\nMeanwhile, those who have been locked out are not standing idly by. You have been sneaking through holes and climbing over fences, liberating the information locked up by the publishers and sharing them with your friends.\nBut all of this action goes on in the dark, hidden underground. It\u0026rsquo;s called stealing or piracy, as if sharing a wealth of knowledge were the moral equivalent of plundering a ship and murdering its crew. But sharing isn\u0026rsquo;t immoral - it\u0026rsquo;s a moral imperative. Only those blinded by greed would refuse to let a friend make a copy.\nLarge corporations, of course, are blinded by greed. The laws under which they operate require it - their shareholders would revolt at anything less. And the politicians they have bought off back them, passing laws giving them the exclusive power to decide who can make copies.\nThere is no justice in following unjust laws. It\u0026rsquo;s time to come into the light and, in the grand tradition of civil disobedience, declare our opposition to this private theft of public culture.\nWe need to take information, wherever it is stored, make our copies and share them with the world. We need to take stuff that\u0026rsquo;s out of copyright and add it to the archive. We need to buy secret databases and put them on the Web. We need to download scientific journals and upload them to file sharing networks. We need\nto fight for Guerilla Open Access.\nWith enough of us, around the world, we\u0026rsquo;ll not just send a strong message opposing the privatization of knowledge - we\u0026rsquo;ll make it a thing of the past.\nWill you join us?\nAaron Swartz\nJuly 2008, Eremo, Italy\n","description":"","id":29,"section":"talks","tags":[null],"title":"互联网之子的故事","uri":"https://hugo.jiahongw.com/zh/talks/aaron-swartz-story/"},{"content":"关于生活的点点滴滴\u0026hellip;\u0026hellip;\n","description":"记录生活","id":31,"section":"gallery","tags":[null],"title":"生活相册","uri":"https://hugo.jiahongw.com/zh/gallery/life/"},{"content":"between 70 and 240 in movies\ngood movies！🎥\n","description":"记录电影精彩瞬间","id":32,"section":"gallery","tags":[null],"title":"影视相册","uri":"https://hugo.jiahongw.com/zh/gallery/movie/"}]