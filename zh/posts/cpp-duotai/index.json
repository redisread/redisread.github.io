[{"content":"地址：http://markdown.xiaoshujiang.com/\nThis is a Test!\n","description":"","id":0,"section":"posts","tags":["小书匠"],"title":"使用小书匠在线编写博文","uri":"https://vhope.cf/zh/posts/hugo/xiaoshujiang/"},{"content":"在UE4中获取深度缓存，调用渲染命令读取。\n获取深度缓存 深度像素格式 键入命令vis scenedepthz uv0以查看实际使用的深度缓冲区。UE4对场景使用“反向”深度缓冲区。\nWay1：直接使用ENQUEUE_RENDER_COMMAND命令获取(效率较低) 在任意tick函数或者其他函数添加以下的命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  struct DepthPixel\t//定义深度像素结构体 \t{ float depth; char stencil; char unused1; char unused2; char unused3; }; float* cpuDataPtr;\t// Texture深度值数组首地址 \tTArray\u0026lt;DepthPixel\u0026gt; mydata;\t//最终获取色深度值数据 \tFIntPoint buffsize;\t//深度长宽大小X和Y  ENQUEUE_RENDER_COMMAND(ReadSurfaceFloatCommand)(\t// 将读取深度数据的命令推给渲染线程进行执行 \t[\u0026amp;cpuDataPtr, \u0026amp;mydata, \u0026amp;buffsize](FRHICommandListImmediate\u0026amp; RHICmdList) //\u0026amp;cpuDataPtr, \u0026amp;mydata, \u0026amp;buffsize为传入的外部参数 \t{ FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, 1); FTexture2DRHIRef uTex2DRes = FSceneRenderTargets::Get(RHICmdList).GetSceneDepthSurface();\tbuffsize = uTex2DRes-\u0026gt;GetSizeXY(); uint32 sx = buffsize.X; uint32 sy = buffsize.Y; mydata.AddUninitialized(sx * sy); uint32 Lolstrid = 0; cpuDataPtr = (float*)RHILockTexture2D(uTex2DRes,0,RLM_ReadOnly,Lolstrid,true);\t// 加锁 获取可读depth Texture深度值数组首地址 \tmemcpy(mydata.GetData(), cpuDataPtr, sx * sy * sizeof(DepthPixel));\t//复制深度数据 \tRHIUnlockTexture2D(uTex2DRes, 0, true);\t//解锁 \tFSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, -1);\t}); FlushRenderingCommands();\t//等待渲染线程执行  mydata; //最终获取深度数据   最终返回的mydata数据就是最终的深度值数组，其中每个深度值的结构是DepthPixel，其中一个成员为depth，另外四个不不使用。其中使用上面的几个命令需要添加\u0026quot;RHI.h\u0026quot;头文件\nWay2：写个请求类读取 UML图：\n流程图：\n1. 首先在项目的build.cs文件添加： 添加引擎源码地址\n1 2 3 4 5 6 7 8 9 10  // 添加引擎源码地址  string EnginePath = \u0026#34;C:/Program Files (x86)/UE4+VS2017/UnrealEngine/\u0026#34;; PrivateIncludePaths.AddRange( new string[] { EnginePath + \u0026#34;Source/Runtime/Renderer/Private\u0026#34;, EnginePath + \u0026#34;Source/Runtime/Renderer/Private/CompositionLighting\u0026#34;, EnginePath + \u0026#34;Source/Runtime/Renderer/Private/PostProcess\u0026#34; } );   添加引依赖项\n2. 类实现 将下面类代码复制到PostProcessing.h文件任意位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  /*****************************************Get Depth Class*******************************************************/ /*\t存储一个像素的缓存 depth 深度缓存 stencil （抠图缓存）*/ struct DepthPixel { float depth; char stencil; char unused1; char unused2; char unused3; }; /*\t存储整个视窗的缓存 data\t像素缓存数组 bufferSizeX\t缓存大小X bufferSizeY\t缓存大小Y pixelSizeBytes\t像素缓存字节数*/ struct DepthResult { TArray\u0026lt;DepthPixel\u0026gt; data; int bufferSizeX; int bufferSizeY; int pixelSizeBytes; }; /*\t获取深度缓存的类\t*/ class RENDERER_API DepthCapture { public: /*\t静态成员，当用户发出一个获取深度缓存的请求后，waitForCapture长度加1，新增DepthResult内容为空 当系统完成一个深度缓存的请求后，waitForCapture长度减一 */ static TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; waitForCapture; /*\t静态成员，当系统完成一个深度缓存的请求后，finishedCapture长度加1， 新增DepthResult含有深度缓存信息\t*/ static TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; finishedCapture; public: /*用户发出一个获取深度缓存的请求时调用*/ static void AddCapture() { waitForCapture.Enqueue(new DepthResult()); } /*系统完成一个深度缓存请求后调用*/ static void FinishedCapture(DepthResult *result) { finishedCapture.Enqueue(result); } /*返回是否存在已经完成的请求*/ static bool HasFinishedCapture() { return !finishedCapture.IsEmpty(); } /*如果存在已完成的请求，返回一个深度结果*/ static DepthResult* GetIfExistFinished() { DepthResult* result = NULL; if (!finishedCapture.IsEmpty()) { finishedCapture.Dequeue(result); } return result; } /*返回是否存在等待系统执行的请求*/ static bool HasCaptureRequest() { return !waitForCapture.IsEmpty(); } /*如果存在待完成的请求，返回一个深度结果（为空）*/ static DepthResult* GetIfExistRequest() { DepthResult* result = NULL; if (!waitForCapture.IsEmpty()) { waitForCapture.Dequeue(result); } return result; } //friend void AddPostProcessingPasses(FRDGBuilder\u0026amp; GraphBuilder, const FViewInfo\u0026amp; View, const FPostProcessingInputs\u0026amp; Inputs); }; /*****************************************end******************************************************/   将下面类中静态成员初始化和添加执行获取代码代码复制到PostProcessing.cpp文件任意位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  /*类静态成员的定义*/ TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; DepthCapture::waitForCapture; TQueue\u0026lt; DepthResult *, EQueueMode::Mpsc\u0026gt; DepthCapture::finishedCapture; /*获取深度缓存*/ void AddDepthInspectorPass(FRDGBuilder\u0026amp; GraphBuilder, const FViewInfo\u0026amp; View, DepthResult* result) { RDG_EVENT_SCOPE(GraphBuilder, \u0026#34;DepthInspector\u0026#34;); { // 获取渲染对象 \tFSceneRenderTargets\u0026amp; renderTargets = FSceneRenderTargets::Get(GRHICommandList.GetImmediateCommandList()); // 定义拷贝参数 \tuint32 striped = 0; FIntPoint size = renderTargets.GetBufferSizeXY(); result-\u0026gt;bufferSizeX = size.X; result-\u0026gt;bufferSizeY = size.Y; result-\u0026gt;data.AddUninitialized(size.X * size.Y); // 获取视窗某一帧的深度缓存对象 \tFRHITexture2D* depthTexture = (FRHITexture2D *)renderTargets.SceneDepthZ-\u0026gt;GetRenderTargetItem().TargetableTexture.GetReference(); // 执行拷贝深度缓存操作，将GPU显存中的缓存信息拷贝到CPU内存中，返回指向这块CPU内存的首地址 \tvoid* buffer = RHILockTexture2D(depthTexture, 0, EResourceLockMode::RLM_ReadOnly, striped, true); // 将缓存结果拷贝到result，用于输出 \tmemcpy(result-\u0026gt;data.GetData(), buffer, size.X * size.Y * 8); // 必须执行解锁语句，否则被锁住的GPU缓存信息将不能释放 \tRHIUnlockTexture2D(depthTexture, 0, true); // 拷贝结果入队 \tDepthCapture::FinishedCapture(result); } } ////////////////////////////////////////   PostProcessing.cpp中该位置添加以下代码：\n代码如下：\n1 2 3 4 5 6 7 8 9 10  // Capture depth buffer，otherwise the buffer will be changed \tif (DepthCapture::HasCaptureRequest()) { DepthResult *reuslt; reuslt = DepthCapture::GetIfExistRequest(); if (reuslt) { AddDepthInspectorPass(GraphBuilder, View, reuslt); } }   3. 调用 使用以下的代码可以获取深度值，获取的结果为result：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int tickcount = 0; // Called every frame void ATestPawn::Tick(float DeltaTime) { tickcount++; if (tickcount % 2 == 0)\t// 设计几帧调用  DepthCapture::AddCapture(); // 定时发出获取深度缓存的请求  // 如果存在已完成的深度缓存请求  if (DepthCapture::HasFinishedCapture()) { DepthResult *result; // 获取已完成的深度缓存结果  result = DepthCapture::GetIfExistFinished(); if (result) { int n = result-\u0026gt;data.Num(); //this is test  GEngine-\u0026gt;AddOnScreenDebugMessage(-1, -1, FColor::Blue, FString::Printf(TEXT(\u0026#34;Get Depth Size: %d \u0026#34;), n)); } } }   ","description":"","id":1,"section":"posts","tags":["C++","UE4","Game"],"title":"UE4获取深度值","uri":"https://vhope.cf/zh/posts/ue/ue-depth/"},{"content":"我太菜了\u0026hellip;😭\n这是第一次面试，电话面试，一上来面试官首先叫我自我介绍，我介绍的很简单，粗略的介绍了自己就这样。\n然后开始是有点紧张，并且答题有点急。其次，我的基础还不是很牢固。一面主要面试的方向在C++、操作系统以及计算机网络。\n腾讯QQ后台一面 C++   static有什么用？\n我就只会回答了static怎么使用的，什么在函数里面使用啊，在类里面的定义的话，全部类对象对共享一个静态变量等等，但是没有说出它的作用。\n（面向对象的）静态成员变量\n  如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。\n也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：\n 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。    同全局变量相比，使用静态数据成员有两个优势：\n 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。    （面向对象的）静态成员函数\n与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。\n（面向过程的）静态全局变量\n 该变量在全局数据区分配内存； 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）； 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；  静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。  定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：\n 静态全局变量不能被其它文件所用； 其它文件中可以定义相同名字的变量，不会发生冲突；  （面向过程的）静态局部变量\n但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。\n静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。\n（面向过程的）静态函数\n在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。\n参考答案：https://zhuanlan.zhihu.com/p/37439983\n  多态怎么实现的？\n我回答了虚函数表以及虚函数指针这些，但是面试官居然问我虚函数表存放在哪里。啊，这个我之前看过，但是忘了🔮!!\n参考答案：C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现\n  了解程序的存储区吗？\n就知道堆栈、BSS区，文本去，其他不记得了。。。\n参考答案：C/C++程序的5种内存存储区及示意\n  操系统   进程间的通信方式\n我回答了：管道、信号量、共享内存、消息队列\n  共享内存是怎么实现的，具体内容\n我懵了，我也不太熟悉。。\n  计算机网络   http的状态码\n就回答了3开头的是重定向之类的码，4开头的是找不带的状态码，5开头的是服务器错误的状态码。😅\n参考答案：\nhttps://www.runoob.com/http/http-status-codes.html\n   分类 分类描述     1 信息，服务器收到请求，需要请求者继续执行操作   2 成功，操作被成功接收并处理   3 重定向，需要进一步的操作以完成请求   4 客户端错误，请求包含语法错误或无法完成请求   5 服务器错误，服务器在处理请求的过程中发生了错误      https的过程，证书有什么用?\n这一块答得不太好\u0026hellip;\u0026hellip;\n  TCP三次握手\n这个我说出来了，比较简单\n  客户端UDP传输1000个字节给缓冲区只有500个字节的服务器\u0026hellip;\u0026hellip;.\n这个题目的意思我都不是很理解，直接跳过了，我也只记得这么多了，总之是UDP传输的相关问题，到时候补补。\n  算法相关   5亿个数据中有许多重复的数据，其中查找只出现一次的数据\n我一开始乱说一通，说用什么集合，保存遇到相同的就将数据拿出来，没想到他说的数据重复次数不只是2，然后赶紧说使用哈希表映射来进行查找，查找速度虽然快，但是消耗的空间较大。\n然后他又问假如空间不够呢，一如既往的剧情，我跟他说位图来解决，不过这个位图使用的是两个bit，用来保存三种状态：不存在的、只存在1个和存在多个的。\n  说说你知道的排序算法\n我说了好几个，冒泡和选择就不说了，说了：插入排序、快速排序、堆排序、归并排序、桶排序、基数排序、计数排序。\n他问什么排序算法最好，我跟他说要看具体的数据规模，在数据基本有序的情况下插入排序比较好，无序使用快速排序，数据在一定范围的话可以使用计数排序。\n ","description":"","id":2,"section":"posts","tags":["C++","面试"],"title":"QQ后台一面","uri":"https://vhope.cf/zh/posts/interview/qq-interview1/"},{"content":"探索UE4游戏线程的进入\n游戏线程 \u0026amp; 渲染线程 UE4游戏线程启动 游戏线程每一帧更新所有内容。\n这个tick是哪里打开的？\n头文件：Engine\\Source\\Runtime\\Launch\\Private\\Launch.cpp\nLauch.cpp定义了一个全局的变量FEngineLoop GEngineLoop;\n该类路径：Engine\\Source\\Runtime\\Launch\\Public\\LaunchEngineLoop.h，继承一个接口类IEngineLoop，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145  /** * Implements the main engine loop.\t*/ class FEngineLoop #if WITH_ENGINE\t: public IEngineLoop #endif{ public: /** Default constructor. */ FEngineLoop(); virtual ~FEngineLoop() { } public: /** * Pre-Initialize the main loop, and generates the commandline from standard ArgC/ArgV from main(). * * @param ArgC The number of strings in ArgV. * @param ArgV The command line parameters (ArgV[0] is expected to be the executable name). * @param AdditionalCommandLine Optional string to append to the command line (after ArgV is put together). * @return Returns the error level, 0 if successful and \u0026gt; 0 if there were errors. */ int32 PreInit(int32 ArgC, TCHAR* ArgV[], const TCHAR* AdditionalCommandline = nullptr); /** * Pre-Initialize the main loop - parse command line, sets up GIsEditor, etc. * * @param CmdLine The command line. * @return The error level; 0 if successful, \u0026gt; 0 if there were errors. */ int32 PreInit(const TCHAR* CmdLine); /** First part of PreInit. */ int32 PreInitPreStartupScreen(const TCHAR* CmdLine); /** Second part of PreInit. */ int32 PreInitPostStartupScreen(const TCHAR* CmdLine); /** Load all modules needed before Init. */ void LoadPreInitModules(); /** Load core modules. */ bool LoadCoreModules(); /** Clean up PreInit context. */ void CleanupPreInitContext(); #if WITH_ENGINE\t/** Load all core modules needed at startup time. */ bool LoadStartupCoreModules(); /** Load all modules needed at startup time. */ bool LoadStartupModules(); /** * Initialize the main loop (the rest of the initialization). * * @return The error level; 0 if successful, \u0026gt; 0 if there were errors. */ virtual int32 Init() override; /** Initialize the timing options from the command line. */ void InitTime(); /** Performs shut down. */ void Exit(); /** Whether the engine should operate in an idle mode that uses no CPU or GPU time. */ bool ShouldUseIdleMode() const; // Advances the main loop.推进主循环 \tvirtual void Tick() override; /** Removes references to any objects pending cleanup by deleting them. */ virtual void ClearPendingCleanupObjects() override; #endif // WITH_ENGINE  /** RHI post-init initialization */ static void PostInitRHI(); /** Pre-init HMD device (if necessary). */ static void PreInitHMDDevice(); public: /** Initializes the application. */ static bool AppInit(); /** * Prepares the application for shutdown. * * This function is called from within guarded exit code, only during non-error exits. */ static void AppPreExit(); /** * Shuts down the application. * * This function called outside guarded exit code, during all exits (including error exits). */ static void AppExit(); private: /** Utility function that processes Slate operations. */ void ProcessLocalPlayerSlateOperations() const; protected: /** Holds a dynamically expanding array of frame times in milliseconds (if FApp::IsBenchmarking() is set). */ TArray\u0026lt;float\u0026gt; FrameTimes; /** Holds the total time spent ticking engine. */ double TotalTickTime; /** Holds the maximum number of seconds engine should be ticked. */ double MaxTickTime; /** Holds the maximum number of frames to render in benchmarking mode. */ uint64 MaxFrameCounter; /** Holds the number of cycles in the last frame. */ uint32 LastFrameCycles; #if WITH_ENGINE /** Holds the objects which need to be cleaned up when the rendering thread finishes the previous frame. */ FPendingCleanupObjects* PendingCleanupObjects; #endif //WITH_ENGINE  private: #if WITH_ENGINE /** Holds the engine service. */ FEngineService* EngineService; /** Holds the application session service. */ TSharedPtr\u0026lt;ISessionService\u0026gt; SessionService; #endif // WITH_ENGINE \tFPreInitContext PreInitContext; };    该文件只需#include \u0026quot;CoreMinimal.h\u0026quot;，最多加上#include \u0026quot;UnrealEngine.h\u0026quot;\n 接口类，位于路径Engine\\Source\\Runtime\\Engine\\Public\\UnrealEngine.h：\n1 2 3 4 5 6 7 8 9  /** Public interface to FEngineLoop so we can call it from editor or editor code */ class IEngineLoop { public: virtual int32 Init() = 0; virtual void Tick() = 0; /** Removes references to any objects pending cleanup by deleting them. */ virtual void ClearPendingCleanupObjects() = 0; };   开启Tick函数之前需要初始化，初始化函数在Launch.cpp这个文件中：\n1 2 3 4 5 6  /* Inits the engine loop */ int32 EngineInit() { int32 ErrorLevel = GEngineLoop.Init(); return( ErrorLevel ); }   GEngineLoop.Init()函数：\n其中会判断是进入那种引擎模式，分为Game模式与Editor模式。\n结束引擎的函数为：\n1 2 3 4 5 6 7 8 9 10  /** * Shuts down the engine */ void EngineExit( void ) { // Make sure this is set \tRequestEngineExit(TEXT(\u0026#34;EngineExit() was called\u0026#34;)); GEngineLoop.Exit(); }   也在Launch.cpp\nLaunch.cpp中的函数多次使用GEngine这个外部变量，这个变量在上面的初始化函数会自定设置为相应的引擎，即Game引擎或者Editor引擎：\n 所在文件Engine.h\n 在FEngineLoop::Tick()函数会调用GEngine的Tick函数：\n也就是本文开始的那个Tick函数。\n","description":"","id":3,"section":"posts","tags":["C++","UE4","Game"],"title":"UE游戏、渲染线程","uri":"https://vhope.cf/zh/posts/ue/ue-game-render/"},{"content":"==通常的游戏引擎中游戏线程和渲染线程都是独立的，相互之间会存在一个同步的机制==\nKeyWord: UMG 虚幻示意图形界面设计器（Unreal Motion Graphics UI Designer）(UMG) 是一个可视化的UI创作工具，可以用来创建UI元素，如游戏中的HUD、菜单或您希望呈现给用户的其他界面相关图形。UMG的核心是控件，这些控件是一系列预先制作的函数，可用于构建界面（如按钮、复选框、滑块、进度条等）。这些控件在专门的控件蓝图中编辑，该蓝图使用两个选项卡进行构造：设计器（Designer）选项卡允许界面和基本函数的可视化布局，而图表（Graph）选项卡提供所使用控件背后的功能。\nSlate Slate 是完全自定义、与平台无关的用户界面框架，旨在让工具和应用程序（比如虚幻编辑器）的用户界面或游戏中用户界面的构建过程变得有趣、高效。它将声明性语法与轻松设计、布局和风格组件的功能相结合，允许在UI上轻松实现创建和迭代。\nSlate UI解决方案使得为工具和应用程序组合图形用户界面和快速迭代这些界面变得极其简单。\nRHICmdList 这是一组独特的宏，用于将操作发送到渲染线程进行操作。\n主要是对Texture之类的数据在GPU以及GPU相关的指令进行执行。\n渲染线程的通信 参考链接：\n 《Exploring in UE4》多线程机制详解[原理分析] 纹理和采样器 虚幻4 Task Graph System 介绍  预览 UE4引擎运行时的部分线程，在UE中，许多模块都使用多线程，如渲染模块、物理模块、网络通信、音频系统、IO：\n虽然UE4遵循C++11的标准，但是他并没有使用std::thread，而是自己实现了一套多线程机制（应该是从UE3时代就有了，未考证），用法上很像Java。\n使用线程 在UE4里面，使用线程有三个方法：\n 我们可以自己继承FRunnable接口创建单个线程 直接创建AsyncTask来调用线程池里面空闲的线程 通过TaskGraph系统来异步完成一些自定义任务。  FRunnable 线索：\n   模块 Core     .h /Engine/Source/Runtime/Core/Public/HAL/Runnable.h   include #include \u0026ldquo;HAL/Runnable.h\u0026rdquo;     UE4中最基础的模型就是FRunnable和FRunnableThread，FRunnable抽象出一个可以执行在线程上的对象，而FRunnableThread是平台无关的线程对象的抽象。后面的篇幅会详细讨论这些基础设施。\n 创建一个继承于FRunnable的类，FRunnable声明如下：\n FRunnable就是一个很简单的类，里面只有5，6个函数接口，为了与真正的线程区分，我这里称FRunnable为“线程执行体”；所谓真正的线程其实就是FRunnableThread，不同平台的线程都继承自他，如FRunnableThreadWin，里面会调用Windows平台的创建线程的API接口。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  class CORE_API FRunnable { public: /** * Initializes the runnable object. * * This method is called in the context of the thread object that aggregates this, not the * thread that passes this runnable to a new thread. * * @return True if initialization was successful, false otherwise * @see Run, Stop, Exit */ virtual bool Init() { return true; } /** * Runs the runnable object. * * This is where all per object thread work is done. This is only called if the initialization was successful. * * @return The exit code of the runnable object * @see Init, Stop, Exit */ virtual uint32 Run() = 0; /** * Stops the runnable object. * * This is called if a thread is requested to terminate early. * @see Init, Run, Exit */ virtual void Stop() { } /** * Exits the runnable object. * * Called in the context of the aggregating thread to perform any cleanup. * @see Init, Run, Stop */ virtual void Exit() { } /** * Gets single thread interface pointer used for ticking this runnable when multi-threading is disabled. * If the interface is not implemented, this runnable will not be ticked when FPlatformProcess::SupportsMultithreading() is false. * * @return Pointer to the single thread interface or nullptr if not implemented. */ virtual class FSingleThreadRunnable* GetSingleThreadInterface( ) { return nullptr; } /** Virtual destructor */ virtual ~FRunnable() { } };   FRunnable与线程之间的关系类图：\nUE4中的多线程模型用一句话概括为: A FRunnable runs on a FRunnableThread.\n FQueuedThreadPool线程池    模块 Core      /Engine/Source/Runtime/Core/Public/Misc/QueuedThreadPool.h    #include \u0026ldquo;Misc/QueuedThreadPool.h\u0026rdquo;    FQueuedThreadPool。和一般的线程池实现类似，线程池里面维护了多个线程FQueuedThread与多个任务队列IQueuedWork，线程是按照队列的方式来排列的。\n在线程池里面所有的线程都是FQueuedThread类型，不过更确切的说FQueuedThread是继承自FRunnable的线程执行体，每个FQueuedThread里面包含一个FRunnableThread作为内部成员。\n相比一般的线程，FQueuedThread里面多了一个成员FEvent* DoWorkEvent，也就是说FQueuedThread里面是有一个事件触发机制的。那么这个事件机制的作用是什么？一般情况下来说，就是在没有任务的时候挂起这个线程，在添加并分配给该线程任务的时候激活他，不过你可以灵活运用它，在你需要的时候去动态控制线程任务的执行与暂停。\n AsyncTask系统 AsyncTask系统是一套基于线程池的异步任务处理系统。\nFAsyncTask有几个特点：\n FAsyncTask是一个模板类，真正的AsyncTask需要你自己写。通过DoWork提供你要执行的具体任务，然后把你的类作为模板参数传过去 使用FAsyncTask就默认你要使用UE提供的线程池FQueuedThreadPool，前面代码里说明了在引擎PreInit的时候会初始化线程池并返回一个指针GThreadPool。在执行FAsyncTask任务时，如果你在执行StartBackgroundTask的时候会默认使用GThreadPool线程池，当然你也可以在参数里面指定自己创建的线程池 创建FAsyncTask并不一定要使用新的线程，你可以调用函数StartSynchronousTask直接在当前线程上执行任务 FAsyncTask本身包含一个DoneEvent，任务执行完成的时候会激活该事件。当你想等待一个任务完成时再做其他操作，就可以调用EnsureCompletion函数，他可以从队列里面取出来还没被执行的任务放到当前线程来做，也可以挂起当前线程等待DoneEvent激活后再往下执行  Task Graph 系统 Task Graph 系统是UE4一套抽象的异步任务处理系统，可以创建多个多线程任务，指定各个任务之间的依赖关系，按照该关系来依次处理任务。\nTick函数\n平时调试的时候，我们随便找个Tick断点一下都能看到类似下图这样的函数堆栈。如果你前面的章节都看懂的话，这个堆栈也能大概理解。World在执行Tick的时候，触发了FNamedTaskThread线程去执行任务（FTickFunctionTask），任务FTickFunctionTask具体的工作内容就是执行ACtorComponent的Tick函数。其实，这个堆栈也说明了所有Actor与Component的Tick都是通过TaskGraph系统来执行的（在TG_PrePhysics阶段）。\nCconclusion ==对于消耗大的，复杂的任务不建议使用TaskGraph，一是因为TaskGraph如果被分配到游戏线程，就会阻塞整个游戏线程的执行，二是即使你不在那几个有名字的线程上执行，也可能会影响到游戏的其他逻辑。==\n全家福：\n线程同步 UE4对操作系统提供的线程同步相关接口进行了一定的封装。\nAtomics \u0026hellip;\u0026hellip;\n","description":"","id":4,"section":"posts","tags":["UE","C++"],"title":"UE4多线程","uri":"https://vhope.cf/zh/posts/ue/ue-thread-commuicate/"},{"content":"UE4问题汇总   UE4光照构建失败⚠\nhttps://blog.csdn.net/earlyAutumnOfRain/article/details/80863561\n  UE4导入灰度图\nhttps://www.cnblogs.com/gucheng/p/10116857.html\n  详解UE4静态库与动态库的导入与使用\nhttps://gameinstitute.qq.com/community/detail/121551\n  Ue4_序列化浅析_\nhttps://blog.csdn.net/mohuak/article/details/83027211\n  UE快捷键\nhttps://www.unrealengine.com/zh-CN/tech-blog/designer-s-guide-to-unreal-engine-keyboard-shortcuts\n  UE4资源加载（一）从StaticLoadObject开始\nhttp://suo.im/6v7hUc\n  Unreal Cookbook：创建对象的的几种姿势（C++）\nhttps://blog.csdn.net/Neil3D/article/details/51488401\n  Aery的UE4 C++游戏开发之旅（1）基础对象模型\nhttps://www.cnblogs.com/KillerAery/p/11986316.html\n  目录结构\nhttps://docs.unrealengine.com/zh-CN/Engine/Basics/DirectoryStructure/index.html\n  引擎世界\nhttps://www.engineworld.cn/\n  《InsideUE4》GamePlay架构（一）Actor和Component\nhttps://zhuanlan.zhihu.com/p/22833151\n  实时渲染中的坐标系变换（5）：投影变换-3\nhttps://zhuanlan.zhihu.com/p/115395322\n  UE4 屏幕坐标转换到世界坐标\nhttps://blog.csdn.net/weixin_36412907/article/details/77306212\n  UE4必读文章列表_个人整理\nhttps://zhuanlan.zhihu.com/p/126611976\n  OpenGL 学习系列\u0026mdash;投影矩阵\nhttps://juejin.im/post/5b0ec5fef265da092a2b79b1\n  Alpha Test\nhttp://geekfaner.com/shineengine/blog13_OpenGLESv2_12.html\n  Rendoc使用\nhttps://www.cnblogs.com/kekec/p/11760288.html\n  [多视图几何] - 逆透视变换\nhttps://blog.csdn.net/chishuideyu/article/details/79136903\n  UE4必读文章列表_个人整理\nhttps://zhuanlan.zhihu.com/p/126611976\n  UE4中的Tone Mapping\nhttps://www.dingshukai.com/blog/ue4-tone-mapping.html\n  UE4 渲染流程\nhttps://blog.csdn.net/or_7r_ccl/article/details/81102771\n  [UE4]尝试使用自定义深度 fq\nhttp://monsho.blog63.fc2.com/blog-entry-138.html#comment469\n  [UE4]扩展GBuffer\nhttp://monsho.blog63.fc2.com/blog-entry-191.html\n  https://ue4study-osaka.connpass.com/event/120568/\n  UE4文件系统  模块是UE4的构建块。引擎是以大量模块的集合形式实现的，游戏提供自己的模块来扩充自己。每个模块都封装了一组功能，并且可以提供公共接口和编译环境（包括宏、路径等）供其他模块使用。\n .build.cs文件的典型结构如下。\n1 2 3 4 5 6 7 8 9  using UnrealBuildTool; using System.Collections.Generic; public class MyModule : ModuleRules { public MyModule(ReadOnlyTargetRules Target) : base(Target) { // Settings go here  } }     \\Engine\\Source\\ThirdParty目录\n存放第三方的库\n  F:\\UnrealEngine4.14\\Engine\\Plugins目录(或者F:\\UE4Project\\项目名称\\Plugins目录)\n保存插件的目录\n  UE创世，万物皆UObject，接着有Actor。\nComponent和Actor  UE4让Actor们轻装上阵，只提供一些通用的基本生存能力，而把众多的“技能”抽象成了一个个“Component”并提供组装的接口，让Actor随用随组装，把自己武装成一个个专业能手。\n 相关组件 RootComponent 定义这个演员在世界上的变换(位置、旋转、缩放)的组件，所有其他组件必须以某种方式附加到这个组件\n弹簧臂组件 弹簧臂组件用于自动控制摄像机受阻时的应对方式。\nUE文件存储的方式 UE 中使用统一的格式存储资源 (uasset， umap)，每个 uasset 对应一个包 (package)，存储一个 UPackage 对象时，会将该包下的所有对象都存到 uasset 中。\n 一个资源在文件中对应uasset，在内存中对应为UPackage。\n uasset文件格式  File Summary 文件头信息 Name Table 包中对象的名字表 Import Table 存放被该包中对象引用的其它包中的对象信息(路径名和类型) Export Table 该包中的对象信息(路径名和类型) Export Objects 所有Export Table中对象的实际数据。  FlinkerLoad FLinkerLoad是作为uasset和内存UPackage的中间桥梁。在加载内容生成UPackage的时候，UPackage会根据名字找到uasset文件，由FLinkerLoad来负责加载。\nFLinkerLoad主要内容如下：\n FArchive* Loader;\t//Loader负责读取具体文件 TArray ImportMap; //将uasset的ImportTable加载到ImportMap中，FObjectImport是需要依赖（导入）的UObject TArray ExportMap; //FObjectExport是这个UPackage所拥有的UObject（这些UObject都能提供给其他UPackage作为Import）  StaticLoadObject加载 步骤：\n 根据文件名字创建一个空的包（没有任何文件相关的数据） 建立一个LinkerLoad去加载对应的uasset文件 序列化。 优先加载ImportMap 加载ExportMap（本身的数据）  1、建立一个UPackage\n2、序列化uasset\n3、加载ImportMap\nPawn默认组件 UE相机 http://www.geodesic.games/2019/03/27/projection-matrices-in-unreal-engine/\n Firstly, Unreal inverses the perspective divide, applying 1 instead of -1 for the “W” value.（虚幻处理投影与 Unity 中使用的标准 OpenGL 透视矩阵不同。） Secondly, Unreal applies a matrix transposition to all their perspective matrices.（其次，Unreal 对所有的透视矩阵进行了矩阵移位。  缺省情况下，Unreal 提供了各种方便的透视矩阵构造函数。 有两种变体，一种是普通透视矩阵，另一种是逆向透视矩阵。  右手坐标系： https://zhuanlan.zhihu.com/p/114729671\n透视投影：\n归一化齐次坐标以后的结果是：\n camera space 3D空间中，相同的x，z越大，投影变换以后的x分量越靠近0。\u0026ldquo;近大远小\u0026quot;的透视效果，就是这么算出来的。\n  Unity的投影矩阵，是把视锥内的所有3D坐标，转换到 [-1,1] 范围之内。最后转化为Screen Space，范围为[0,1]\n 深度值是到近平面的距离：\n正交投影：\n 透视投影变换，有\u0026quot;近大远小\u0026quot;的透视效果。3D空间中的两条平行线，在投影变换以后会相交于某个\u0026quot;灭点\u0026rdquo;。\n正交投影变换，没有\u0026quot;近大远小\u0026quot;的透视效果。3D空间中的两条平行线，在投影变换以后，仍旧是平行的。\n Unreal 正交矩阵：\n UE4里的透视投影矩阵的计算方式，参见引擎源代码的OrthoMatrix.h文件。\n 代码1：\n1  UGameplayStatics::DeprojectScreenToWorld(UGameplayStatics::GetPlayerController(GetWorld(), 0), forwardCursorPos, forwardWorldPos, forwardMoveDirection);   代码2：\n1 2 3  FVector forwardMoveDirection; GetWorld()-\u0026gt;GetFirstPlayerController()-\u0026gt;GetMousePosition(forwardCursorPos.X, forwardCursorPos.Y); UGameplayStatics::DeprojectScreenToWorld(UGameplayStatics::GetPlayerController(GetWorld(), 0), forwardCursorPos, forwardWorldPos, forwardMoveDirection);    APlayerController 玩家控制器被人类玩家用来控制棋子。地址 ULocalPlayer 当前客户端上的每个玩家都有一个LocalPlayer。地址 FViewportClient 视窗客户端的抽象接口。地址 ViewportClient 在玩家中包含此玩家视图的主视窗.。 地址 ULocalPlayer::GetProjectionData 用于导出投影所需的各种数据位的辅助函数。 地址  bianxngjing:\nhttps://v.qq.com/x/page/t0770a2b6f6.html\nAPI UGameplayStatics::DeprojectScreenToWorld  Unity 与 NGUI 坐标转换原理   将给定的2D屏幕空间坐标转换为3D世界空间点和方向。\nAPI地址： https://docs.unrealengine.com/en-US/API/Runtime/Engine/Kismet/UGameplayStatics/DeprojectScreenToWorld/index.html\n语法：\n1 2 3 4 5 6 7  static bool DeprojectScreenToWorld ( APlayerController const * Player,\t// 玩家视角  const FVector2D \u0026amp; ScreenPosition,\t// 2D点  FVector \u0026amp; WorldPosition,\t// 世界空间三维坐标 输出  FVector \u0026amp; WorldDirection\t// 在给定的2d点上远离相机的世界空间方向矢量。\t输出 )   源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  bool UGameplayStatics::DeprojectScreenToWorld(APlayerController const* Player, const FVector2D\u0026amp; ScreenPosition, FVector\u0026amp; WorldPosition, FVector\u0026amp; WorldDirection) { // 获取LocalPlayer \tULocalPlayer* const LP = Player ? Player-\u0026gt;GetLocalPlayer() : nullptr; if (LP \u0026amp;\u0026amp; LP-\u0026gt;ViewportClient) {//ViewpoetClient 包含此玩家视图的主视窗。 \t// get the projection data \tFSceneViewProjectionData ProjectionData; //立体渲染通过。FULL表示此过程中未启用立体渲染，eSSP_FULL \tif (LP-\u0026gt;GetProjectionData(LP-\u0026gt;ViewportClient-\u0026gt;Viewport, eSSP_FULL, /*out*/ ProjectionData)) {// 获取投影数据 \tFMatrix const InvViewProjMatrix = ProjectionData.ComputeViewProjectionMatrix().InverseFast(); FSceneView::DeprojectScreenToWorld(ScreenPosition, ProjectionData.GetConstrainedViewRect(), InvViewProjMatrix, /*out*/ WorldPosition, /*out*/ WorldDirection); return true; } } // something went wrong, zero things and return false，错误不管 \tWorldPosition = FVector::ZeroVector; WorldDirection = FVector::ZeroVector; return false; }   逆透视变换 投影矩阵：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // Projection data for a FSceneView struct FSceneViewProjectionData { FVector ViewOrigin;\t//源视图向量 \t/** Rotation matrix transforming from world space to view space. */ FMatrix ViewRotationMatrix;\t// 从世界空间到视图空间的旋转矩阵转换。 \t/** UE4 projection matrix projects such that clip space Z=1 is the near plane, and Z=0 is the infinite far plane. */ FMatrix ProjectionMatrix;\t// UE4投影矩阵投影使得剪辑空间Z=1是近平面，Z=0是无限远平面。 protected: //The unconstrained (no aspect ratio bars applied) view rectangle (also unscaled) \tFIntRect ViewRect;\t// 无约束(未应用宽高比条)视图矩形(也未缩放) \t// The constrained view rectangle (identical to UnconstrainedUnscaledViewRect if aspect ratio is not constrained) \tFIntRect ConstrainedViewRect;\t// 受约束的视图矩形(如果长宽比不受约束，则与UnconstrainedUnscaledViewRect相同) public: void SetViewRectangle(const FIntRect\u0026amp; InViewRect) { ViewRect = InViewRect; ConstrainedViewRect = InViewRect; } void SetConstrainedViewRectangle(const FIntRect\u0026amp; InViewRect) { ConstrainedViewRect = InViewRect; } // 上面两个函数设置Rect窗口  bool IsValidViewRectangle() const {//判断窗口是否有效 \treturn (ConstrainedViewRect.Min.X \u0026gt;= 0) \u0026amp;\u0026amp; (ConstrainedViewRect.Min.Y \u0026gt;= 0) \u0026amp;\u0026amp; (ConstrainedViewRect.Width() \u0026gt; 0) \u0026amp;\u0026amp; (ConstrainedViewRect.Height() \u0026gt; 0); } bool IsPerspectiveProjection() const {// 判断是不是透视投影矩阵 \treturn ProjectionMatrix.M[3][3] \u0026lt; 1.0f; } const FIntRect\u0026amp; GetViewRect() const { return ViewRect; } const FIntRect\u0026amp; GetConstrainedViewRect() const { return ConstrainedViewRect; } FMatrix ComputeViewProjectionMatrix() const {// 计算视图投影矩阵 \treturn FTranslationMatrix(-ViewOrigin) * ViewRotationMatrix * ProjectionMatrix; } };   上面平移矩阵：\n1 2 3 4 5 6 7 8  FORCEINLINE FTranslationMatrix::FTranslationMatrix(const FVector\u0026amp; Delta)\t//基于给定向量的构造函数转换矩阵，//转置矩阵 \t: FMatrix( FPlane(1.0f,\t0.0f,\t0.0f,\t0.0f), FPlane(0.0f,\t1.0f,\t0.0f,\t0.0f), FPlane(0.0f,\t0.0f,\t1.0f,\t0.0f), FPlane(Delta.X,\tDelta.Y,Delta.Z,1.0f) ) { }   难点一：GetProjectionData函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  bool ULocalPlayer::GetProjectionData(FViewport* Viewport, EStereoscopicPass StereoPass, FSceneViewProjectionData\u0026amp; ProjectionData) const { // If the actor  //Size为分配给此玩家的主视口子区域的大小。0-1  // Viewport-\u0026gt;GetSizeXY()获取视端的X与Y \tif ((Viewport == NULL) || (PlayerController == NULL) || (Viewport-\u0026gt;GetSizeXY().X == 0) || (Viewport-\u0026gt;GetSizeXY().Y == 0) || (Size.X == 0) || (Size.Y == 0)) { return false; } // 将浮点数转换为截断值接近零的整数。即向下取整  // Origin为分配给该玩家的主视口子区域左上角的坐标。0-1 \tint32 X = FMath::TruncToInt(Origin.X * Viewport-\u0026gt;GetSizeXY().X); int32 Y = FMath::TruncToInt(Origin.Y * Viewport-\u0026gt;GetSizeXY().Y); // 加上视端初始的坐标值 \tX += Viewport-\u0026gt;GetInitialPositionXY().X; Y += Viewport-\u0026gt;GetInitialPositionXY().Y; //新的窗口大小 \tuint32 SizeX = FMath::TruncToInt(Size.X * Viewport-\u0026gt;GetSizeXY().X); uint32 SizeY = FMath::TruncToInt(Size.Y * Viewport-\u0026gt;GetSizeXY().Y); //X=0,Y = 0 #if !(UE_BUILD_SHIPPING || UE_BUILD_TEST) // We expect some size to avoid problems with the view rect manipulation \t// 我们希望有一定的大小来避免view rect操作的问题 \tif(SizeX \u0026gt; 50 \u0026amp;\u0026amp; SizeY \u0026gt; 50) { int32 Value = CVarViewportTest.GetValueOnGameThread();\t//根据value的值分类各种视端  if(Value) { int InsetX = SizeX / 4; int InsetY = SizeY / 4; // this allows to test various typical view port situations (todo: split screen)  // 这允许测试各种典型的视图端口情况(todo:分割屏幕) \tswitch(Value) { case 1: X += InsetX; Y += InsetY; SizeX -= InsetX * 2; SizeY -= InsetY * 2;break; case 2: Y += InsetY; SizeY -= InsetY * 2; break; case 3: X += InsetX; SizeX -= InsetX * 2; break; case 4: SizeX /= 2; SizeY /= 2; break; case 5: SizeX /= 2; SizeY /= 2; X += SizeX;\tbreak; case 6: SizeX /= 2; SizeY /= 2; Y += SizeY; break; case 7: SizeX /= 2; SizeY /= 2; X += SizeX; Y += SizeY; break; } } } #endif\t// FIntRect为二维空间中整数矩形的结构。新的视端矩阵 \tFIntRect UnconstrainedRectangle = FIntRect(X, Y, X+SizeX, Y+SizeY);//InMin(X,Y),InMax(X+SizeX,Y+SizeY) \t// 设置投影数据的窗口 \tProjectionData.SetViewRectangle(UnconstrainedRectangle); // Get the viewpoint.  // 获得视点 \tFMinimalViewInfo ViewInfo; //结构  /** enum EStereoscopicPass { eSSP_FULL, eSSP_LEFT_EYE, eSSP_RIGHT_EYE, eSSP_LEFT_EYE_SIDE, eSSP_RIGHT_EYE_SIDE, } **/ GetViewPoint(/*out*/ ViewInfo, StereoPass);\t//检索该玩家的视点。  // If stereo rendering is enabled, update the size and offset appropriately for this pass  // 如果启用了立体渲染，请为此过程适当更新大小和偏移 \tconst bool bNeedStereo = IStereoRendering::IsStereoEyePass(StereoPass) \u0026amp;\u0026amp; GEngine-\u0026gt;IsStereoscopic3D(); const bool bIsHeadTrackingAllowed = GEngine-\u0026gt;XRSystem.IsValid() \u0026amp;\u0026amp; GEngine-\u0026gt;XRSystem-\u0026gt;IsHeadTrackingAllowed(); if (bNeedStereo) { GEngine-\u0026gt;StereoRenderingDevice-\u0026gt;AdjustViewRect(StereoPass, X, Y, SizeX, SizeY); } // scale distances for cull distance purposes by the ratio of our current FOV to the default FOV  // 根据我们当前的FOV与默认FOV的比率，为选择距离的目的缩放距离 \tPlayerController-\u0026gt;LocalPlayerCachedLODDistanceFactor = ViewInfo.FOV / FMath::Max\u0026lt;float\u0026gt;(0.01f, (PlayerController-\u0026gt;PlayerCameraManager != NULL) ? PlayerController-\u0026gt;PlayerCameraManager-\u0026gt;DefaultFOV : 90.f); FVector StereoViewLocation = ViewInfo.Location; // 加入立体渲染或者  if (bNeedStereo || bIsHeadTrackingAllowed) {// 假如启用了立体渲染和头部追踪 \tauto XRCamera = GEngine-\u0026gt;XRSystem.IsValid() ? GEngine-\u0026gt;XRSystem-\u0026gt;GetXRCamera() : nullptr;\t//虚拟现实相机 \tif (XRCamera.IsValid()) { AActor* ViewTarget = PlayerController-\u0026gt;GetViewTarget(); const bool bHasActiveCamera = ViewTarget \u0026amp;\u0026amp; ViewTarget-\u0026gt;HasActiveCameraComponent(); XRCamera-\u0026gt;UseImplicitHMDPosition(bHasActiveCamera); } if (GEngine-\u0026gt;StereoRenderingDevice.IsValid()) { GEngine-\u0026gt;StereoRenderingDevice-\u0026gt;CalculateStereoViewOffset(StereoPass, ViewInfo.Rotation, GetWorld()-\u0026gt;GetWorldSettings()-\u0026gt;WorldToMeters, StereoViewLocation); } } // Create the view matrix  // 创建视图矩阵  // FPlane 三维平面的结构。(X,Y,Z,W)  // FMatrix 浮点值的4x4矩阵。 \tProjectionData.ViewOrigin = StereoViewLocation; ProjectionData.ViewRotationMatrix = FInverseRotationMatrix(ViewInfo.Rotation) * FMatrix( FPlane(0,\t0,\t1,\t0), FPlane(1,\t0,\t0,\t0), FPlane(0,\t1,\t0,\t0), FPlane(0,\t0,\t0,\t1)); // @todo viewext this use case needs to be revisited  // 重新考虑viewext \tif (!bNeedStereo)\t//假如没有立体渲染 \t{ // Create the projection matrix (and possibly constrain the view rectangle)  // 创建投影矩阵(并可能约束视图矩形)  // ViewInfo视点 \tFMinimalViewInfo::CalculateProjectionMatrixGivenView(ViewInfo, AspectRatioAxisConstraint, Viewport, /*inout*/ ProjectionData);//计算给定视图投影矩阵 \t// 视图扩展对象可以在没有运动控制器组件的情况下保留在渲染线程上，大概是设置相关试图拓展的投影矩阵 \tfor (auto\u0026amp; ViewExt : GEngine-\u0026gt;ViewExtensions-\u0026gt;GatherActiveExtensions()) { ViewExt-\u0026gt;SetupViewProjectionMatrix(ProjectionData); }; } else {\t// 有三维渲染 \t// Let the stereoscopic rendering device handle creating its own projection matrix, as needed  // 让立体渲染设备根据需要处理创建自己的投影矩阵，调用一系列函数GetProjectMatrix \tProjectionData.ProjectionMatrix = GEngine-\u0026gt;StereoRenderingDevice-\u0026gt;GetStereoProjectionMatrix(StereoPass); // calculate the out rect \tProjectionData.SetViewRectangle(FIntRect(X, Y, X + SizeX, Y + SizeY)); } return true; }   难点：计算给定视图投影矩阵\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  void FMinimalViewInfo::CalculateProjectionMatrixGivenView(const FMinimalViewInfo\u0026amp; ViewInfo, TEnumAsByte\u0026lt;enum EAspectRatioAxisConstraint\u0026gt; AspectRatioAxisConstraint, FViewport* Viewport, FSceneViewProjectionData\u0026amp; InOutProjectionData) { // Create the projection matrix (and possibly constrain the view rectangle)  // 创建投影矩阵(并可能约束视图矩形) \tif (ViewInfo.bConstrainAspectRatio) { // Enforce a particular aspect ratio for the render of the scene. \t// Results in black bars at top/bottom etc. \tInOutProjectionData.SetConstrainedViewRectangle(Viewport-\u0026gt;CalculateViewExtents(ViewInfo.AspectRatio, InOutProjectionData.GetViewRect())); InOutProjectionData.ProjectionMatrix = ViewInfo.CalculateProjectionMatrix(); } else { // Avoid divide by zero in the projection matrix calculation by clamping FOV \tfloat MatrixFOV = FMath::Max(0.001f, ViewInfo.FOV) * (float)PI / 360.0f; float XAxisMultiplier; float YAxisMultiplier; const FIntRect\u0026amp; ViewRect = InOutProjectionData.GetViewRect(); const int32 SizeX = ViewRect.Width(); const int32 SizeY = ViewRect.Height(); // if x is bigger, and we\u0026#39;re respecting x or major axis, AND mobile isn\u0026#39;t forcing us to be Y axis aligned \tif (((SizeX \u0026gt; SizeY) \u0026amp;\u0026amp; (AspectRatioAxisConstraint == AspectRatio_MajorAxisFOV)) || (AspectRatioAxisConstraint == AspectRatio_MaintainXFOV) || (ViewInfo.ProjectionMode == ECameraProjectionMode::Orthographic)) { //if the viewport is wider than it is tall \tXAxisMultiplier = 1.0f; YAxisMultiplier = SizeX / (float)SizeY; } else { //if the viewport is taller than it is wide \tXAxisMultiplier = SizeY / (float)SizeX; YAxisMultiplier = 1.0f; } if (ViewInfo.ProjectionMode == ECameraProjectionMode::Orthographic) {\t//判断投影模式 \tconst float OrthoWidth = ViewInfo.OrthoWidth / 2.0f * XAxisMultiplier; const float OrthoHeight = (ViewInfo.OrthoWidth / 2.0f) / YAxisMultiplier; const float NearPlane = ViewInfo.OrthoNearClipPlane; const float FarPlane = ViewInfo.OrthoFarClipPlane; const float ZScale = 1.0f / (FarPlane - NearPlane); const float ZOffset = -NearPlane; InOutProjectionData.ProjectionMatrix = FReversedZOrthoMatrix( // 计算反向Z正交矩阵 \tOrthoWidth, OrthoHeight, ZScale, ZOffset );\t} else { InOutProjectionData.ProjectionMatrix = FReversedZPerspectiveMatrix(\t// 反转Z透视矩阵 \tMatrixFOV, MatrixFOV, XAxisMultiplier, YAxisMultiplier, GNearClippingPlane, GNearClippingPlane ); } } if (!ViewInfo.OffCenterProjectionOffset.IsZero()) { const float Left = -1.0f + ViewInfo.OffCenterProjectionOffset.X; const float Right = Left + 2.0f; const float Bottom = -1.0f + ViewInfo.OffCenterProjectionOffset.Y; const float Top = Bottom + 2.0f; InOutProjectionData.ProjectionMatrix.M[2][0] = (Left + Right) / (Left - Right); InOutProjectionData.ProjectionMatrix.M[2][1] = (Bottom + Top) / (Bottom - Top); } }   反向Z正交：\n1 2 3 4 5 6 7 8  FORCEINLINE FReversedZOrthoMatrix::FReversedZOrthoMatrix(float Width,float Height,float ZScale,float ZOffset) : FMatrix( FPlane((Width != 0.0f) ? (1.0f / Width) : 1.0f, 0.0f, 0.0f, 0.0f), FPlane(0.0f, (Height != 0.0f) ? (1.0f / Height) : 1.f, 0.0f, 0.0f), FPlane(0.0f, 0.0f, -ZScale, 0.0f), FPlane(0.0f, 0.0f, 1.0f - ZOffset * ZScale, 1.0f) ) { }   难点2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  void FSceneView::DeprojectScreenToWorld(const FVector2D\u0026amp; ScreenPos, const FIntRect\u0026amp; ViewRect, const FMatrix\u0026amp; InvViewProjMatrix, FVector\u0026amp; out_WorldOrigin, FVector\u0026amp; out_WorldDirection) { float PixelX = FMath::TruncToFloat(ScreenPos.X); float PixelY = FMath::TruncToFloat(ScreenPos.Y); // Get the eye position and direction of the mouse cursor in two stages (inverse transform projection, then inverse transform view).  // //分两个阶段获取鼠标光标的眼睛位置和方向(逆变换投影，然后逆变换视图)。  // This avoids the numerical instability that occurs when a view matrix with large translation is composed with a projection matrix \t// //这避免了当具有大平移的视图矩阵由投影矩阵组成时出现的数值不稳定性  // Get the pixel coordinates into 0..1 normalized coordinates within the constrained view rectangle  // 将像素坐标转换为0..1约束视图矩形内的标准化坐标 \tconst float NormalizedX = (PixelX - ViewRect.Min.X) / ((float)ViewRect.Width()); const float NormalizedY = (PixelY - ViewRect.Min.Y) / ((float)ViewRect.Height()); // Get the pixel coordinates into -1..1 projection space  // 将像素坐标转换为-1..1投影空间 \tconst float ScreenSpaceX = (NormalizedX - 0.5f) * 2.0f; const float ScreenSpaceY = ((1.0f - NormalizedY) - 0.5f) * 2.0f; // The start of the ray trace is defined to be at mousex,mousey,1 in projection space (z=1 is near, z=0 is far - this gives us better precision)  // //光线跟踪的开始被定义为在投影空间中mousex，mousey，1处(z = 1是近的，z=0是远的-这给了我们更好的精度) \t// To get the direction of the ray trace we need to use any z between the near and the far plane, so let\u0026#39;s use (mousex, mousey, 0.5)  // //为了得到光线轨迹的方向，我们需要使用近平面和远平面之间的任何z，所以让我们使用(mousex，mousey，0.5) \tconst FVector4 RayStartProjectionSpace = FVector4(ScreenSpaceX, ScreenSpaceY, 1.0f, 1.0f); const FVector4 RayEndProjectionSpace = FVector4(ScreenSpaceX, ScreenSpaceY, 0.5f, 1.0f); // Projection (changing the W coordinate) is not handled by the FMatrix transforms that work with vectors, so multiplications  // //投影(改变w坐标)不是由处理向量的矩阵变换来处理的，所以乘法  // by the projection matrix should use homogeneous coordinates (i.e. FPlane).  // 由投影矩阵应使用齐次坐标(即平面)。 \tconst FVector4 HGRayStartWorldSpace = InvViewProjMatrix.TransformFVector4(RayStartProjectionSpace); const FVector4 HGRayEndWorldSpace = InvViewProjMatrix.TransformFVector4(RayEndProjectionSpace); FVector RayStartWorldSpace(HGRayStartWorldSpace.X, HGRayStartWorldSpace.Y, HGRayStartWorldSpace.Z); FVector RayEndWorldSpace(HGRayEndWorldSpace.X, HGRayEndWorldSpace.Y, HGRayEndWorldSpace.Z); // divide vectors by W to undo any projection and get the 3-space coordinate  // //将向量除以w以撤销任何投影并获得3-空间坐标 \tif (HGRayStartWorldSpace.W != 0.0f) { RayStartWorldSpace /= HGRayStartWorldSpace.W; } if (HGRayEndWorldSpace.W != 0.0f) { RayEndWorldSpace /= HGRayEndWorldSpace.W; } const FVector RayDirWorldSpace = (RayEndWorldSpace - RayStartWorldSpace).GetSafeNormal(); // Finally, store the results in the outputs \tout_WorldOrigin = RayStartWorldSpace; out_WorldDirection = RayDirWorldSpace; }   FPlane:\nFMatrix:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  FORCEINLINE FMatrix::FMatrix(const FPlane\u0026amp; InX,const FPlane\u0026amp; InY,const FPlane\u0026amp; InZ,const FPlane\u0026amp; InW) { M[0][0] = InX.X; M[0][1] = InX.Y; M[0][2] = InX.Z; M[0][3] = InX.W; M[1][0] = InY.X; M[1][1] = InY.Y; M[1][2] = InY.Z; M[1][3] = InY.W; M[2][0] = InZ.X; M[2][1] = InZ.Y; M[2][2] = InZ.Z; M[2][3] = InZ.W; M[3][0] = InW.X; M[3][1] = InW.Y; M[3][2] = InW.Z; M[3][3] = InW.W; } FORCEINLINE FMatrix::FMatrix(const FVector\u0026amp; InX,const FVector\u0026amp; InY,const FVector\u0026amp; InZ,const FVector\u0026amp; InW) { M[0][0] = InX.X; M[0][1] = InX.Y; M[0][2] = InX.Z; M[0][3] = 0.0f; M[1][0] = InY.X; M[1][1] = InY.Y; M[1][2] = InY.Z; M[1][3] = 0.0f; M[2][0] = InZ.X; M[2][1] = InZ.Y; M[2][2] = InZ.Z; M[2][3] = 0.0f; M[3][0] = InW.X; M[3][1] = InW.Y; M[3][2] = InW.Z; M[3][3] = 1.0f; }   step1:\nAPI UGameplayStatics::ProjectWorldToScreen 将给定的3D世界空间点转换为其2D屏幕空间坐标。\nAPI地址： https://docs.unrealengine.com/en-US/API/Runtime/Engine/Kismet/UGameplayStatics/ProjectWorldToScreen/index.html\n语法：\n1 2 3 4 5 6 7  static bool ProjectWorldToScreen ( APlayerController const * Player, const FVector \u0026amp; WorldPosition, FVector2D \u0026amp; ScreenPosition, bool bPlayerViewportRelative\t//这是否应该与玩家视窗子区域相关(在分割屏幕中使用玩家附加的小部件时很有用) )   Z-Buffer 用Renderdoc对UE4(PC，DX11）截帧，UE4的版本为4.18. 可以看到UE4一帧画面的渲染过程如下\n获取GBuffer的一种方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ENQUEUE_UNIQUE_RENDER_COMMAND_ONEPARAMETER( DZRenderSutioBP_InterceptSceneBaseColor, UTexture2D*, vTextureAsset, TextureAsset, { /*if (!IsInRenderingThread()) return;*/ FRHICommandListImmediate\u0026amp; RHICmdList = GRHICommandList.GetImmediateCommandList(); //计数加一避免Render完成后直接清空了GBuffer,但会慢一帧，你猜 FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, 1); static const FString ScrollingMessage(TEXT(\u0026#34;Hello World: \u0026#34;)); GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 0.2f, FColor::Red, ScrollingMessage); FSceneRenderTargets\u0026amp; SceneContext = FSceneRenderTargets::Get(RHICmdList); if (SceneContext.GBufferA) { FTexture2DRHIRef vTextTarget = SceneContext.GetGBufferATexture(); FString vSiceStr = FString::Printf(TEXT(\u0026#34;FSceneRenderTargets GBufferA Size = %d*%d\u0026#34;), vTextTarget-\u0026gt;GetSizeX(), vTextTarget-\u0026gt;GetSizeY()); GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 0.2f, FColor::Red, vSiceStr); } //移除 FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, -1); } );   How to export FTexture2DRHIRef to png?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class SceneDepthCapture { public: TArray\u0026lt;FLinearColor\u0026gt; sceneDepthData; FIntPoint bufferSize; void SceneDepthCaptureSync() { ENQUEUE_RENDER_COMMAND(ReadSurfaceFloatCommand)( [this](FRHICommandListImmediate\u0026amp; RHICmdList) { FSceneRenderTargets\u0026amp; context = FSceneRenderTargets::Get(RHICmdList); bufferSize = context.GetBufferSizeXY(); FIntRect Rect(0, 0, bufferSize.X, bufferSize.Y); RHICmdList.ReadSurfaceData( context.GetSceneDepthTexture(), Rect, sceneDepthData, FReadSurfaceDataFlags()); }); FlushRenderingCommands(); } };   使用模块的方式 使用模块\n添加自定义Pass的方法  添加Shader  了解了一个Pass要完成的工作，我们就可以动手实现一个自己的 Pass 了。首先要确定的问题是 Shader。既然要把同一个模型画两次，那必然要用到不同的Shader。关于如何在UE4中添加 Shader，可以参考 DepthPass 的 VS/PS(在DepthRendering.h中) 和 UE4 的官方文档：https://docs.unrealengine.com/en-US/Programming/Rendering/ShaderDevelopment/index.html。MobileBasePass的Shader因为涉及环境光，点光源数等可开关的Defination，所以对应的 C++ 类是以 template 的形式实现的。一般来说自定义 Pass 的 Shader 会继承 FMaterialShader 并用 IMPLEMENT_MATERIAL_SHADER_TYPE 宏来绑定对应的 usf 文件。 可以完全自己写新的 usf 文件，也可以在 FMaterialShader::ModifyCompilationEnvironment() 中应用不同的 SetDefine() 来实现不同的 Shader。需要注意的是 UE4 的 Shader 编译是一个比较漫长的过程，所以最好在 FMaterialShader::ShouldCompilePremutation() 中对材质进行筛选，只编译必要的Shader。否则所有的 Material 都会编译对应的 Shader，效率很低。还有注意 Shader 要在构造函数中绑定需要的 Uniform Buffer，在 GetShaderBinding 中绑定对应的UniformBuffer，否则会出现 ResourceMiss。\n2. 添加 MeshProcessor\n根据对UE4的渲染流程分析我们可以看出，Pass 生成 DrawCall 的主要逻辑是在 MeshProcessor 中完成的。MeshProcessor 是 4.22 中新加入的类名，之前对应的是 DrawingPolicy。添加 MeshProcessor 很简单，只需要继承 FMeshPassProcessor 并复写其 AddMeshBatch() 方法即可。一般我们会在 AddMeshBatch 方法中获取 Material Resource 的信息并对 MeshBatch 做进一步筛选，最后调用 Process 方法绑定 Shader，Mesh 和 Material，计算 Mesh 的 CullMode，ZTest，Zwrite，BlendOP 和 SortKey等等并用 BuildMeshCommands 生成 DrawCall。\n3. 添加 Pass\n所有的 Pass 都可以在 Enum EMeshPass中找到，所以第一步就是在 MeshProcessor.h 的 EMeshPass 中添加对应的 Enum。然后我们要为 Pass 创建对应的 MeshProcessor，我们可以在对应 .cpp 文件中实现对应 MeshProcessor 的 Creator 方法，并定义对应的 FRegisterPassProcessorCreatFunction 在其构造函数中传入对应的 Creator 方法指针和 Pass Enum。这一部分可以参考 MobileBasePass.cpp 最后的 CreateMobileBasePassProcessor 和 RegisterMobileBasePass 部分。之后我们就要在 MobileSceneRenderer 的 Render 方法中插入自定义 Pass 的渲染流程，这一部分主要是一些 Profile 标签和 RHICmdList 的Setup 和 Flush，还有生成 Pass 的多线程 DrawTask。这一部分逻辑可以参考 MobileBasePassRendering.cpp 中的 RenderMobileBasePass 方法。\n","description":"虚幻引擎相关问题","id":5,"section":"talks","tags":[""],"title":"UE4 Problems","uri":"https://vhope.cf/zh/talks/ue4-talks/"},{"content":"大概介绍以下UE4的主要渲染过程。\nUE4渲染过程 延迟渲染 所谓延迟渲染，是指将一个场景的几何体（3D模型、多边形）的光照、阴影、质感搁置到一旁，先着手于绘画，然后在后半段再对光照、阴影、质感进行处理的处理方式。即给人一种把原本的多边形先绘制出来的印象，实际上不仅要绘制多边形，前者的参数还需要配合后面光照和阴影的处理。其输出目标，在成为复数缓冲时具有普遍性，但是这里的缓冲我们称之为\u0026quot;物理缓冲\u0026rdquo;。物体缓冲是指使用后照明和后处理特效的中间过渡环节\n相关术语 RHI\n渲染硬件接口，是为不同平台抽象出不同图形API的一层。所有渲染命令均通过RHI层传递，以转换为适用的渲染器。\n延迟渲染\n虚幻引擎4中的默认渲染器。它因将照明/阴影计算推迟到全屏过程而不是绘制每个网格时而得名。\n顶点工厂\n顶点工厂是封装顶点数据源并链接到顶点着色器上的输入的类。静态网格物体，骨架网格物体和过程网格组件均使用不同的顶点工厂。\n着色器\n在虚幻引擎中，着色器是HLSL代码（以.ush / .usf文件的形式）和材质图的内容的组合。在Unreal中创建材质时，它会根据设置（如着色模式）和用法来编译多个着色器排列。\n渲染数据 相关的渲染的数据包括深度值及一些Gbuffer，如下图：\n几个Pass Z Pre Pass UE4的渲染管道，是在Bass Pass的物体缓冲写出来之前，在仅预处理深度值（Z值）之后，运行Z预阶段。\n事先预处理深度值的目的，是将最终影像和同一深度缓冲的内容结果，在透视前获得。Z预阶段之后的Base Pass则是，参考预先得出的深度值缓冲进行Z预测试，因此通过在最终的画面里不留下像素痕迹（即编写后又被消去的像素），以回避像素着色器的运行。\nBase Pass\n使用Base Pass输出物体缓冲需要注意的两点：\n  不绘制没进入视线的对象\n这种\u0026quot;投影剔除\u0026rdquo;（Frustum Culling），一般是通过CPU端来处理；为了整体覆盖被称为\u0026quot;包围球\u0026rdquo;（Bounding sphere）的各个3D对象，对象是否在视野内的判定标准，是通过预先设定的包围球来实行的。\n 什么程度的剔除会成功，可以通过Stat初始视图（Stat InitViews）指令的\u0026quot;视锥体裁剪基元（Frustum Culled Primitives）\u0026ldquo;进行确认。\n   不计算多余的像素\n在图像处理的流程中，使用像素着色器实际处理前，会有运行深度测试（Z 测试）的\u0026quot;Pre Z 测试\u0026quot;这一步骤。从这里着手处理的像素，会因为被某个东西所遮挡而无法绘制出来，这时可以进行撤销处理。\n 但是，像半透明对象这种会伴随α测试的绘制、视差遮蔽映射这种像素着色器处理后会重新编写深度值的情况，就不进行Pre Z测试，而通过处理实行分路迂回。\n    UE4 绘制策略DrawingPolicy\n绘制策略在UE4渲染中使用很多， 中文也不好翻译。 其实就是根据策略 使用了哪些 着色器 。\n \u0026hellip;\u0026hellip;\u0026hellip;.\nUE4渲染一帧 渲染管道 首先，虚幻的渲染由三个线程共同完成。分别是CPU线程，DRAW线程，和GPU线程。\n知乎：https://zhuanlan.zhihu.com/p/57158725\nRender模块 调用Render()函数在Render模块RendererModule.h中，以下函数：\n1 2 3 4 5  class FRendererModule : public IRendererModule { // 开始渲染视图族  virtual void BeginRenderingViewFamily(FCanvas* Canvas,FSceneViewFamily* ViewFamily) override; }   ==谁最终调用了Render？==\n实时渲染流程图： part1:https://i.loli.net/2020/05/30/qU8vN2WZVbt9hkF.jpg\npart2:https://i.loli.net/2020/05/30/3trKVpOMU5sTQfB.jpg\n渲染函数Render 路径：Engine \\ Source \\ Runtime \\ Renderer \\ Private \\ DeferredShadingRenderer.cpp（660）\n函数：FDeferredShadingSceneRenderer :: Render（）渲染路径\n   全局系统纹理初始化 DeferredShadingRenderer.cpp（677） GSystemTextures.InitializeTextures（）     保护 必要的渲染目标您是否已确保可以保护的最大目标数目？ DeferredShadingRenderer.cpp（680） GSceneRenderTargets.Allocate（）   初始化每个视口 设置视口显示的对象，选择使用动态阴影时显示的对象，对半透明对象进行排序 DeferredShadingRenderer.cpp（683） InitViews()（）   FXSystem预处理 GPU粒子正在被仿真 DeferredShadingRenderer.cpp（758） FXSystem-\u0026gt; PreRender（）   启用Z Pre-Pass时执行的早期Z绘制 不绘制Tile渲染的硬件（移动设备，Android或iOS）对于 PC或PS4，将生成深度缓冲区和HiZ，因此后续绘制速度很快成为？ DeferredShadingRenderer.cpp（768） RenderPrePass（）   安全GBuffer DeferredShadingRenderer.cpp（774） GSceneRenderTargets.AllocGBufferTargets（）   透明光传播量 DeferredShadingRenderer.cpp（779） ClearLPVs（）   使用DBuffer时绘制延期贴图单击此处获取 DBuffer和延期贴图 DeferredShadingRenderer.cpp（796） GCompositionLighting.ProcessBeforeBasePass（）   如有必要，请 在绘制线框图时清除GBuffer透明颜色缓冲区， 有些游戏在发行游戏时无法清除GBuffer或屏幕。 DeferredShadingRenderer.cpp（805） SetAndClearViewGBuffer（） DeferredShadingRenderer.cpp（816） RHICmdList.Clear（）   渲染不透明的对象渲染 项目，这些项目根据它们是Masked还是Default，是否有LightMap等按每种排序顺序进行了精细分类 DeferredShadingRenderer.cpp（828） RenderBasePass（）   清除 GBuffer 的未绘制部分如果事先清除GBuffer，则不必要。 DeferredShadingRenderer.cpp（851） ClearGBufferAtMaxZ（）   绘制 自定义深度请参见此处以获取自定义深度 DeferredShadingRenderer.cpp（860） RenderCustomDepthPass（）   在这里再次模拟GPU粒子除了在这里 处理使用深度缓冲区执行碰撞检测的 粒子外，还对GPU粒子进行排序 DeferredShadingRenderer.cpp（865） 场景-\u0026gt; FXSystem-\u0026gt; PostRenderOpaque（）   为SceneDepthTexture创建一个半分辨率（每个方面为1/4分辨率）的缓冲区 DeferredShadingRenderer.cpp（875） UpdateDownsampledDepthSurface（）   执行阻塞测试 HZB的构建，执行提交 的HZB Attotempkinder的这篇文章指 DeferredShadingRenderer.cpp（881） BeginOcclusionTests（）   开始写 因为有点复杂，所以要写一些细节 DeferredShadingRenderer.cpp（890）   不使用DBuffer绘制延迟的贴图 CompositionLighting.cpp（293） AddDeferredDecalsBeforeLighting（）   在屏幕空间中绘制环境光遮挡 CompositionLighting.cpp（300） AddPostProcessingAmbientOcclusion（）   后期处理环境立方体贴图 CompositionLighting.cpp（305） AddPostProcessingAmbientCubemap（）   到这里为止的一系列处理 DeferredShadingRenderer.cpp（904） GCompositionLighting.ProcessAfterBasePass（）   透明的体积光缓冲液可提高透明度 DeferredShadingRenderer.cpp（908） ClearTranslucentVolumeLighting（）   从此处开始的主要照明设备 收集要绘制的灯光并将其排序 不要投影，不使用灯光功能的灯光将使用“ 基于图块” 绘制（如果可能）如果不能使用“ 基于图块”关于延迟渲染，这是味o，但请参见此处 LightRendering.cpp（312-348） LightRendering.cpp（423） RenderTiledDeferredLighting（） LightRendering.cpp（429） RenderSimpleLightsStandardDeferred（）   它不会阴影，也不会使用灯光功能，但是似乎无法使用TBDR绘制的灯光 被称为标准延迟灯光。 LightRendering.cpp（445） RenderLight（）   如果用于半透明的体积光是有效的，则将每个光注入到体积光中 ，从而在3D纹理上绘制光效果。 LightRendering.cpp（455） InjectTranslucentVolumeLightingArray（） LightRendering.cpp（461） InjectSimpleTranslucentVolumeLightingArray（）   使用灯光功能投射阴影的灯光将单独处理 LightRendering.cpp（468-552）   首先，我在投射阴影时 绘制了一个阴影贴图；在这里我还绘制了一个 半透明的阴影贴图；我记得半透明的当然是傅立叶不透明度贴图。 LightRendering.cpp（495） RenderTranslucentProjectedShadows（） LightRendering.cpp（497） RenderProjectedShadows（）   使用LPV时绘制反射阴影贴图 LightRendering.cpp（508） RenderReflectiveShadowMaps（）   灯光功能图 阴影指示器图 LightRendering.cpp（515） RenderLightFunction（） LightRendering.cpp（522） RenderPreviewShadowsIndicator（）   衰减缓冲器中的分辨 光的衰减信息是否曾经被吸入另一个缓冲器中？ LightRendering.cpp（534） GSceneRenderTargets.FinishRenderingLightAttenuation（）   注入体积光以获得半透明 LightRendering.cpp（541） InjectTranslucentVolumeLighting（）   这 是使用光功能投射阴影的光处理的结束。 LightRendering.cpp（550） RenderLight（）   这 是每个光的LPV 的主要注入照明过程的结尾 LightRendering.cpp（561-593） Lpv-\u0026gt; InjectLightDirect（）   注入体积光以实现环境立方体贴图的半透明 DeferredShadingRenderer.cpp（916） InjectAmbientCubemapTranslucentVolumeLighting（）   过滤体积光以获得半透明 DeferredShadingRenderer.cpp（919） FilterTranslucentVolumeLighting（）   LPV传输过程 此外，第921行的注释上写有“ copypimis”，例如“ Clear LPV buffer”。 DeferredShadingRenderer.cpp（924） PropagateLPVs（）   动态天光绘图 DeferredShadingRenderer.cpp（928） RenderDynamicSkyLighting（）   延迟的反射图形 捕获的反射图形而不是屏幕空间 DeferredShadingRenderer.cpp（931） RenderDeferredReflections（）   LPV的GI绘图 CompositionLighting.cpp（344） AddPostProcessingLpvIndirect（）   屏幕空间次表面散射（SSSSS）的后处理 CompositionLighting.cpp（347-376）   如果启用了“光轴”，则绘制“光轴遮挡” DeferredShadingRenderer.cpp（953） RenderLightShaftOcclusion（）   大气雾图 DeferredShadingRenderer.cpp（977） RenderAtmosphere（）   绘图雾 这是高度雾吗？ DeferredShadingRenderer.cpp（986） RenderFog（）   画一个半透明的物体 在这里也画一个单独的半透明的东西 DeferredShadingRenderer.cpp（1000） RenderTranslucency（）   折射变形处理 DeferredShadingRenderer.cpp（1008） RenderDistortion（）   光轴的起霜处理 DeferredShadingRenderer.cpp（1013） RenderLightShaftBloom（）   距离场AO处理不能在 当前不支持多个视口 的分屏游戏中使用吗？ DeferredShadingRenderer.cpp（1019） RenderDistanceFieldAOSurfaceCache（）   它只是在查看网格的“距离场”的可视化处理结果吗？ DeferredShadingRenderer.cpp（1024） RenderMeshDistanceFieldVisualization（）   由于速度模糊而绘制运动对象的速度 DeferredShadingRenderer.cpp（1034） RenderVelocities（）   从这里到最后的发布过程， 这也很复杂而且很长 DeferredShadingRenderer.cpp（1047） GPostProcessing.Process（）   使用BeforeTranslucency设置绘制后处理材料 PostProcessing.cpp（878） AddPostProcessMaterial（）   景深处理 通过高斯模糊进行DOF 处理之后，正在执行散焦处理（使用指定的光圈形状的纹理进行绘制）， 在此阶段似乎合并了单独的半透明缓冲区 PostProcessing.cpp（888） AddPostProcessDepthOfFieldGaussian（） PostProcessing.cpp（898） AddPostProcessDepthOfFieldBokeh（） PostProcessing.cpp（905） FRCPassPostProcessBokehDOFRecombine （如果未启用模糊）   使用BeforeTonemapping设置绘制后处理材料 PostProcessing.cpp（913） AddPostProcessMaterial（）   如果要使用TemporalAA ，请在此处绘制，如果使用FXAA，请稍后再绘制 PostProcessing.cpp（921） AddTemporalAA（） PostProcessing.cpp（928） AddTemporalAA（） （如果不使用速度缓冲区，请单击此处）   运动模糊处理 设置，分辨率下采样，高斯模糊，运动模糊绘制，组合处理 PostProcessing.cpp（932-994） FRCPassPostProcessMotionBlurSetup FRCPassPostProcessDownsample RenderGaussianBlur（） FRCPassPostProcessMotionBlur FRCPassPostProcessMotionBlurRecombine   SceneColor下采样 PostProcessing.cpp（1000） FRCPassPostProcessDownsample   直方图 PostProcessing.cpp（1006-1040） FRCPassPostProcessHistogram FRCPassPostProcessHistogramReduce   此处需要眼睛适应图直方图 PostProcessing.cpp（1046） AddPostProcessEyeAdaptation（）   布卢姆绘图 PostProcessing.cpp（1057） AddBloom（） PostProcessing.cpp（1060-1148） （对于移动设备，请单击此处）   色调映射 仅替换ReplacecingTonemapper设置工程图的一种后处理材料，但是 如果存在该材料，则执行默认色调映射 PostProcessing.cpp（1155） AddSinglePostProcessMaterial（） PostProcessing.cpp（1171） AddTonemapper（） （默认色调映射）   如果启用了FXAA，请在此处处理 PostProcessing.cpp（1177） AddPostProcessAA（）   绘制一些编辑器（如选定的轮廓）， 然后使用AfterTonemapping设置绘制后期处理材料 PostProcessing.cpp（1244） AddPostProcessMaterial（）   用于地下和GBuffer的可视化 调试 PostProcessing.cpp（1246-1254）   用于HMD的后处理 Oculus或Morpheus PostProcessing.cpp（1256-1277） FRCPassPostProcessHMD FRCPassPostProcessMorpheus   之后，调试和高分辨率屏幕截图功能等。 之后，进行后处理并结束！ 谢谢！ PostProcessing.cpp（1279-）    哦，很长。\n参考链接：\n  如何在C ++中从UTexture2D读取数据\n  https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1422920-casting-converting-frhitexture-to-utexture\n  Unreal渲染相关的缓冲区\n  https://qiita.com/mechamogera/items/a0c369a3b853a3042cae\n  https://answers.unrealengine.com/questions/17862/access-color-and-depth-buffer-of-each-frame.html\n  https://segmentfault.com/a/1190000012737548\n  Gbuff数据\n  渲染系统概述 图片\n  ","description":"","id":6,"section":"posts","tags":["C++","UE4","Game"],"title":"UE4渲染过程","uri":"https://vhope.cf/zh/posts/ue/ue4-render/"},{"content":"RSA算法 RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。\n 对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到当前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。\n 公钥/双密钥/非对称 加密 涉及到两个密钥的使用:\n 一个公钥, 可以被任何人知道，用于加密消息和验证签名 一个私钥, 只有接收方才知道，用于解密消息和创造签名  RSA实现过程 1. 公钥与私钥的产生 生成公钥e和私钥d的步骤如下：\n 随意选择两个大的质数$p$和$q$，$p$不等于$q$，计算$n=pq$。 根据欧拉函数，求$r = \\varphi (N) = \\varphi (p)\\varphi (q) = (p - 1)(q - 1)$ 选择一个小于$r$的整数$e$，使$e$与$r$互质。并求得$e$关于$r$的模反元素，命名为$d$(求$d$令$ed \\equiv 1(\\bmod ;r)$)。(模反元素存在，当且仅当$e$与$r$互质) 将$p$和$q$的记录销毁  经过上面四个步骤最终可以得到公钥$(n,e)$和私钥$(n,d)$。\n接收消息的人将自己的公钥$(n,e)$发送给发送消息的人,发送的人使用这个公钥加密信息发送给接收方，而接收方将私钥$(n,d)$保存起来用于解密。\n下面实现RSA类\n 参考资料：\n 米勒-拉宾素性检验 RSA加密算法 C++实现   实验步骤与结果 1.实现大整数类 因为该加密算法涉及的数可能很大，而C++中并没有像Java一样，内置大整数类BigInteger，故需自己实现，这里我参考了网上的一些资料设计了BigInteger类，实现了加减乘除以及模幂等运算，也实现了运算符重载，具体参考实现的方法如下：\n2. 设计RSA类 编写rsa.h头文件，定义RSA类，其中包含的成员以及成员函数如下：\n下面分别实现上述的各个方法\n首先要生成密钥对，即生成公钥和私钥，那么，我们首先需要生成两个大素数p和q,显然，素数是不可能是偶数的，故定义一个生成随机奇数的函数BigInteger createOddNum(unsigned len)参数为奇数的长度。\n使用16进制的随机字母，然后随机选取其中的len/4个得到一个随机的大奇数，只需要末尾那个数为奇数即可，最后返回BigInteger类型的奇数大整数，关键代码如下：\n然后定义一个生成素数的函数，其中用到米勒-拉宾素性检验算法判断生成的素数是否为素数素数：\n米勒-拉宾素性检测算法 基于以下定理：\n 费马小定理  要测试$N$是否为素数，首先将$N−1$分解为$2^{s}d$。在每次测试开始时，先随机选一个介于$[1,N−1]$的整数$a$，之后如果对所有的$r∈[0,s−1]$，若${a^d}\\bmod N \\ne 1$且${a^{{2^r}d}}\\bmod N \\ne - 1$，则$N$是合数。否则，$N$有$3/4$的概率为素数。\n关键代码如下：\n生成素数的逻辑就是首先使用函数createOddNum生成一个大奇数，然后调用isPrime判断是否为一个素数，是的话就可以return，不然继续寻找，知道生成一个素数。\n接下来计算n值，n值的计算很简单，直接使用$n = p * q$ 这个式子就能够计算出来；计算欧拉值也一样，可以使用$\\varphi(n) = (p-1) * (q-1)$得出。其中比较难的是生成的私钥d。\n下面定义一个RSA类的初始化函数init()​，生成p、q以及密钥对，如下：\n在创建公钥e和私钥d的函数createExponent(eul)中，首先创建一个比欧拉值小的公钥e，其中e为一个素数，直接调用函数createPrime()生成，然后使用大整数类中的求模逆元，即求出私钥d。\n扩展欧几里得算法  逆元\n逆元是模运算中的一个概念，我们通常说 A 是 B 模 C 的逆元，实际上是指 A * B = 1 mod C，也就是说 A 与 B 的乘积模 C 的余数为 1。可表示为 A = B^(-1) mod C。\n打个比方，7 模 11 的逆元，即：7^(-1) mod 11 = 8，这是因为 7 × 8 = 5 × 11 + 1，所以说 7 模 11 的逆元是 8。\n 扩展欧几里得算法是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式\n$$\nax{\\rm{ }} + {\\rm{ }}by{\\rm{ }} = {\\rm{ }}gcd\\left( {a,b} \\right).\n$$\n在RSA算法中求私钥中的整数d时，需要使得 (e * d ) % n = 1，该方程等价于 e * d = 1 + y * n （y为整数），也等价于 e * d - y * n = 1。\n因此求解d的过程就是求解该二元一次方程组（e和n已知，求解d），即求e模n的逆元。\n关键代码如下：\n我们知道，RSA的加密与解密其实就是一个模幂的运算，而这个模幂的运算已经在大整数类中实现了，如下：\n使用RSA类进行加密解密的函数只需要调用这个模幂运算即可，例如私钥加密可以这样调用：\n以上就设计完了RSA类的相关操作，主要是包括密钥的生成。下面将RSA加密解密的操作封装在一个类中。\n3. 设计加密解密类EncryptDecrypt 主要的方法及成员如下：\n实现RSA加密解密字符串 加密字符串的逻辑是，先将字符串以每两个字符 一组，转化为一个16进制数据序列，使用vector容器保存，之后调用rsa的公钥加密函数进行加密，如下是关键代码：\n解密函数其实是接受一个加密后的16进制序列，然后对这个序列调用RSA的私钥解密函数进行解密，然后得到解密后的16进制数据序列，最后还有一步就是需要将这个16进制序列最终转化为原来的字符串，只需要根据ascii码的数值即可得到，这里编写了一个hex2string函数，关键代码如下：\n实现效果\n首先显示密钥：\n加密字符串\n解密字符串\n实现RSA加密解密文件 实现RSA加密解密文件时基于RSA加密解密字符串实现的，其中主要的加密逻辑就是将一个文件看作是一行一行的字符串文本，没每读取一行，就调用加密字符串的函数进行加密，然后将加密得到的16进制序列写入到另外一个文件中，而这个文件也就是加密后的文件，主要关键代码如下：\n解密文件的函数稍微有点不一样，是从打开的待解密文件中循环读取每一个16进制数据，然后对每一个16进制数据调用解密函数得到解密后的16进制数据，将16进制数据转为字符串后再相继的写到另外一个文件中，即解密后的文件，关键代码如下：\n实现效果\n加密文件\n解密文件\n加密文件解密文件对比\n实现RSA数字签名及验证 实现数字签名方案，按照以下的流程图进行操作。\n首先需要对文件进行信息的摘要，得到Hash值，这里选择的Hash算法是SHA512算法，可以直接对文件进行信息摘要。\n可以直接include C++ 实现的\u0026quot;sha512.h\u0026quot;文件头，然后使用以下的语句就能够生成一个长度为512的Hash值，如下：\n可以在命令行输出文件的Hash摘要值如下:\n数字签名的实现类似字符串加密，对文件的hash值进行加密得到后面的16进制序列，然后将16进制序列伴随文件发送出去，签名的关键代码就是对hash值进行加密，如下：\n验证函数直接将16进制序列进行解密，然后还原成字符串再与收到的文件的hash值进行比较，如果相等，那么验证成功；否则验证失败，关键代码如下：\n实现效果\n数字签名\n验证数字签名\n","description":"","id":7,"section":"posts","tags":["rsa"],"title":"RSA加密算法","uri":"https://vhope.cf/zh/posts/rsa/"},{"content":"费马大定理在数学里有一个特殊的现象，即在于它是错误证明数量最多的数学题。\n费马小定理 费马小定理是数论中的一个定理：假如$a$是一个整数，$p$是一个质数，那么$a^{p}-a$是$p$的倍数，可以表示为\n$$\na^{p} \\equiv a \\pmod p\n$$\n当a不是p的倍数时也可以表示为\n$$\na^{p-1} \\equiv 1 \\pmod p\n$$\n 同余符号\n两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余\n记作$a \\equiv b\\pmod {m}$\n读作a同余于b模m，或读作a与b关于模m同余。\n比如$26 \\equiv 14 \\pmod{12}$\n 一种证明：\n考虑一根有 [公式] 颗珠子的项链，其每颗珠子有 [公式] 种染色选择，然后由下图蕴含的精神可得原命题成立。\n费马大定理 当整数$n\u0026gt;2$时，关于$x, y, z$的不定方程\n$$\nx^{n} + y^{n} = z^{n}\n$$\n没有整数解\n","description":"费马大定理、费马小定理","id":8,"section":"posts","tags":["费马"],"title":"费马🦓定理","uri":"https://vhope.cf/zh/posts/math/feima/"},{"content":"操作流程 用到的云产品及服务            序号 云产品 功能及用途 备注   1 容器镜像仓库 用于存放示例demo镜像    2 云编译 编译和打包实例demo代码，同时将镜像推送至容器镜像仓库    3 私有网络 创建用于Kubernetes集群，工作节点所需的VPC    4 Access Key 授权K8S集群访问京东智联云各个服务API的授权凭证。 例如：集群向京东智联云监控中心，推送业务监控数据就需要用到AK/SK。   5 Kubernetes集群 创建K8S集群，部署应用服务 规格：通用型1核4GB，公网IP 5Mpbs   6 云监控 查询业务监控数据，配置告警服务。     实操 第一步：准备Docker镜像 创建容器镜像仓库 新建注册表\n  登录京东智联云控制台，选择云服务-\u0026gt;弹性计算-\u0026gt;容器镜像仓库。\n  进入注册表页面，选择“华北-北京”地域，点击“新建”按钮，进入新建注册表页面。\n  在新建注册表页面，设置名称，勾选同意服务条款。点击“保存”按钮即可。\n  新建镜像仓库\n  切换至“镜像仓库”列表页面，选择地域“华北-北京”，点击“创建”按钮。\n  在新建镜像仓库页面， 选择刚新建的注册表，配置注册表名称信息\n  创建成功后，在镜像仓库里列表可以看到到仓库名称。以及镜像仓库的URI\n  编译构建Docker镜像 新建编译任务\n  选择云服务-\u0026gt;开发者工具-\u0026gt;云编译，进入云编译服务页面。\n  在任务列表页面，选择华北-北京地域， 点击“创建”按钮，选择中“创建任务”\n  在创建任务页面做如下配置：\n任务配置与源码配置如下，其中代码库地址为:https://code.jdcloud.com/jdcloud-monitor/prometheus-demo.git\n构建存放的配置如下：\n其他选项保持默认配置\n  点击“保存”按钮，完成任务的创建。\n  构建任务\n  选中刚创建的任务，点击操作了下的执行构建按钮。\n  在弹出的构建页面，配置如下信息,其中CommitID为ece523fc68cce1cd3d48b38fc07252f81ba2c44c\n  点击“确定”按钮，执行编译构建操作。当产物归档状态变为完成状态时，完成构建。\n  第二步：用K8S部署应用服务 前提准备 创建kubernetes进群时，需要用到VPC 和 密钥信息， 只需创建VPC即可，无需创建子网，工作节点组用到的子网会自己创建。\n创建VPC\n  选择云服务-\u0026gt;网络-\u0026gt;私有网络，进入私有网络VPC列表页面。\n  在私有网络页面，选中华北-北京地域，点击“创建”按钮。\n  配置网络名称，IPv4CIRD选择 192.168.0.0/16。\n  创建AK/SK密钥\n  点击顶部导航的账户名称，在弹出的下拉框中点击“Access Key管理”\n  在进入的Access Key管理页面中，点击“创建Access Key”，会提示输入短信验证码，输入完就可以创建了\n  创建Kubernetes集群   选择云服务-\u0026gt;弹性计算-\u0026gt; Kubernetes集群，进入集群列表页面。\n  选择“华北-北京”地域，点击“创建”按钮，在新建Kubernetes集群，进行如下配置\n集群信息配置\n网络与工作节点配置\n密码配置\n  部署服务 注册镜像仓库\n 本操作是将容器镜像仓库的注册表在K8S服务中进行注册，便于后续pod上部署应用服务。\n   选择云服务-\u0026gt;弹性计算-\u0026gt; 云主机，进入云主机列表页面。在云主机列表可以看到新创建了2台云主机实例。\n  找到k8s-***-nat-vm-***命名的云主机，其为K8S集群的管理节点云主机， 可以公网SSH远程登录进去。\n  获取集群凭据， 选择云服务-\u0026gt;弹性计算-\u0026gt; Kubernetes集群, 进入集群列表页面。选中刚创建的集群信息，点击名称，进入详情页面。切换至kubectl客户端配置页。\n  管理节点登录成功后，ssh 登录至 k8s-node-*** 节点的云主机（**命令： ssh root@your_node_ip, 需要将 your_node_ip 替换为你的node云主机的内网ip。点击回车后输入密码即可** ）。\n  配置kubectl客户端\n执行如下的命令\n1 2 3 4 5  mkdir -p $HOME/.kube cd $HOME/.kube vi config   将kubectl客户端配置的凭据，拷贝至config中，保存后退出。执行 sudo chown $(id -u):$(id -g) $HOME/.kube/config 命令。\n  执行以下操作命名，注册镜像仓库。\nkubectl create secret -n default docker-registry my-secret --docker-server=k8s-monitor-demo01-cn-north-1.jcr.service.jdcloud.com --docker-username=jdcloud --docker-password=Eoj3Ja4mSeXasAbX --docker-email=1427298682@qq.com 输入指令如下：\n  创建Pod\n  在kubernetes集群页面，菜单切换至Workloads-\u0026gt;Pod，进入Pod列表页面。点击创建pod\n  配置如下信息\na. 集群：请确认刚创建的集群，例如：monitor-demo\nb. Yaml 文件：将如下内容拷贝至黑色输入框，注意黄色标注内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:prometheus-demolabels:app:prometheus-demospec:imagePullSecrets:- name:my-secretcontainers:- name:flaskapp-demoimage:k8s-monitor-demo01-cn-north-1.jcr.service.jdcloud.com/k8s-monitor-demo-repo:job-ANbzZdjyyYKEBRX-1587872493ports:- containerPort:5000- containerPort:7777   注意：\n  name：为您注册镜像仓库创建的secret名称，示例用的my-secret。\n  image 标注为黄色的内容包含2个部分，URI:镜像版本，请一定要替换为自己镜像仓库的内容。可通过如下截图位置获取。\n     创建Pod  可以看到创建的pod，进入pod详情，切换至Container可以查看其运行状态，等待3分钟左右，其状态变为运行，服务部署成功。\n  配置访问策略 创建Service\n 注：基于K8S部署的应用服务，若需要外网访问，则需要创建一个负载均衡，同时绑定公网IP，以下步骤就是通过创建Service为服务配置一个负载均衡。\n   切换至service列表页面，选择“华北-北京”，点击“创建”按钮。\n  进入创建Service页面\n配置如下信息\na. 集群：确认选中的集群。\nb. Yaml：将如下信息拷贝至输入框中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  kind:ServiceapiVersion:v1metadata:name:prometheus-demoannotations:prometheus.io/path:/metricsprometheus.io/port:\u0026#39;7777\u0026#39;prometheus.io/scrape:\u0026#39;true\u0026#39;spec:ports:- protocol:TCPport:5000targetPort:5000selector:app:prometheus-demotype:LoadBalancer    点击“确定”按钮，完成service创建。点击名称，进入详情页面，可查看到pod状态为running。\n  点击顶部导航云服务-\u0026gt;网络-\u0026gt;负载均衡，进入应用负载均衡页面。可以看到刚新建的的LoadBalancer。\n  访问服务\n  在新建的负载均衡服务页面，获取到公网IP， 在浏览器端输入http://公网IP:5000，可看到如下界面。\n  第三步：业务监控告警 查看监控图   选择云服务-\u0026gt;监控与运维-\u0026gt; 云监控，进入云监控控制台。\n  在左侧菜单选中“自定义监控”，进入自定义监控页面。\n   输入以下查询条件，可以看到Demo示例内置采集的一些业务数据。查询条件如下：\n  配置告警   在上述查看的的监控图中，点击“配置报警”按钮，进入设置告警页面，进行如下配置：\n基本信息配置\n触发条件配置\n通知策略配置\n  上面配置完之后当访问页面次数超过10此的时候就会有邮件和短信的通知\n邮件\n短信\n","description":"","id":9,"section":"posts","tags":["云计算","京东云"],"title":"使用云监控管理k8s-京东云实践","uri":"https://vhope.cf/zh/posts/cloud/cloud-kubernetes/"},{"content":"[toc]\n1. 鲲鹏云服务 鲲鹏处理器与服务器 鲲鹏处理器 华为鲲鹏处理器是华为自主研发的基于ARM架构的企业级系列处理器产品，包含“算、存、传、管、智”五个产品系统体系。\n架构介绍： 华为鲲鹏处理器基于ARM架构。ARM是一种CPU架构，有别于Intel、AMD CPU采用的CISC复杂指令集，ARM CPU采用RISC精简指令集（reduced instruction set computer，精简指令集计算机）。\n处理器对比：\n优点：  采用ARM架构，同样功能性能占用的芯片面积小、功耗低、集成度更高，更多的硬件CPU核具备更好的并发性能。 支持16位、32位、64位多种指令集，能很好的兼容从IOT、终端到云端的各类应用场景。 大量使用寄存器，大多数数据操作都在寄存器中完成，指令执行速度更快。 采用RISC指令集，指令长度固定，寻址方式灵活简单，执行效率高。  规格发展 华为鲲鹏920处理器规格 技术创新 内置多种加速引擎 Taishan服务器 系列 TaiShan 200机架服务器全景图 TaiShan 200高密服务器 云服务 云计算 美国国家标准与技术研究院（NIST）定义：\n云计算是一种模型，它可以实现随时随地，便捷地，随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用、及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。\n云计算的特点:\n 快捷的网络访问 自服务和随需分配 资源池 灵活有弹性 服务可度量  云计算的本质就是自动化和规模化在IT行业的服务化体现！  云服务实例 而云服务正是由于云计算的发展而孕育而生,主要依靠云计算的虚拟化技术.将所有的硬件资源进行计算虚拟化和存储虚拟化,最后得到我们的云服务.\n一个简单的网站例子可以是下面这张图:\n计算类云服务 计算类云服务有如下这么多种:\nECS-(弹性云主机) 弹性云服务器（ Elastic Cloud Server ）是一种可随时自助获取、可弹性伸缩的云服务器，帮助用户打造可靠、安全、灵活、高效的应用环境，确保服务持久稳定运行，提升运营效率。\n需要注意的是,ECS一般要配合硬盘系统盘、数据盘以及VPC等组件进行使用.  如下是一个简单的多态ECS服务器的拓扑图:\nBMS裸金属服务器 弹性裸金属服务器(Bare Metal Server)服务, 为用户提供专属的物理服务器，提供卓越的计算性能，满足核心应用场景对高性能及稳定性的需求，结合了传统托管服务器带来的稳定性能与云中资源高度弹性的优势。\n这个云服务的应用场景主要针对部署在物理机上的场景.\n规格和场景：\n 自带SDI卡，实现无系统盘挂载的技术。\n IMS镜像服务 镜像是由基础操作系统、预装的公共应用以及用户私有应用组成的模板，便于用户批量发放弹性云主机或裸金属服务器。\n有了镜像之后,就相当于有了一个当前系统的备份,可以复制到其他云服务器上,减少配置的时耗.  镜像服务提供镜像生命周期管理能力。用户可以通过服务器或外部文件创建系统盘镜像或数据盘镜像，也可以使用弹性云服务器或云服务器备份创建带数据盘的整机镜像。并对镜像进行修改，共享，加密，复制，导出，标签管理，企业多项目管理，发布市场镜像等操作。\nAS弹性伸缩服务 弹性伸缩（Auto Scaling）可根据用户的业务需求和预设策略，自动调整计算资源或弹性IP资源，使云服务器数量或弹性IP带宽自动随业务负载增长而增加，随业务负载降低而减少，节省云上业务资费，保证业务平稳健康运行.\n应用场景主要有:\n 企业网站、电商、移动应用等，业务特点：业务请求有突发式暴增或者访问量起伏不定 视频网站、媒体编解码应用、媒体内容回传应用、高流量内容管理系统、分布式高速缓存系统,业务特点:需要根据计算量动态调整计算、网络等资源  AS服务一般配合负载均衡(ELB)一起使用,例如:\n AS系统架构如下:\n云容器服务 CCE(云容器引擎)\n云容器引擎（Cloud Container Engine，简称CCE）提供高度可扩展的、高性能的企业级Kubernetes集群，支持运行Docker容器。借助云容器引擎，您可以在云上轻松部署、管理和扩展容器化应用程序。\n实用实例：\n优点：\n 多平台混合部署 跨云管理 一键式交付 高性能  CCI(云容器实例)\n云容器实例（Cloud Container Instance， CCI）服务提供 Serverless Container（无服务器容器）引擎，让您无需创建和管理服务器集群即可直接运行容器。\n使用云容器实例\n优点\n 免运维 高安全 极致性能 秒级付费 开放生态 极速弹性  云容器特性\n服务总览\n存储类云服务 存储类云服务主要分为如下三种:\n云硬盘EVS 云硬盘（Elastic Volume Service）是一种为ECS、BMS等计算服务提供持久性块存储的服务，通过数据冗余和缓存加速等多项技术，提供高可用性和持久性，以及稳定的低时延性能。您可以对云硬盘做格式化、创建文件系统等操作，并对数据做持久化存储。云硬盘提供多种性能规格，用户可以根据不同业务场景按需、灵活配置。\n使用图解:\n相当于在云上的硬盘.\n对象存储服务OBS 对象存储服务（OBS）是一个基于对象的海量存储服务，为您提供海量、低成本、高可靠、安全的数据存储能力。\n图解如下:\n弹性文件服务SFS和SFS 弹性文件服务（Scalable File Service）为用户的弹性云服务器（ECS）提供一个完全托管的共享文件存储，符合标准文件协议（NFS），能够弹性伸缩至PB规模（SFS Turbo最大320TB），具备可扩展的性能，为海量数据、高带宽型应用提供有力支持。\n云备份服务 最简单的备份服务，可将云服务器数据恢复到任意备份点,例如:\nSDRS 存储容灾服务 存储容灾服务（Storage Disaster Recovery Service，简称SDRS）是一种服务化容灾方案，可大幅降低企业容灾TCO。通过简单三步操作（创建保护组、创建保护实例、开启保护）即可为云上虚拟机提供跨可用区级别的容灾保护，确保数据零丢失（RPO=0），并可在灾难发生时迅速恢复业务，减少损失。\n简单例子:\n网络类云服务 主要有如下几种:\nVPC虚拟私有云服务 虚拟私有云（Virtual Private Cloud): 用户在华为云上申请的隔离的、私密的虚拟网络环境。用户可以自由配置VPC内的IP地址段、子网、安全组等子服务，也可以申请弹性公网IP和带宽搭建面向Internet的业务系统。\n主要包括如下四个方向内容:\n弹性公网IP 弹性公网IP（Elastic IP）提供独立的公网IP资源，包括公网IP地址与公网出口带宽服务。可以与弹性云服务器、裸金属服务器、虚拟IP、弹性负载均衡、NAT网关等资源灵活地绑定及解绑。\n 简单来说,就是外界可以访问的ip地址.并且是其他功能的依赖.\n 使用模型：\nNAT网关服务 NAT网关（NAT Gateway）能够为VPC内的弹性云服务器提供SNAT和DNAT功能，通过灵活简易的配置，即可轻松构建VPC的公网出入口\n SNAT和DNAT分别为源地址转换和目的地址转换。\nSNAT架构：\nDNAT架构：\n 使用NAT这个功能主要是为了节省弹性公网IP资源并且避免云主机IP直接暴露在公网上。\n虚拟专用网络 VPN 虚拟专用网络（Virtual Private Network）用于搭建用户本地数据中心与华为云VPC之间便捷、灵活，即开即用的IPsec加密连接通道，实现灵活一体，可伸缩的混合云计算环境\n 主要面向的是企业用户。\n 满足需求：\n 混合云部署 跨地域VPC 互联  云专线 DC 云专线（Direct Connect）用于搭建用户本地数据中心与华为云VPC之间高速、低时延、稳定安全的专属连接通道，充分利用华为云服务优势的同时，继续使用现有的IT设施，实现灵活一体，可伸缩的混合云计算环境\n应用场景：\n 混合云部署 异地容灾  弹性负载均衡服务ELB 弹性负载均衡（Elastic Load Balance，简称ELB）是将访问流量根据转发策略分发到后端多台弹性云服务器的流量分发控制服务。弹性负载均衡可以通过流量分发扩展应用系统对外的服务能力，提高应用程序的容错能力。\n简单来说，ELB就是用来处理多用户连接时候的资源缺乏的，临时制造多个副本来缓解压力。应用场景有：大型门户网站、跨可用区同城容灾、电商抢购。\nPPT  2. 鲲鹏应用移植 两种语言 1. 编译型语言 2. 解释型语言 策略 迁移过程 迁移工具 华为鲲鹏代码迁移工具主要面向鲲鹏平台的开发者、用户和第三方待移植软件提供方开发工程师，用来分析待移植软件源码文件，并给出代码移植指导报告，同时能够自动分析出需修改的代码内容，并指导如何修改，帮助用户顺利完成应用从x86平台向鲲鹏平台的移植。\n逻辑架构 容器迁移 容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。\n容器与虚拟机的不同 前提 跨平台的容器无法运行，会出现格式错误\n x86平台获取的镜像是适用于x86平台，当迁移到鲲鹏平台，容器无法执行。 在基于ARM的平台中，docker pull方式或者Dockerfile方式获取或者构建的镜像均为基于ARM平台的，同样也无法在x86上运行。  容器迁移的原理 迁移容器同时涉及到两个操作，备份和恢复。我们可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，首先我们将把容器备份为Docker镜像快照。然后，该Docker镜像或者是被推送到了Docker注册中心，或者被作为tar包文件保存到了本地。如果我们将镜像推送到了Docker注册中心，我们简单地从任何我们想要的机器上使用 docker run 命令来恢复并运行该容器，或者通过docker pull命令拉取我们想要的镜像。\n迁移策略 Docker容器迁移有两种策略：使用Docker pull获取镜像或使用Dockerfile构建镜像。\n主要流程  Docker安装 Docker构建基础镜像 Dockerfile创建应用镜像 验证应用镜像  性能调优 性能调优就是对计算机硬件、操作系统和应用程序有相当深入的了解，调节三者之间的关系，实现整个系统（包括硬件、操作系统、应用程序）的性能最大化，并能不断地满足现有的业务需求。\n华为鲲鹏性能优化工具 为解决客户软件运行遇到性能问题时凭人工经验定位困难、调优能力弱的痛点，华为推出了Kunpeng Tuning Kit鲲鹏性能优化工具。\n华为鲲鹏性能优化工具主要面向华为FAE、开放实验室能力建设工程师或客户工程师，针对应用程序部署在TaiShan服务器的场景下，通过收集服务器的处理器硬件、操作系统、进程/线程、函数等各层次的性能数据，分析出系统性能指标，定位到瓶颈点及热点函数。\n华为鲲鹏性能优化工具功能特性  支持采集整个系统或指定进程的CPU Cycles性能事件，能够快速定位热点函数。 支持热点函数按照CPU核/线程/模块进行分组，支持查看热点函数调用栈。 支持通过火焰图查看热点函数及其调用栈。 支持代码映射功能，即查看函数内的热点指令及该指令对应的高级语言文件及行号。 支持显示汇编代码的控制流图。 支持分析Java代码的热点函数及热点指令。  华为鲲鹏性能优化工具逻辑架构 主要分为Analysis和Agent两个模块。\n子模块 Analysis子模块\nAgent子模块\n部署方式 当前版本只支持单机部署，即将华为鲲鹏性能优化工具所有组件部署在一台服务器上，完成对该台服务器软件的性能数据采集和分析。\n如以下示例图：\n 部署环境要求如下表所示：\n 部署后访问方式  华为鲲鹏性能优化工具部署在TaiShan服务器上，该服务器上同时运行客户的应用软件。 华为鲲鹏性能优化工具提供Web界面访问方式，用户只需要在浏览器地址栏中输入：https:// 部署服务器的IP:端口号 即可。  访问Web界面时，对本地浏览器的要求如下表所示。\n优化工具业务流程 C/C++程序性能分析和优化 Java Mixed-Mode程序性能分析和优化 3. 容灾备份安全 云架构 基础架构：\n安全架构：\n企业主机安全（HSS） 企业主机安全（Host Security Service）是提升主机整体安全性的服务，包括账户破解防护、弱口令检测、恶意程序检测、双因子认证、漏洞管理，网页防篡改等功能，帮助企业构建服务器安全防护体系，降低当前服务器面临的主要安全风险\nWAF：最常用最有效的防护方案 Web应用防火墙（Web Application Firewall）对网站业务流量进行多维度检测和防护，结合深度机器学习智能识别恶意请求特征和防御未知威胁，阻挡诸如SQL注入或跨站脚本等常见攻击，避免这些攻击影响Web应用程序的可用性、安全性或过度消耗资源，降低数据被篡改、失窃的风险\nDBSS-数据库安全服务 数据库安全服务（Database Security Service）是一个智能的数据库安全防护服务，基于反向代理及机器学习机制，提供敏感数据发现、数据脱敏、数据库审计和防注入攻击等功能，保障云上数据库的安全\nCBH-云堡垒机：云运维审计的瑞士军刀 云堡垒机（Cloud Bastion Host）开箱即用，包含主机管理、权限控制、运维审计、安全合规等功能，支持Chrome等主流浏览器随时随地远程运维，开启高效运维新时代。\n案例 容灾备份 系统可靠性设计之高可用、双活、容灾、备份 容灾指标 RTO： RTO (Recovery Time Objectives)，关键业务功能（CBF）从中断点恢复到其最低业务连续目标（MBCO）所能承受的最大时间，从而使中断对业务所带领的冲击最小化。\nRPO： RPO (Recovery Point Objectives)，灾难恢复中的恢复时间点目标，指业务可接受的、灾难发生后，系统和数据从灾难发生时间点到可恢复至灾难前的时间点的目标。\nMBCO MBCO（Minimum Business Continuity Objectives），在突发事件、紧急状态、或灾难发生期间，企业为完成其业务目标所能接受的最低服务及生产水平。\n  标准 容灾方案 混合云容灾整体方案 4. GaussDB 5. 大数据 算存分离 解决方案 项目:个人同步网盘\n","description":"","id":10,"section":"talks","tags":["云计算"],"title":"鲲鹏Learning🏸","uri":"https://vhope.cf/zh/talks/kubpeng_exercise/"},{"content":"C++学习路线🌱 hode on!💠\n","description":"","id":11,"section":"talks","tags":["C++"],"title":"C++学习路线","uri":"https://vhope.cf/zh/talks/cpp_router/"},{"content":"| 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。\ngrep Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。\n语法 grep [选项] 查找内容 源文件 选项参数   -a --text #不要忽略二进制的数据。\n  -A\u0026lt;显示行数\u0026gt; --after-context=\u0026lt;显示行数\u0026gt; #除了显示符合范本样式的那一列之外，并显示该行之后的内容。\n  -b  --byte-offset  #在显示符合样式的那一行之前，标示出该行第一个字符的编号。⭐\n  -B\u0026lt;显示行数\u0026gt; --before-context=\u0026lt;显示行数\u0026gt; #除了显示符合样式的那一行之外，并显示该行之前的内容。\n  -c --count #计算符合样式的列数。⭐\n  -C\u0026lt;显示行数\u0026gt; --context=\u0026lt;显示行数\u0026gt;或-\u0026lt;显示行数\u0026gt; #除了显示符合样式的那一行之外，并显示该行之前后的内容。\n  -d \u0026lt;动作\u0026gt; --directories=\u0026lt;动作\u0026gt; #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。⭐\n  -e\u0026lt;范本样式\u0026gt; --regexp=\u0026lt;范本样式\u0026gt; #指定字符串做为查找文件内容的样式。\n  -E --extended-regexp #将样式为延伸的普通表示法来使用。\n  -f\u0026lt;规则文件\u0026gt; --file=\u0026lt;规则文件\u0026gt; #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。\n  -F --fixed-regexp #将样式视为固定字符串的列表。\n  -G --basic-regexp #将样式视为普通的表示法来使用。\n  -h --no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称。\n  -H --with-filename  #在显示符合样式的那一行之前，表示该行所属的文件名称。\n  -i --ignore-case  #忽略字符大小写的差别。⭐\n  -l --file-with-matches #列出文件内容符合指定的样式的文件名称。\n  -L --files-without-match #列出文件内容不符合指定的样式的文件名称。\n  -n --line-number #在显示符合样式的那一行之前，标示出该行的列数编号。\n  -q --quiet或--silent #不显示任何信息。\n  -r --recursive #此参数的效果和指定“-d recurse”参数相同。\n  -s --no-messages #不显示错误信息。\n  -v --revert-match #显示不包含匹配文本的所有行。\n  -V --version #显示版本信息。\n  -w --word-regexp #只显示全字符合的列。\n  -x --line-regexp #只显示全列符合的列。\n  -y #此参数的效果和指定“-i”参数相同。\n   其中标⭐号的为比较常实用的\n 查找内容规则 查找内容的规则与正则表达式大同小异。\n  ^ #锚定行的开始 如：\u0026lsquo;^grep'匹配所有以grep开头的行。\n  $ #锚定行的结束 如：\u0026lsquo;grep$'匹配所有以grep结尾的行。\n  . #匹配一个非换行符的字符 如：\u0026lsquo;gr.p'匹配gr后接一个任意字符，然后是p。\n  *#匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。\n  .* #一起用代表任意字符。\n  [] #匹配一个指定范围内的字符，如\u0026rsquo;[Gg]rep'匹配Grep和grep。\n  [^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。\n  \\(..\\) #标记匹配字符，如\u0026rsquo;(love)'，love被标记为1。\n  \\\u0026lt; #锚定单词的开始，如:'\u0026lt;grep'匹配包含以grep开头的单词的行。\n  \\\u0026gt; #锚定单词的结束，如\u0026rsquo;grep\u0026gt;'匹配包含以grep结尾的单词的行。\n  x\\{m\\} #重复字符x，m次，如：\u0026lsquo;0{5}\u0026lsquo;匹配包含5个o的行。\n  x\\{m,\\}  #重复字符x,至少m次，如：\u0026lsquo;o{5,}\u0026lsquo;匹配至少有5个o的行。\n  x\\{m,n\\} #重复字符x，至少m次，不多于n次，如：\u0026lsquo;o{5,10}\u0026lsquo;匹配5\u0026ndash;10个o的行。\n  \\w  #匹配文字和数字字符，也就是[A-Za-z0-9]，如：\u0026lsquo;G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。\n  \\W  #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。\n  \\b  #单词锁定符，如: \u0026lsquo;\\bgrep\\b'只匹配grep。\n  在/etc/profile文件中查找关键字CLASS_PATH所在位置\n查询ssh相关进程\n压缩解压类命令 gzip/gunzip gzip用于压缩文件，gunzip用于解压\n语法：\ngzip文件名（功能描述：压缩文件，只能将文件压缩为*.gz文件）\ngunzip 文件名(.gz结尾)：(功能描述：解压缩文件命令）\n压缩b.txt文件\n解压b.txt.gz压缩文件\nzip/unzip zip用于压缩文件，unzip用于解压的，这个在项目打包发布中很有用的.\n语法：\nzip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）\nunzip [选项] XXX.zip (功能描述：解压缩文件）\n加密a.txt文件\n解密a.zip文件\ntar tar指令是打包指令，最后打包后的文件可以是.tar.gz的文件。\n语法：\ntar [选项] XXX.tar.gz 打包的内容（功能描述：打包目录，压缩后的文件格式tar.gz)\n选项参数：\n  -A 新增压缩文件到已存在的压缩\n  -B 设置区块大小\n  -c 建立新的压缩文件\n  -d 记录文件的差别\n  -r 添加文件到已经压缩的文件\n  -u 添加改变了和现有的文件到已经存在的压缩文件\n  -x 从压缩的文件中提取文件\n  -t 显示压缩文件的内容\n  -z 支持gzip解压文件\n  -j 支持bzip2解压文件\n  -Z 支持compress解压文件\n  -v 显示操作过程\n  -l 文件系统边界设置\n  -k 保留原有文件不覆盖\n  -m 保留文件不被覆盖\n  -W 确认压缩文件的正确性\n  可选参数如下：\n  -b 设置区块数目\n  -C 切换到指定目录\n  -f 指定压缩文件\n  --help 显示帮助信息\n  --version 显示版本信息\n  实例：\n打包/victor文件夹下所有内容，打包后的文件名为victor.tar\n解压victor.tar文件\n打包文件夹/victor并且压缩成data.tar.gz\n将多个文件压缩成a.tar.gz\n将a.tar.gz解压到当前目录\n解压到文件夹/a(文件夹必须存在，不然报错)\n![](https://i.loli.net/2020/04/16/xALa9JldzXuBjRi.png\n https://www.cnblogs.com/peida/archive/2012/12/17/2821195.html https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html https://www.cnblogs.com/peida/archive/2012/12/06/2804323.html ","description":"","id":12,"section":"posts","tags":["Linux","grep","tar","gzip"],"title":"Linux实用指令","uri":"https://vhope.cf/zh/posts/linux-grep/"},{"content":"每一个用户都是一个个体，每一个个体都属于一个群组，而每一个群组又有区别!\n——Users\n Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n 添加用户 基本语法 useradd [选项] 用户名 实操 输入以下命令之后创建一个用户victor\n这里我们选项参数什么也没有写，此时会默认在/home目录下创建一个/victor的文件夹用于保存用户victor用户的数据信息。\n当然我们可以指定参数：\n用参数 -d 目录指定用户信息存储的目录，使用命令useradd -d /home/test tom创建用户tom。\n使用-g 用户组指定将当前创建的用户添加到指定的用户组，使用命令useradd -g root wjh将新建用户wjh添加到root用户组。\n给用户设置密码 基本语法 passwd 用户名 实操 给用户victor设置密码(默认密码是不会显示出来的)\n下面可以使用victor这个用户登陆\n默认是不能访问root用户的文件的，因为不在同一个组\n切换用户 基本语法 su - 切换用户名 实操 切换到root。其中低权限用户切换到高权限用户需要输入密码。\n退出切换使用exit删除用户 基本语法 userdel [选项] 用户名 其中选项参数可以添加-r，表示删除用户时同时删除保存用户的文件夹。\n实操 删除用户tom\n可以看到之前tom致电给创建的文件夹test并没有删除。\n 注意，删除用户必须要root权限，不然删除不了。\n 删除用户victor，同时删除其文件夹，victor文件夹消失了\n其他操作 查询用户信息 语法\nid 用户名 如下查询用户root的信息\nroot用户的用户id为0，组id为0，组为0\n查询当前用户 语法\nwhoami 用户组  类似于角色，系统可以对有共性的多个用户进行统一的管理。\n 用户组关系图：\n增加组 语法\ngroupadd 组名 增加用户组test\n删除组 语法\ngroupdel 组名 删除用户组test\n修改用户的组 语法\nusermod -g 用户组 用户名 相关配置文件  用户信息文件：/etc/passwd 密码文件： /etc/shadow 用户组文件：/etc/group 用户组密码文件： /etc/gshadow 用户配置文件：\n/etc/login.defs\n/etc/default/useradd 新用户信息文件：/etc/skel 登录信息：/etc/motd  /etc/passwd 每一行内容存放一个用户的信息，每个用户信息有7部分组成\nroot​：x:0:0:root:/root:/bin/bash\nroot 用户名 用户登录系统时使用的用户名\nx 密码 密码位\n2 UID 用户标识号\n2 GID 缺省组标识\nroot 注释性描述 例如存放用户全名等信息\n/root 宿主目录 用户登录系统后的缺省目录\n/bin/bash 命令解释器 用户使用的Shell ,默认为bash\n UID分类\n超级用户：（root UID=0）\n普通用户： （UID 500~60000）\n伪用户： （UID 1~499）\n什么是伪用户?\n 伪用户与系统和程序服务相关  bin、daemon、shutdown、halt等，任何Linux系统默认都有这些伪用户。\nmail、news、games、apache、ftp、mysql及sshd等，与linux系统的进程相关。\n 伪用户通常不需要或无法登录系统\n  可以没有宿主目录\n   /etc/shadow 每行的含义： 登录名: 加密口令: 最后一次修改时间: 最小时间间隔: 最大时间间隔:警告时间: 不活动时间: 失效时间:标志\n/etc/group 每行含义： 组名: 口令: 组标识号: 组内用户列表\n https://www.cnblogs.com/qmfsun/p/3674024.html linux用户管理命令 ","description":"","id":13,"section":"posts","tags":["Linux","用户管理"],"title":"Linux用户管理","uri":"https://vhope.cf/zh/posts/linux-users/"},{"content":"在大学时代，Vim 的大名就已如雷贯耳，但由于它陡峭的学习曲线，一直望而却步。等真正开始学习之后，发现并没有想象中的复杂，也没有所谓的瓶颈，只要在实际写代码中强迫自己使用就可以了，无形中就会形成习惯。\n​\t——GeekPlux\n三种模式 正常模式 以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。正常模式可以使用快捷键。\n编辑模式 按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可.\n命令行模式 在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的。\n vi 和vim模式的相互切换\n 常用快捷键  使用快捷键在正常模式下输入！\n 复制粘贴 拷贝当前行输入yy，然后再按下p键的时候就可以粘贴了。\n复制多行可以输入nyy，其中n为一个数字，例如5yy，即复制当前行向下的5行，同样粘贴也是按p键。\n删除 删除当前行输入dd\n删除多行输入ndd，表示删除当前行向下的n行。\n查找单词 再正常模式下输入/关键字即可查找关键字所在的位置，例如/hello为查找hello这个单词所有的所在位置，输入 n 就是查找下一个。\n设置文件行号 有时候为了看文档更清楚，想要知道每一行的行数，可以先进入命令模式，在输入set nu，即再正常模式下输入:set nu,然后回车。\n取消行号可以输入:set nonu\n移动到底部到首部 有时候需要直接看文档的末尾，可以输入G移动到文件末行。\n而移动到首行则是输入gg，然后回车即可。\n撤销 取消上一次做的操作，输入u。表示undo。\n移动到某行 假如我们要移动到第20行，我们可以这样输入：20 + shift + g\n更多快捷键可以参考：https://zhuanlan.zhihu.com/p/77283813\nVim键盘图\n思维导图：\n","description":"","id":14,"section":"posts","tags":["Linux","Vim"],"title":"Linux编辑利器-Vim","uri":"https://vhope.cf/zh/posts/linux/vim-use/"},{"content":"问题描述 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n输入: \u0026quot;babad\u0026quot; 输出: \u0026quot;bab\u0026quot; 注意: \u0026quot;aba\u0026quot; 也是一个有效答案。 示例 2：\n输入: \u0026quot;cbbd\u0026quot; 输出: \u0026quot;bb\u0026quot; 解答 使用动态规划，把原来的字符串倒置，然后找最长的公共子串就可以了。例如 S = \u0026ldquo;caba\u0026rdquo; ，S = \u0026ldquo;abac\u0026rdquo;，最长公共子串是 \u0026ldquo;aba\u0026rdquo;，所以原字符串的最长回文串就是 \u0026ldquo;aba\u0026rdquo;。其中求最大公共子串就是使用动态规划的方法。\n示意图：\n 当S[i]==S[j]时，矩阵arr[i][j]=arr[i-1][j-1]+1；特殊情况i、j为0时arr[i][j]=1 其他情况跳过。   另外，还需要考虑最长公共子串不是回文的情况，只需要判断翻转前后的末尾字符下标是否一样即可，比如 S=\u0026quot;caba\u0026rdquo;，S'=\u0026quot;abac\u0026rdquo; ，S’ 中 aba 的下标是 0 1 2 ，倒置前是 3 2 1，和 S 中 aba 的下标符合，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。\n 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;class Solution { public: string longestPalindrome(string s) { //暴力法  int len = s.length(); if (len \u0026lt;= 1) return s; std::string r; std::string real = s; reverse(s.begin(), s.end()); std::string reverse = s; int arr[len][len]; for (int i = 0; i \u0026lt; len; ++i) for (int j = 0; j \u0026lt; len; ++j) arr[i][j] = 0; int maxLen(0), maxEnd(0); for (int i = 0; i \u0026lt; len; ++i) { for (int j = 0; j \u0026lt; len; ++j) { if (real[i] == reverse[j]) { if (i == 0 || j == 0) arr[i][j] = 1; else { arr[i][j] = arr[i - 1][j - 1] + 1; } } if (arr[i][j] \u0026gt; maxLen) { int beforeindex = len - 1 - j; if ((beforeindex + arr[i][j] - 1) == i) { maxLen = arr[i][j]; maxEnd = i; } } } } return real.substr(maxEnd - maxLen + 1, maxLen); } };   结果： ","description":"","id":15,"section":"posts","tags":["C++","leetcode"],"title":"Leetcode-最长回文子串","uri":"https://vhope.cf/zh/posts/leetcode-0/"},{"content":"Linux基本操作。🤠\nLinux 目录结构及解释 查看命令行执行完位置：\n1  echo $BASH   命令记录 mkdir mkdir命令 用来创建目录。\n语法：mkdir (选项)(参数)\n 主要选项：\n-m\u0026lt;目标属性\u0026gt;或\u0026ndash;mode\u0026lt;目标属性\u0026gt;建立目录的同时设置目录的权限；\n-p或\u0026ndash;parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；\n参数：\n指定要创建的目录列表，多个目录之间用空格隔开。\n 创建多层目录：\n1  mkdir a/b/c/d   chmod chmod命令用来变更文件或目录的权限。\n语法：chmod(选项)(参数)\n权限范围的表示法如下：\nu User，即文件或目录的拥有者；\ng Group，即文件或目录的所属群组；\no Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；\na All，即全部的用户，包含拥有者，所属群组以及其他用户；\nr 读取权限，数字代号为“4”;\nw 写入权限，数字代号为“2”；\nx 执行或切换权限，数字代号为“1”；\n- 不具任何权限，数字代号为“0”；\ns 特殊功能说明：变更文件或目录的权限。\n例子：\n1 2 3 4  chmod u+x,g+w f01　//为文件f01设置自己可以执行，组员可以写入的权限 chmod u=rwx,g=rw,o=r f01 chmod 764 f01 chmod a+x f01　//对文件f01的u,g,o都设置可执行属性   可以输入命令ll -d 文件名查看文件的权限：\nlinux文件的用户权限的分析图\n例：rwx　rw-　r\u0026ndash;\nr=读取属性　//值＝4\nw=写入属性　//值＝2\nx=执行属性　//值＝1\n对demo.sh执行chmod a+x demo.sh之后，查看其权限，三个组都含x，表示所有用户都能执行：\nShell脚本 shell脚本一般以.sh结尾。如demo.sh：\n1 2 3  #!/bin/bash #This is my First shell echo \u0026#34;Hello World!\u0026#34;    第一行表示脚本的位置\n第二行为注释\n第三行为脚本的命令\n 如何执行？在Linux下需要先赋予权限\n1  chmod o+x demo.sh   执行\n1  ./demo.sh   常见的变量\n$0当前程序的名称\n$n当前程序的第 n 个参数,n=1,2,…9\n$* 当前程序的所有参数(不包括程序本身)\n$# 当前程序的参数个数(不包括程序本身)\n$? 命令或程序执行完后的状态，一般返回 0 表示执行成功。\n$UID 当前用户的 ID\n$PWD 当前所在的目录\nIf 条件判断语句 格式：\n1 2 3 4 5  if (表达式) #if ( Variable in Array ) 语句 1 else 语句 2 fi   例：\n1 2 3 4 5  #!/bin/sh NUM=100 if (( $NUM \u0026gt; 4 )) ;then echo “this num is $NUM greater 4 !” fi   参考：\n https://wangchujiang.com/linux-command/ ","description":"","id":16,"section":"posts","tags":["Linux","Shell","bash"],"title":"Linux命令与Shell","uri":"https://vhope.cf/zh/posts/linux/linux-shell/"},{"content":"Docker是基于内核的容器,可以运行在宿主机上,看作是一个容器.\nDocker🐋 安装配置 略,可以百度搜索.如下:\nhttps://juejin.im/post/5dc241ce6fb9a04aa333c1bd\n基本使用 安装完成之后,可以使用以下命令查看版本\n1  docker version   拉取并且运行hello-world镜像进行测试\ndocker run hello-world 查看本地镜像:\ndocker image ls 本地有一个hello-world镜像\nImage的获取 1. 从Dockerfile制作 2. 从Register拉取(Pull from Register) 例如:\n1  docker pull ubuntu:14.04   可以在DockerHub里面搜索相关的镜像\n添加Docker用户权限，创建docker组\n1  sudo groupadd docker   1  sudo gpasswd -a vagrant docker   1  sudo service docker restart   最后重新登陆服务器即可\n自定义image 构建一个输出信息的C语言编译的可执行文件镜像\n首先编写C文件,如下:\n1 2 3 4 5 6  #include \u0026lt;stdio.h\u0026gt;int main(){ printf(\u0026#34;Hello,Docker!\\n\u0026#34;); return 0; }   安装gcc及相关库:\n1 2  sudo yum install gcc sudo yum install glibc-static   编译:\n1  gcc -static hello.c -o hello   在当前文件夹下创建Dockerfile\n1  vim Dockerfile   编写下面的内容\n1 2 3  FROM scratch ADD hello / CMD [\u0026#34;/hello\u0026#34;]   使用docker构建:\n1  docker build -t victorhong/hello .   其中victorhong是用户名,hello是镜像名,.表示当前文件夹下的内容\n构建完可以查看到镜像:\n查看构建的历史\n运行容器\ndocker run victorhong/hello Container 什么是container?\n查看container\n1  docker container ls   查看所有cpntainer,包括结束的\n1  docker container ls -a   运行ubuntu:16.04是马上就会结束的,要想交互式的执行容器,使用以下的mingl\n1  docker run -it ubuntu:16.04   另外开一个窗口,查看container\n1  docker container ls   可以看到有一个ubuntu容器正在运行\n构建自己的Docker镜像   docker container commit\n1  docker commit clever_franklin victorhong/centos-vim   在对容器进行修改了之后,clever_franklin为容器名,victorhong/centos-vim为提交的镜像名\n  Dockerfile build\n1 2  FROMcentosRUN yum install -y vim  然后执行\n1  docker build -t victorhong/centos-vim-new .     Dockerfile语法 FROM 定义base image\nLabel 定义数据信息,类似注释\n Metadata不可少\n RUN 每执行一次run,都会新建一层,尽量少用多次run\nWORKDIR 设定当前工作目录,类似cd\n 注意:\n ADD and COPY ADD还有解压功能\nENV 设置环境变量或者常量变量\n尽量使用ENV增加可维护性\nVOLUME ADN EXPOSE VOLUME用于挂载数据卷，EXPOSE用于暴露端口\nCMD and ENTRYPOINT 区别:\n执行命令格式:\nGitHub上的官方Dockerfile\n镜像的发布 使用DockerHub去push\n登陆docker\n1  docker login   push\n1  docker push victorhongdream/hello:latest   查看DockerHub\n","description":"","id":17,"section":"posts","tags":["docker"],"title":"入门Docker","uri":"https://vhope.cf/zh/posts/docker-begin/"},{"content":"C++特性之多态🍄\n静态类型 是指不需要考虑表达式的执行期语义，仅分析程序文本而决定的表达式类型。\n动态类型 是指由一个左值表达式表示的左值所引用的最终派生对象的类型。\n动态绑定与静态绑定 **静态绑定：**编译时绑定，通过对象调用\n**动态绑定：**运行时绑定，通过地址实现\n何时使用动态绑定?\n 只有采用“指针-\u0026gt;函数()”或“引用变量.函数()”的方式调用C++类中的虚函数才会执行动态绑定。 对于C++中的非虚函数，因为其不具备动态绑定的特征，所以不管采用什么样的方式调用，都不会执行动态绑定。   总的来所,动态绑定执行的函数只针对虚函数,执行虚函数会动态执行,而非虚函数就直接执行基类类型的函数,也就是说指针类型是什么，就会调用该类型相应的函数。\n 例如下面的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include \u0026lt;iostream\u0026gt;using namespace std; class Base { public: void func() { cout \u0026lt;\u0026lt; \u0026#34;func() in Base.\u0026#34; \u0026lt;\u0026lt; endl; } virtual void test() { cout \u0026lt;\u0026lt; \u0026#34;test() in Base.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { void func() { cout \u0026lt;\u0026lt; \u0026#34;func() in Derived.\u0026#34; \u0026lt;\u0026lt; endl; } virtual void test() { cout \u0026lt;\u0026lt; \u0026#34;test() in Derived.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base *b; b = new Derived(); b-\u0026gt;func(); b-\u0026gt;test(); }   输出为:\nfunc() in Base. test() in Derived. 再例如下面的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class A { public: virtual void func(int val = 1) { std::cout\u0026lt;\u0026lt;\u0026#34;A-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} virtual void test() { func();} }; class B : public A { public: void func(int val=0) {std::cout\u0026lt;\u0026lt;\u0026#34;B-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} }; int main(int argc ,char* argv[]) { B*p = new B; p-\u0026gt;test(); return 0; }   输出为: B-\u0026gt;1\n test()是虚函数,p-\u0026gt;test()会动态调用B类中的test()函数,并且,还需要记住一个结论:virtual 函数是动态绑定，而缺省参数值却是静态绑定,绝不重新定义继承而来的缺省参数值！\n 虚函数、动态绑定、运行时多态之间的关系 要触发动态绑定，需满足两个条件：\n  只有虚函数才能进行动态绑定，非虚函数不进行动态绑定。\n  必须通过基类类型的引用或指针进行函数调用。\n  简单地说，虚函数是动态绑定的基础；动态绑定是实现运行时多态的基础。\n https://blog.csdn.net/iicy266/article/details/11906509 C++中的动态类型与动态绑定、虚函数、运行时多态的实现 ","description":"","id":18,"section":"posts","tags":["C++","多态"],"title":"C++动态与静态","uri":"https://vhope.cf/zh/posts/cpp-duotai/"},{"content":"c文件读写🗃\nFILE对象结构体 1 2 3 4 5 6 7 8  typedef struct { int _fd; // 文件号  int _cleft; // 缓冲区中剩下的字节数  int _mode; // 文件操作模式  char * _nextc; // 下一个字节的位置  char * _buff; // 文件缓冲区位置 }FILE;   打开文件 可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：\n1  FILE *fopen( const char * filename, const char * mode );   mode 的值可以是r,w,a,,r+,w+,a+:\n   r 打开一个已有的文本文件，允许读取文件。     w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。   a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。   r+ 打开一个文本文件，允许读写文件。   w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。   a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。    如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：\n1  \u0026#34;rb\u0026#34;, \u0026#34;wb\u0026#34;, \u0026#34;ab\u0026#34;, \u0026#34;rb+\u0026#34;, \u0026#34;r+b\u0026#34;, \u0026#34;wb+\u0026#34;, \u0026#34;w+b\u0026#34;, \u0026#34;ab+\u0026#34;, \u0026#34;a+b\u0026#34;     关闭文件 关闭文件非常简单,只需要调用**fclose()**函数即可,其中参数就是指向文件对象的指针.\n1  int fclose( FILE *fp );   如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。  demo 1 2 3 4 5 6 7 8 9 10 11 12 13  void open_close_file(){ char fname[10]; printf(\u0026#34;pease input file name: \u0026#34;); scanf(\u0026#34;%s\u0026#34;,fname); FILE *p = fopen(fname,\u0026#34;r+\u0026#34;); if(p == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return ; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;,fname); fclose(p); printf(\u0026#34;file %s had be closed!\\n\u0026#34;,fname); }   读取文件 读取单个字符的最简单的函数:\n1  int fgetc( FILE * fp );   读取多个字符的函数(也可以读取单个字符):\n1  char *fgets( char *buf, int n, FILE *fp );   fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。\n函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。\n 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void read_file_demo() { char fname[10] = \u0026#34;basic.sql\u0026#34;; FILE *fp = fopen(fname, \u0026#34;r+\u0026#34;); if (fp == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;, fname); char ch; int n = 5; printf(\u0026#34;\\nusing fgetc()......\\n\u0026#34;); while (n--) { ch = fgetc(fp); if(ch != EOF) printf(\u0026#34;char = %c\\n\u0026#34;, ch); } char str[20]; printf(\u0026#34;\\nusing fgets()......\\n\u0026#34;); fgets(str,20,fp); printf(\u0026#34;str[20] = %s\\n\u0026#34;,str); fclose(fp); printf(\u0026#34;file %s had be closed!\\n\u0026#34;, fname); }   读取二进制输入:\n1  size_t fread(void *buffer, size_t size, size_t count, FILE * stream);    buffer为接收数据的地址，size为一个单元的大小，count为单元个数，stream为文件流。\n返回实际读取的单元个数。如果小于count，则可能文件结束或读取出错；可以用ferror()检测是否读取出错，用feof()函数检测是否到达文件结尾。如果size或count为0，则返回0。\n 写入文件 写入单个字符的最简单的函数:\n1  int fputc( int c, FILE *fp );   写入多个字符的函数(也可以写入单个字符):\n1  int fputs( const char *s, FILE *fp );   函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。\n函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。\n 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void write_file_demo() { char fname[10] = \u0026#34;test.txt\u0026#34;; FILE *fp = fopen(fname, \u0026#34;w+\u0026#34;); if (fp == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;, fname); char ch; int n = 5; printf(\u0026#34;\\nusing fputc()......\\n\u0026#34;); while (n--) { ch = (char)(100+n); if((ch = fputc(ch,fp)) != EOF) printf(\u0026#34;char %c write successful!\\n\u0026#34;,ch); } char str[30] = \u0026#34;\\nIt`s a test for write!\u0026#34;; printf(\u0026#34;\\nusing fputs()......\\n\u0026#34;); int r = fputs(str,fp); if(r \u0026gt;= 0) printf(\u0026#34;str[30] = %s write successful!\\n\u0026#34;,str); fclose(fp); printf(\u0026#34;file %s had be closed!\\n\u0026#34;, fname); }   二进制输出:\n1  size_t fwrite(void * buffer, size_t size, size_t count, FILE * stream);    buffer为数据源地址，size为每个单元的字节数，count为单元个数，stream为文件流指针。\n返回成功写入的单元个数。如果小于count，则说明发生了错误，文件流错误标志位将被设置，随后可以通过ferror()函数判断。\n 参考:\n https://www.runoob.com/cprogramming/c-file-io.html ","description":"","id":19,"section":"posts","tags":["C","文件读写"],"title":"C文件读写","uri":"https://vhope.cf/zh/posts/c-read-write/"},{"content":"在markdown文件中嵌入html代码.🛶\n使用自定义文字样式 输入代码:\n1  \u0026lt;span style=\u0026#34;font-size:2rem; background:yellow;\u0026#34;\u0026gt;**Bigger**\u0026lt;/span\u0026gt;   Bigger\n设置键盘按键 输入代码:\n1  \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;F9\u0026lt;/kbd\u0026gt;   Ctrl+F9\n其他网站摘录的html 1  \u0026lt;blockquote class=\u0026#34;twitter-tweet\u0026#34;\u0026gt;\u0026lt;p lang=\u0026#34;en\u0026#34; dir=\u0026#34;ltr\u0026#34;\u0026gt;Sunsets don\u0026amp;#39;t get much better than this one over \u0026lt;a href=\u0026#34;https://twitter.com/GrandTetonNPS?ref_src=twsrc%5Etfw\u0026#34;\u0026gt;@GrandTetonNPS\u0026lt;/a\u0026gt;. \u0026lt;a href=\u0026#34;https://twitter.com/hashtag/nature?src=hash\u0026amp;amp;ref_src=twsrc%5Etfw\u0026#34;\u0026gt;#nature\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://twitter.com/hashtag/sunset?src=hash\u0026amp;amp;ref_src=twsrc%5Etfw\u0026#34;\u0026gt;#sunset\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;http://t.co/YuKy2rcjyU\u0026#34;\u0026gt;pic.twitter.com/YuKy2rcjyU\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026amp;mdash; US Department of the Interior (@Interior) \u0026lt;a href=\u0026#34;https://twitter.com/Interior/status/463440424141459456?ref_src=twsrc%5Etfw\u0026#34;\u0026gt;May 5, 2014\u0026lt;/a\u0026gt;\u0026lt;/blockquote\u0026gt; \u0026lt;script async src=\u0026#34;https://platform.twitter.com/widgets.js\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   Sunsets don\u0026#39;t get much better than this one over @GrandTetonNPS. #nature #sunset pic.twitter.com/YuKy2rcjyU\n\u0026mdash; US Department of the Interior (@Interior) May 5, 2014 ","description":"","id":20,"section":"posts","tags":["markdown","html"],"title":"在markdown使用html","uri":"https://vhope.cf/zh/posts/markdown-html/"},{"content":"TCP/IP编程\n  目标:  能进行网络编程\n1.如果你说你会select,epoll,iocp模型,那会让对方觉得更靠谱\n2.如果你说出你做过im,下载之类那会让对方来兴趣.\n3.如果你说设计了通讯协议,会让对方觉得更贴切\n4.如果你说做过,熟悉, ftp http snmp smtp 这些简单的老古董协议,会加分,但不大.\n5.如果你说熟悉bt,emule,udt等协议,那会对你很有好感.\n6.如果你说你破解过某大牌 qq,360内某通讯协议,那会对你加分很大.\n阶段:\n1)熟悉TCP/IP协议族的基本原理\nIP地址的分类，定义，获得，大概的管理方法\nTCP、UDP等主要协议的特点，主要格式，以及重要字段在协议交互中起到的作用。\n2）对于简单的TCP/IP协议导致的问题，有基本的判断\n熟悉网络问题的解决方法，一个问题，应该是由上而下（top-button），还是由下而上（button-top）来分析？\n3）基本的编程知识。\n在系统内，构建简单通信。\n在系统间，构建简单的通信。\n熟悉系统内的API，知道在什么时候，改使用哪些API协调工作。\n能够熟练使用这些API，在系统间传递信息，文件。\n能够熟练使用这些API，实现自己的简单的私有协议。\n4）进阶编程知识\n知道一两个已经封装好的框架（framwork），它们之间的差别。\n使用一个框架，写过能正常工作的程序。\n知道网络协议处理也是要讲究性能的，知道性能的瓶颈会在什么地方产生。\n能有较好的设计技巧，将私有协议设计得更加具有弹性，优雅。\n熟悉系统间协议处理的细微的差异，以及将会对业务造成的影响，时延、状态不一致、自定义字段、、、、、\n5）熟练阶段的知识\n针对业务的需求，快速选型，定框架。\n不再认为多线程是万能的。\n知道稳定性比性能更加重要。\n数据包去了哪儿，不用看代码，也能预估出来。\n6）源代码是最好的老师，永远都是。\n以上，差不多或者已经达到4）的时候，就是“熟悉”了。\n  网络模型 OSI模型 TCP/IP模型 示例 协议对应 数据封装 C++UDP/TCP实例 套接字 为了区分不同应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP交互提供了称为**嵌套字(Socket)**的接口。\n常用的TCP/IP有以下三种类型的嵌套字：\n  流式嵌套字（SOCK_STREAM）\n用于提供面向连接的、可靠的数据传输服务，即使用TCP进行传输。\n  数据报嵌套字（SOCK_DGRAM）\n用于提供无连接的服务，即使用UDP进行传输。\n  原始嵌套字（SOCK_RAW\n可以读写内核没有处理的IP数据报，而流式嵌套字只能读取TCP的数据，数据报嵌套字只能读取UDP的数据.\n   如果要访问其它协议发送的数据必须使用原始嵌套字，它允许对底层协议(如IP或ICMP)直接访问\n 端口对应进程 单单之后ip地址还不足以辨识通信的两个进程,因为操作系统是并发的,使用端口来辨认某个进程.所以套接字必须的两个信息为: ip地址 + 端口,例如: 192.168.1.4 1500\n参考:\n https://www.jianshu.com/p/c1015f5ffa74 进程间通信 https://segmentfault.com/a/1190000003063859 Linux IO模式及 select、poll、epoll详解 https://cloud.tencent.com/developer/article/1373483 各种IO复用模式之select，poll，epoll，kqueue，iocp分析 ","description":"","id":21,"section":"posts","tags":["tcp","udp","网络"],"title":"Udp-Tcp编程","uri":"https://vhope.cf/zh/posts/udp-tcp/"},{"content":"每次push都需要输入用户名和密码,其实可以免去这些操作.🚛\n1. 使用.git-credentials文件 在git项目目录下新建.git-credentials这个文件,然后在里面填写下面内容(大括号不用填写):\nhttps://{username}:{password}@github.com 然后在git项目目录执行:\n1  git config --global credential.helper store   执行此命令后，用户主目录下的.gitconfig文件会多了一项：[credential]\nhelper = store  注意: Linux用户主目录一般在~/下,而Windows下一般为C:\\users\\Administrator\n 这样以后push就不需要用户名和密码了\n2. 使用ssh协议 首先生成密钥对,执行\n1  ssh-keygen -t rsa -C \u0026#34;youremail\u0026#34;   接下来按照提示操作，默认可以一路往下。\n然后将生成的位于~/.ssh/的id_rsa.pub的内容复制到你github setting里的ssh key中。\n复制之后，如果你还没有克隆你的仓库，那你直接使用ssh协议用法：git@github.com:yourusername/yourrepositoryname克隆就行了。\n如果已经使用https协议克隆了，那么按照如下方法更改协议：\ngit remote set-url origin git@github.com:yourusername/yourrepositoryname.git\nDone!\n3. 管理多git账号 参考:\n https://www.jianshu.com/p/f7f4142a1556 简书 https://segmentfault.com/a/1190000012432367 https://juejin.im/post/5d6a23d45188252bd90f601a 掘金 https://www.cnblogs.com/popfisher/p/5731232.html ","description":"","id":22,"section":"posts","tags":["git","github"],"title":"Git免密push","uri":"https://vhope.cf/zh/posts/git-push-no-pw/"},{"content":"AES算法是继DES之后比较快且比较简单的加密算法.⚖\nAES算法 算法原理： AES密码与分组密码Rijndael基本上完全一致，Rijndael分组大小和密钥大小都可以为128位、192位和256位。然而AES只要求分组大小为128位，因此只有分组长度为128Bit的Rijndael才称为AES算法。\n下面是分组长度为128位的AES算法,而key位数可以是128/192/256,本次实验选择key的大小位128位.\n特点  明文分组被描述为一个字节方阵并复制到状态数组，在每轮替换和移位时都并行处理整个状态分组。 矩阵中字节的顺序是按列排序的，例如128比特的明文分组的前4个字节占输入矩阵的第一列，接下来的4个字节占第二列，依次类推。扩展子密钥数组也类似操作。 假设AES使用128比特的密钥，其密钥被描述为一个字节方阵并将扩展成为一个子密钥数组w[i]（具有44个32比特字），4个不同的字（共128比特）用作每轮的轮密钥。 AES在每轮运算中将进行4个不同的步骤，1个是移位，3个是替换。  数学知识 在AES算法中的MixColumn层中会用到伽罗瓦域中的乘法运算，而伽罗瓦域的运算涉及一些数学知识。\n素域 有限域有时也称伽罗瓦域，它指的是由有限个元素组成的集合，在这个集合内可以执行加、减、乘和逆运算。而在密码编码学中，我们只研究拥有有限个元素的域，也就是有限域。域中包含元素的个数称为域的阶。只有当m是一个素数幂时，即$m=p^n$(其中n为正整数是p的次数，p为素数)，阶为m的域才存在。p称为这个有限域的特征。\n例如，有限域中元素的个数可以是11(p=11是一个素数,n=1)、可以是81(p=3是一个素数，n=4)、也可以是256(p=2是一个素数，n=8)\u0026hellip;..但有限域的中不可能拥有12个元素，因为12=2·2·3，因此12也不是一个素数幂。因此满足p是一个素数且满足$m = p^n$这个公式，m才是一个素数幂。\n有限域中最直观的例子就是阶为素数的域，即n=1的域。域GF(p)的元素可以用整数0、1、\u0026hellip;、p-1l来表示。域的两种操作就是模整数加法和整数乘法模p。加上p是一个素数，整数环Z表示为GF(p)，也成为拥有素数个元素的素数域或者伽罗瓦域。GF(p)中所有的非零元素都存在逆元，GF(p)内所有的运算都是模p实现的。\n素域内的算数运算规则如下  加法和乘法都是通过模p实现的； 任何一个元素a的加法逆元都是由a+(a的逆元)=0 mod p得到的； 任何一个非零元素a的乘法逆元定义为a·a的逆元=1。  举个例子，在素域GF(5)={0、1、2、3、4}中，2的加法逆元为3，这是因为2+(3)=5，5mod5=0,所以2+3=5mod5=0。2的乘法逆元为3，这是因为2·3=6，6mod5=1，所以2·3=6mod5=1。(在很多地方a的加法逆元1用$-a$表示，a的乘法逆元2用$1/a$表示)\n 注：GF(2)是一个非常重要的素域，也是存在的最小的有限域，由于GF(2)的加法，即模2加法与异或(XOR)门等价，GF(2)的乘法与逻辑与(AND)门等价，所以GF(2)对AES非常重要。\n模2加法与异或(XOR)门等价:\n$$\n(1 + 0) \\mod 2 = 1\\\\\n(0 + 1) \\mod 2 = 1\\\\\n(0 + 0) \\mod 2 = 0\\\\\n(1 + 1) \\mod 2 = 0\\\\\n$$\n乘法与逻辑与(AND)门等价:\n$$\n(1 \\times 0) \\mod 2 = 0\\\\\n(0 \\times 1) \\mod 2 = 0\\\\\n(0 \\times 0) \\mod 2 = 0\\\\\n(1 \\times 1) \\mod 2 = 1\\\\\n$$\n 扩展域 如果有限域的阶不是素数，则这样的有限域内的加法和乘法运算就不能用模整数加法和整数乘法模p表示。而且m\u0026gt;1的域被称为扩展域，为了处理扩展域，我们就要使用不同的符号表示扩展域内的元素，使用不同的规则执行扩展域内元素的算术运算。\n在扩展域$GF(2^m)$中，元素并不是用整数表示的，而是用系数为域$GF(2)$中元素的多项式表示。这个多项式最大的度(幂)为m-1​，所以每个元素共有m个系数，在AES算法使用的域$GF(2^8)$中，每个元素$A∈GF(2^8)$都可以表示为：\n$$\nA(x) = a_7x^7 + a_6x^6 + a_5x^5 + a_4x^4 + a_3x^3 + a_2x^2+a_1x + a_0,x_i \\in GF(2) = 0,1\n$$\n注意：在域GF(2^8)中这样的多项式共有256个，这256个多项式组成的集合就是扩展域GF(2^8)。每个多项式都可以按一个8位项链的数值形式存储：\n$$\nA = (a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0)\n$$\n像$x^7$、$x^6$等因子都无需存储，因为从位的位置就可以清楚地判断出每个系数对应的幂。\n扩展域$GF(2^m)$内的加减法 在AES算法中的密钥加法层中就使用了这部分的知识，但是不是很明显，因为我们通常把扩展域中的加法当作异或运算进行处理了，因为在扩展域中的加减法处理都是在底层域GF(2)内完成的，与按位异或运算等价。假设$A(x)$、$B(x)∈GF(2^m)$，计算两个元素之和的方法就是：\n$$\nC(x) = A(x) + B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i + b_i) \\mod 2\n$$\n而两个元素之差的计算公式就是：\n$$\nC(x) = A(x) - B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i - b_i) \\mod 2 = (a_i + b_i) \\mod 2\n$$\n 注：在减法运算中减号之所以变成加号，这就和二进制减法的性质有关了，大家可以试着验算下。从上述两个公式中我们发现在扩展域中加法和减法等价，并且与XOR等价(异或运算也被称作二进制加法)。\n 扩展域GF(2^m)内的乘法 扩展域的乘法主要运用在AES算法的列混淆层(Mix Column)中，也是列混淆层中最重要的操作。我们项要将扩展域中的两个元素用多项式形式展开，然后使用标准的多项式乘法规则将两个多项式相乘：\nAES步骤详解 AES算法主要有四种操作处理，分别是密钥加法层(也叫轮密钥加，英文Add Round Key)、字节代换层(SubByte)、行位移层(Shift Rows)、列混淆层(Mix Column)。而明文x和密钥k都是由16个字节组成的数据(当然密钥还支持192位和256位的长度)，它是按照字节的先后顺序从上到下、从左到右进行排列的。而加密出的密文读取顺序也是按照这个顺序读取的，相当于将数组还原成字符串的模样了，然后再解密的时候又是按照4·4数组处理的。AES算法在处理的轮数上只有最后一轮操作与前面的轮处理上有些许不同(最后一轮只是少了列混淆处理)，在轮处理开始前还单独进行了一次轮密钥加的处理。在处理轮数上，只考虑128位密钥的10轮处理。\n其中字节排列方式需要按照如下转换:\nAES算法流程图如下:\n实现步骤及代码 按照AES流程图,对每一层的代码进行实现.\n密钥加法层 在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。在扩展域中加减法操作和异或运算等价，所以这里的处理也就异常的简单了，只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n如下图：\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4 * 4], word k[4]) { for (int i = 0; i \u0026lt; 4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i + 4] = mtx[i + 4] ^ byte(k2.to_ulong()); mtx[i + 8] = mtx[i + 8] ^ byte(k3.to_ulong()); mtx[i + 12] = mtx[i + 12] ^ byte(k4.to_ulong()); } }   AES密钥生成 首先定义位置变换函数RotWord(),作用是接受一个字 $[a0, a1, a2, a3] $作为输入，循环左移一个字节后输出$ [a1, a2, a3, a0]$,代码如下:\n1 2 3 4 5 6  word RotWord(const word \u0026amp;w) { word result(0x0); result = (w \u0026lt;\u0026lt; 8) | (w \u0026gt;\u0026gt; 24); return result; }   定义S盒变换函数SubWord()，接受一个字 $[a0, a1, a2, a3]$ 作为输入，然后每一个byte，例如a0，前四个字节为行，后四个字节为列，从S_Box中查找并且返回四个元素。，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  word SubWord(const word\u0026amp; sw) { word temp; for(int i=0; i\u0026lt;32; i+=8) { int row = sw[i+7]*8 + sw[i+6]*4 + sw[i+5]*2 + sw[i+4]; int col = sw[i+3]*8 + sw[i+2]*4 + sw[i+1]*2 + sw[i]; byte val = S_Box[row][col]; for(int j=0; j\u0026lt;8; ++j) temp[i+j] = val[j]; } return temp; }   轮常数Rcon[]作为一个常量数组，每一轮生成密钥的时候需要作为参数异或\n1 2 3  // 轮常数，密钥扩展中用到。（AES-128只需要10轮） word Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};   密钥拓展函数KeyExpansion(),接受一个参数为外部密钥，另外一个为需要拓展的轮密钥数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1),Nr为轮数 void KeyExpansion(byte key[4 * N_key], word w[4 * (N_round + 1)]) { word temp; int i = 0; while (i \u0026lt; N_key)\t//前四个word就是输入的key  { w[i] = ToWord(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); ++i; } i = N_key; while (i \u0026lt; 4 * (N_round + 1)) { temp = w[i - 1]; //记录前一个word  if (i % N_key == 0) { //temp先位置表换RotWord，再S盒变换，然后与轮常数异或，最后w[i-N_key] 异或  w[i] = w[i - N_key] ^ SubWord(RotWord(temp)) ^ Rcon[i / N_key - 1]; } else { w[i] = w[i - N_key] ^ temp; } i++; } }   字节替换层 S盒字节替换，主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，读取S_box数据的方法就是要将输入数据的每个字节的高四位作为第一个下标，第四位作为第二个下标。然后返回数据，字节替换主要是为了扰乱数据。\nS盒：\n逆S盒：\n图解如下：\n正向S盒变换代码如下：\n1 2 3 4 5 6 7 8 9 10  //S盒变换 - 前4位为行号，后4位为列号 void SubBytes(byte mtx[4 * 4]) { for (int i = 0; i \u0026lt; 16; ++i) { int row = mtx[i][7] * 8 + mtx[i][6] * 4 + mtx[i][5] * 2 + mtx[i][4]; int col = mtx[i][3] * 8 + mtx[i][2] * 4 + mtx[i][1] * 2 + mtx[i][0]; mtx[i] = S_Box[row][col]; } }   反向S盒变换代码如下:\n1 2 3 4 5 6 7 8 9 10  // 逆S盒变换 void InvSubBytes(byte mtx[4*4]) { for(int i=0; i\u0026lt;16; ++i) { int row = mtx[i][7]*8 + mtx[i][6]*4 + mtx[i][5]*2 + mtx[i][4]; int col = mtx[i][3]*8 + mtx[i][2]*4 + mtx[i][1]*2 + mtx[i][0]; mtx[i] = Inv_S_Box[row][col]; } }   行移位层 将输入数据作为一个$4·4$的字节矩阵进行处理，然后将这个矩阵的字节进行位置上的置换。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在$4·4$矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。最终结束。\n正向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //正向行变换 - 按字节循环移位 void ShiftRows(byte mtx[4 * 4]) { // 第二行循环左移一位  byte temp = mtx[4]; for (int i = 0; i \u0026lt; 3; ++i) mtx[i + 4] = mtx[i + 5]; mtx[7] = temp; // 第三行循环左移两位  for (int i = 0; i \u0026lt; 2; ++i) { temp = mtx[i + 8]; mtx[i + 8] = mtx[i + 10]; mtx[i + 10] = temp; } // 第四行循环左移三位  temp = mtx[15]; for (int i = 3; i \u0026gt; 0; --i) mtx[i + 12] = mtx[i + 11]; mtx[12] = temp; }   反向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 逆行变换 - 以字节为单位循环右移 void InvShiftRows(byte mtx[4*4]) { // 第二行循环右移一位 \tbyte temp = mtx[7]; for(int i=3; i\u0026gt;0; --i) mtx[i+4] = mtx[i+3]; mtx[4] = temp; // 第三行循环右移两位 \tfor(int i=0; i\u0026lt;2; ++i) { temp = mtx[i+8]; mtx[i+8] = mtx[i+10]; mtx[i+10] = temp; } // 第四行循环右移三位 \ttemp = mtx[12]; for(int i=0; i\u0026lt;3; ++i) mtx[i+12] = mtx[i+13]; mtx[15] = temp; }   列混淆层 列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。\n在加密的正向列混淆中，我们要将输入的$4·4$矩阵左乘一个给定的$4·4$矩阵。而它们之间的加法、乘法都在扩展域$GF(2^8)$中进行，,在矩阵相乘计算中，出现了加法和乘法，而前面提到了在拓展域中加法等同于异或运算，而对于乘法，需要特殊的方式进行处理，于是将+号换成^号，然后将伽罗瓦域的乘法定义成一个有两个参数的函数，并让他返回最后计算结果，最后列混淆代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //正向列变换 void MixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x02, arr[0]) ^ GFMul(0x03, arr[1]) ^ arr[2] ^ arr[3]; mtx[i+4] = arr[0] ^ GFMul(0x02, arr[1]) ^ GFMul(0x03, arr[2]) ^ arr[3]; mtx[i+8] = arr[0] ^ arr[1] ^ GFMul(0x02, arr[2]) ^ GFMul(0x03, arr[3]); mtx[i+12] = GFMul(0x03, arr[0]) ^ arr[1] ^ arr[2] ^ GFMul(0x02, arr[3]); } }   在解密的逆向列混淆中与正向列混淆的不同之处在于使用的左乘矩阵不同，它与正向列混淆的左乘矩阵互为逆矩阵，也就是说，数据矩阵同时左乘这两个矩阵后，数据矩阵不会发生任何变化。下面是图解：\n正向混淆处理：\n逆向混淆处理：\n反向列变换代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //反向列混淆 void InvMixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]); mtx[i+4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]); mtx[i+8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]); mtx[i+12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]); } }   密钥加法层 这一层主要是明文矩阵盒子密钥矩阵进行异或操作,在密钥加法层中有两个输入的参数，分别是明文和子密钥，而且这两个输入都是128位的。只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4*4], word k[4]) { for(int i=0; i\u0026lt;4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i+4] = mtx[i+4] ^ byte(k2.to_ulong()); mtx[i+8] = mtx[i+8] ^ byte(k3.to_ulong()); mtx[i+12] = mtx[i+12] ^ byte(k4.to_ulong()); } }   实现加密函数 加密函数按照流程图,首先开始是先进行一次轮密钥加,然后开始9轮的字节替换+行移位+列混淆+轮密钥加的操作,循环之后再做一次字节替换+行移位+轮密钥加就完成加密操作了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void encrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); for(int round=1; round\u0026lt;N_round; ++round) { SubBytes(in); ShiftRows(in); MixColumns(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); } SubBytes(in); ShiftRows(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); }   实现解密函数 解密函数与加密差不多,只不过将行移位变成反向行移位,列混淆变成反向列混淆,字节替换变成逆字节替换即可.\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void decrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); for(int round=N_round-1; round\u0026gt;0; --round) { InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); InvMixColumns(in); } InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); }   测试加密解密函数 可以发现上面面的测试中明文与解密之后的明文是完全正确的,说明加密函数与解密函数正确!\n测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  void Aes_test() { byte key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}; byte plain[16] = {0x32, 0x88, 0x31, 0xe0, 0x43, 0x5a, 0x31, 0x37, 0xf6, 0x30, 0x98, 0x07, 0xa8, 0x8d, 0xa2, 0x34}; // 输出密钥  cout \u0026lt;\u0026lt; \u0026#34;Key is : \u0026#34;; for (int i = 0; i \u0026lt; 16; ++i) cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; key[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; cout \u0026lt;\u0026lt; endl; word w[4 * (N_round + 1)]; KeyExpansion(key, w); // 输出待加密的明文  cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;the plaintext to encrypy:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 加密，输出密文  encrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;cipher : \u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 解密，输出明文  decrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;plain arter decrypt:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; }   实现加解密文件 加密文件函数,返回加密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  string encryptFile(string oname, string suffix, word w[4 * (N_round + 1)]) { string outputfilename = oname + \u0026#34;_cipher.bin\u0026#34;; bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining encrypy...........\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); // 将文件加密到 oname + cipher.bin 中  ifstream in; ofstream out; in.open(oname + suffix, ios::binary); //输入文件  out.open(outputfilename, ios::binary); //输出加密文件  while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); encrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0  } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;encrypy finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;encrypy cost time : \u0026#34; \u0026lt;\u0026lt; (end - start) \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; //返回加密之后的文件 }   解密文件函数,返回解密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  string decryptFile(string filename, string oname, string suffix, word w[4 * (N_round + 1)]) { ifstream in; ofstream out; in.open(filename, ios::binary); string outputfilename = oname + \u0026#34;_decrypt\u0026#34; + suffix; out.open(outputfilename, ios::binary); bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining decrypt............\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); decrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0  } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;decrypt finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;decrypt cost time : \u0026#34; \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; }   实现效果:\n加密txt文件:\n加密jpg文件:\n加密mp3文件:\n加密doc文件:\nAES五种加密模式 实现五种加密方式的密钥是一个置换表unsigned char Table[4] = {0x12, 0xb1, 0x53, 0x28};,加密函数是原文与密钥的异或.\nECB模式(电子密码本模式) 加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。\nECB模式由于每块数据的加密是独立的因此加密和解密都可以并行计算，ECB模式最大的缺点是相同的明文块会被加密成相同的密文块，这种方法在某些环境下不能提供严格的数据保密性。\n流程图如下:\n实现代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //电子密码本模式,分组大小为4 unsigned char* ECB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for(int j = 0;j \u0026lt; groupSize;++j) temp[j] = plain[count++]; //加密  encrypt(temp,groupSize); for(int j = i*4;j \u0026lt; i*4 + 4;++j) cipher[j] = temp[j - i * 4]; } return cipher;//返回密文 }   解密方法也是让密文与密钥进行异或即可,实现效果如下:\nCBC模式(分组链接模式) CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。\n可用公式总结为:\n$$\nC_i = E_K(P_i XOR C_{i-1}) \\\nC_{-1} = IV\n$$\n流程图如下:\nCBC模式相比ECB有更高的保密性，但由于对每个数据块的加密依赖与前一个数据块的加密所以加密无法并行。与ECB一样在加密前需要对数据进行填充，不是很适合对流数据进行加密。\n代码如下:\n加密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //CCB加密函数 unsigned char *CCB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = plain[count++]; //加密  for (int j = 0; j \u0026lt; groupSize; ++j) //先与初始向量异或  temp[i] ^= C[i]; encrypt(temp, groupSize); //加密  for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { cipher[j] = temp[j - i * 4]; C[j - i * 4] = temp[j - i * 4];//设置新向量  } } return cipher; }   解密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //CCB解密函数 unsigned char *dCCB(unsigned char *cipher, int N) { int gNum = N / groupSize; //分组数量  //明文  unsigned char *plain = new unsigned char[N]; //设置初始向量  unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = cipher[count++]; //解密  encrypt(temp, groupSize); //先解密  for (int j = 0; j \u0026lt; groupSize; ++j) //然后与初始向量异或  temp[i] ^= C[i]; for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { plain[j] = temp[j - i * 4]; C[j - i * 4] = cipher[j];//设置新向量  } } return plain; }   实现效果:\nCFB模式(密文反馈模式) 与前面的模式不同,CFB模式可以将消息被当成是比特流.可以总结为如下的公式:\n$$\nC_i = P_i XOR E_K(C_{i-1})\\\nC_{-1} = IV\n$$\n流程图如下:\n加密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  //密文反馈模式,加密函数 unsigned char *CFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文,大小为2  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; gsize;++j){ temp[j] ^= C[j]; S[j] = temp[j]; //获取密文的2bit  } //设置密文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; }   解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  //密文反馈解密 unsigned char *dCFB(unsigned char *cipher, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //明文  unsigned char *plain = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组密文  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = cipher[count++]; //解密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; 2;++j){ S[j] = temp[j]; temp[j] = C[j] ^ temp[j]; } //设置明文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { plain[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j+gsize] = S[j]; } } return plain; }   实现效果:\nOFB模式(输出反馈模式) OFB是先用块加密器生成密钥流（Keystream），然后再将密钥流与明文流异或得到密文流，解密是先用块加密器生成密钥流，再将密钥流与密文流异或得到明文，由于异或操作的对称性所以加密和解密的流程是完全一样的。\nOFB与CFB一样都非常适合对流数据的加密，OFB由于加密和解密都依赖与前一段数据，所以加密和解密都不能并行。\n流程图如下:\n加密解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  //输出反馈模式,加密解密函数相同 unsigned char *OFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xee, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; 2;++j){ S[j] = C[j]; //取向量加密后的前两位  temp[j] ^= C[j]; } //设置密文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; }   实现效果:\nCTR模式(计数器模式) 类型于CFB，但是加密每个计数值，而不是任何反馈值,对每个明文分组，必须有不同的密钥和计数值 (从不重复使用),,可以用如下公式表示:\n$$\nO_i = E_K(i)\\\nC_i = P_i XOR O_i\n$$\n计数器模式流程图如下:\n计数器模式加密函数与解密函数一样,代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  //计数器模式,加密函数 unsigned char *CTR(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; //设置随机值  unsigned char Counter[groupSize*groupSize] = {0x44, 0xa9, 0x5d, 0x99, 0xe5, 0xf1, 0x3d, 0x91, 0x16, 0xa6, 0xe1, 0x33, 0x22, 0xdd, 0xab, 0x1f}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; //明文分组  unsigned char C[groupSize]; //分组随机值  for (int j = 0; j \u0026lt; groupSize; ++j) { temp[j] = plain[count++]; C[j] = Counter[i*4+j]; } //加迷  //首先加密随机值C  encrypt(C, groupSize); //然后与明文进行异或  for(int j = 0;j \u0026lt; groupSize;++j) temp[j] ^= C[j]; //设置密文  for(int j = i*groupSize;j \u0026lt; i*groupSize+groupSize;j++) cipher[j] = temp[j-i*groupSize]; } return cipher; }   实现效果如下:\n参考:\n https://www.cnblogs.com/RabbitHu/p/bitset.html bitset用法 https://blog.csdn.net/liushu1231/article/details/8844631 bitset的空间大小 http://c.biancheng.net/cpp/html/2834.html 文件处理 https://bbs.pediy.com/thread-253884.htm AES算法带图解 https://blog.csdn.net/lisonglisonglisong/article/details/41909813 AES算法 CSDN https://blog.csdn.net/sinat_23338865/article/details/72869841 AES五种加密模式   设“+”为一个交换性的二元运算，即对于所有x,y，x+y=y+x。若该集内存在一个元素0，使得对于所有x，x+0=0+x=x，则此元素是唯一的。如果对于一个给定的x，存在一个x'使得x+x'=x'+x=0，则称x'是x的加法逆元。 \u0026#x21a9;\u0026#xfe0e;\n 乘法逆元，是指数学领域群G中任意一个元素a，都在G中有唯一的逆元a‘，具有性质a×a'=a'×a=e，其中e为该群的单位元。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":23,"section":"posts","tags":["AES","密码学","加密"],"title":"Aes-高级加密标准","uri":"https://vhope.cf/zh/posts/aes/"},{"content":"简单地说，云计算就是计算服务的提供（包括服务器、存储、数据库、网络、软件、分析和智能）- 通过 Internet（云）提供快速创新、弹性资源和规模经济。对于云服务，通常你只需使用多少支付多少，从而帮助降低运营成本，使基础设施更有效地运行，并能根据业务需求的变化调整对服务的使用。\n行云趣码记录 行云趣码官网：http://mart.cloudtogo.cn/\nLinux服务器 生成自己的服务器 进入应用商店，选择需要的Linux服务器，这里选择CentOS\n点击部署，等待生成自己的服务器\n发布成功\n参数解释 点击访问，会跳出访问地址，部署区域以及提示信息，一步一步看。\n访问地址\n部署区域\n部署区域没什么好说的，就是这个服务器部署的区域。\n详情\n从上面给的信息，可以归为如下：\n  ssh远程访问的地址为2c56369b3c95a919.c.cloudtogo.cn，端口为34920(注意：端口不是22)。远程登陆的用户名为：root，密码为：123456.\n  有五个映射端口，他们的对应关系如下：\n   Linux内部 外部访问     8001 34921(预留a端口)   8002 34916(预留b端口)   8003 34917(预留c端口)   8004 34918(预留d端口)   8005 34924(预留e端口)    也就是说，当我们在Linux内部启用8001-8005这五个端口运行相应的应用时，我们可以访问对应的外部预留端口以及子域名进行访问测试。\n例如在Linux内运行了一个web应用在8001端口，我们可以在浏览器访问61823a63ab19b300.c.cloudtogo.cn:34921\n  ssh远程连接：\n查看配置 查看CPU型号: Intel(R) Xeon(R) CPU E5-2680 v3\n1  cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c   查看物理CPU个数: 2\n1  cat /proc/cpuinfo | grep \u0026#34;physical id\u0026#34; | sort | uniq|wc -l   查看逻辑CPU的个数: 8个\n1  cat /proc/cpuinfo | grep \u0026#34;processor\u0026#34; |wc -l   查看CPU是几核: 4核\n1  cat /proc/cpuinfo | grep \u0026#34;cores\u0026#34;|uniq   设置远程访问jupyter 安装完jupyter之后，输入以下命令生成配置文件：\n1  jupyter notebook --generate-config   参考：\nhttps://www.jianshu.com/p/960f011f712e\nhttps://zhuanlan.zhihu.com/p/64524822\n结果：\n添加虚拟环境：https://ofooo.github.io/wiki/python/%E5%B7%A5%E5%85%B7/jupyter-notebook/\n更换pip源：https://www.linuxidc.com/Linux/2019-04/158178.htm\n部署nodejs：https://blog.csdn.net/xerysherryx/article/details/78920978\nnpm镜像：https://www.cnblogs.com/alps/p/12439387.html\nCentOS基本命令 查看服务进程\n1 2 3  [victor@mylove ~]$ ps -aux|grep mysql victor 23477 0.0 0.0 110656 2688 pts/3 S+ 12:26 0:00 grep --color=auto mysql   查看进程端口\n1  netstat -anp |grep 1506   查看端口进程\n1  netstat -lnp|grep 3306   关闭进程\n1  kill –9 1506   生产应用 使用docker生产自己的应用 开发网页App 进入应用工厂,打开一个Blank的模板继续,然后再设计页面拖入一个代码组件,如下:\n输入名字为webpy,应为使用的是web.py框架进行编写,然后点击下一步.\n然后输入存放代码的地址,代码需要编写完成之后存到GitHub上,程序默认的运行入口时main.py,在运行main.py之前,还会执行pip install -r requirements.txt这个代码,所以我们可以将所需要的依赖包都写在requirements.txt这个文件中.\n我的代码地址: https://github.com/redisread/webpy.git\n编写组件向导,有许多参数\n其他的参数作用:\n 环境变量: 存储系统的相关需要运行的程序的位置 多副本: 多副本设置支持可以使用弹性伸缩功能,可开启可不开启 会话保持: 维持客户端与一台服务器的连接,即对于某个客户端,,不会更换与他进行连接的服务器 执行命令: 可以执行Linux的相关命令 存储路径: 可以设置存储到数据卷中,填写的Linux的位置就是数据卷存放的位置 root权限: 是否开启root权限 服务名称: 就是服务的名称 读取指定文件: **0 日志文件: 填写日志文件存放的的地方 映射配置文件: 可以映射(相当于替换)配置文件,例如nginx的nginx.conf文件. 健康检查: 特权模式: 资源限制: 限制CPUy以及内存的设置  最后点击完成就可以发发布应用了\n发布一般不需要配置什么,需要的话可以自行设置.\n发布成功!\n访问该地址就能够访问我们写的应用了.\n运维管理 在发布页的侧边栏有一个运维按钮,点击进入运维界面\n如下就是可以进行查看的相关信息\n","description":"","id":24,"section":"posts","tags":["云计算","行云趣码"],"title":"行云开发","uri":"https://vhope.cf/zh/posts/xingyun-begin/"},{"content":"集万滴雨水，成一条江河🌊🌊\nRedis  REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。\nRedis是一个开源的使用ANSI C语言编写、遵守BSD协议1、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n  开源界的 5 大许可协议：五大开源许可协议分别是GPL,LGPL,BSD,MIT,Apache。\n 存储类型：\n String: 字符串 Hash: 散列 List: 列表 Set: 集合 Sorted Set: 有序集合  三个特点：\n Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式2的数据备份。  Redis与其他key-value存储有什么不同？\n Redis有着更为复杂的数据结构并且提供对他们的原子性操作3，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。  安装 github链接：https://github.com/microsoftarchive/redis/releases\nRedis是C语言开发，安装Redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc。\n安装GCC 步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  ## 先安装 gcc 编译环境,如果已经安装, 请忽略 yum -y install gcc automake autoconf libtool make ## 下载 redis 源代码 wget http://download.redis.io/releases/redis-4.0.1.tar.gz ## 下载完成后,解压 tar zxvf redis-4.0.1.tar.gz ## 跳转到 redis 目录 cd redis-4.0.1 ## 编译 make ## 安装编译后的软件到 /usr/local/redis ## PREFIX必须大写,自动为我们创建redis目录，并将结果安装此目录 make PREFIX=/usr/local/redis install ## 查看安装的结果 cd /usr/local/redis/bin ls -l -rwxr-xr-x 1 root root 2451864 Mar 12 13:28 redis-benchmark -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-check-aof -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-check-rdb -rwxr-xr-x 1 root root 2606088 Mar 12 13:28 redis-cli lrwxrwxrwx 1 root root 12 Mar 12 13:28 redis-sentinel -\u0026gt; redis-server -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-server   配置  Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。\n redis.conf配置文件详解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  ## 指定包含其它的配置文件，可以多个Redis实例使用同一份配置文件，而各个实例又拥有自己的特定配置文件 include /path/to/local.conf ## 绑定的主机地址, 可以监听一个或多个, 如果为 127.0.0.1 只能本机才能访问 bind 127.0.0.1 ## Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no ## Redis以守护进程方式运行时,Redis默认会把 pid 写入 /var/run/redis.pid 文件,可以通过 pidfile 指定 pidfile /var/run/redis_6379.pid ## 指定Redis监听端口，默认端口为6379 port 6379 ## 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 0 ## 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose ## debug 会打印出很多信息，适用于开发和测试阶段 ## verbose 包含很多不太有用的信息，但比debug要清爽一些 ## notice 适用于生产模式 ## warning 警告信息（仅记录非常重要/重要的消息） loglevel verbose ## 日志记录方式，默认为标准输出 ## 如果 Redis 以守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout ## 设置数据库的数量，默认数据库为0，可以使用SELECT \u0026lt;dbid\u0026gt;命令在连接上指定数据库id databases 16 ## 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件(持久化)，可以多个条件配合 ## save \u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt; save 900 1 ## 900秒内有一个更新 save 300 10 ## 300秒内有10个更新 save 60 10000 ## 60秒内有10000个更新 ## 指定存储至本地数据库时是否压缩数据，默认为yes ## Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes ## 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb ## 也就是安装目录下我们看到的那个文件 ## 指定本地数据库存放目录 dir ./ ## 当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt; ## 当master服务设置了密码保护时，slav服务连接master的密码 masterauth \u0026lt;master-password\u0026gt; ## 设置Redis连接密码 ## 如果配置了连接密码，客户端在连接Redis时需要通过AUTH \u0026lt;password\u0026gt;命令提供密码，默认关闭 requirepass foobared ## 设置同一时间最大客户端连接数，默认无限制 ## Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数 ## 如果设置 maxclients 0，表示不作限制 ## 客户端连接数到达限制时,Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 128 ## Redis最大内存限制 ## Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key ## 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。 ## Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory \u0026lt;bytes\u0026gt; ## 指定是否在每次更新操作后进行日志记录, 默认为 no ## Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失 ## 因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中 appendonly no ## 指定更新日志文件名，默认为 appendonly.aof appendfilename appendonly.aof ## 指定更新日志条件 ## no : 表示等操作系统进行数据缓存同步到磁盘（快） ## always : 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） ## everysec : 表示每秒同步一次（折中，默认值） appendfsync everysec ## 指定是否启用虚拟内存机制，默认值为no ## VM机制将数据分页存放,将访问量较少的页即冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中 vm-enabled no ## 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap ## 将所有大于vm-max-memory的数据存入虚拟内存 ## 无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys), ## 也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 ## Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享 vm-page-size 32 ## 设置swap文件中的page数量 ## 由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的,在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 ## 设置访问swap文件的线程数,最好不要超过机器的核数, ## 如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 ## 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes ## 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 ## 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes   注意事项 我们查看了配置文件信息, 总结如下\n   如果你想要以加载配置文件的方式启动 Redis, 那么你需要使用 ./redis-server /path/to/redis.conf 命令启动 Redis 服务端.\n  内存设置大小单位\n   1k =\u0026gt; 1000 bytes 1kb =\u0026gt; 1024 bytes 1m =\u0026gt; 1000000 bytes 1mb =\u0026gt; 1024*1024 bytes 1g =\u0026gt; 1000000000 bytes 1gb =\u0026gt; 102410241024 bytes 1GB 1Gb 1gB 表达一样的意思, 单位不区分大小写    121321\n   基本操作 连接远程服务器：redis-cli -h host -p port -a password\n例如：$redis-cli -h 127.0.0.1 -p 6379 -a \u0026quot;mypass\u0026quot;\n键Key 与 Redis 键相关的基本命令：\n   序号 命令及描述     1 DEL key 该命令用于在 key 存在时删除 key。   2 DUMP key 序列化给定 key ，并返回被序列化的值。   3 EXISTS key 检查给定 key 是否存在。   4 EXPIRE key seconds 为给定 key 设置过期时间，以秒计。   5 EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。   6 PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。   7 PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计   8 KEYS pattern 查找所有符合给定模式( pattern)的 key 。   9 MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。   10 PERSIST key 移除 key 的过期时间，key 将持久保持。   11 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。   12 TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。   13 RANDOMKEY 从当前数据库中随机返回一个 key 。   14 RENAME key newkey 修改 key 的名称   15 RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。   16 TYPE key 返回 key 所储存的值的类型。    设置键值对 set key value 与取出键值对 get key\n删除键值使用del key\n字符串存储 Hash存储 之前变量没删除会报错\nRedis hash 是一个键值(key=\u0026gt;value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n每个 hash 可以存储 232 -1 键值对（40多亿）。\n列表存储 Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n展示：\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n集合存储 指令：sadd key member 向集合key添加元素。\n指令：smembers key，展示集合key中的元素：\n有序集合-zset 指令：zadd key score member ，向有序集合添加元素，并且设置相应的score。\n上面设置A且score为0，B且score为2，C且score为1.\n指令：zrangebyscore key l r,展示有序集合按score排序之后且在范围l到r的元素。\n显然元素已经按照score的顺序排列。\n 跟其他条款相比，从GNU通用公共许可证（GPL）到限制重重的著作权（Copyright），BSD许可证比较宽松，甚至跟公有领域更为接近。事实上，BSD许可证被认为是copycenter（中间著作权），介乎标准的copyright与GPL的copyleft之间。\u0026ldquo;Take it down to the copy center and make as many copies as you want\u0026rdquo;[1]。可以说，GPL强迫后续版本必须一样是自由软件，BSD的后续版本可以选择要继续是BSD或其他自由软件条款或封闭软件等等。 \u0026#x21a9;\u0026#xfe0e;\n 主从设备模式也叫做主仆模式英文简称为Master-Slave,核心思想是基于分而治之的思想,将一个原始任务分解为若干个语义等同的子任务,并由专门的工作者线程来并行执行这些任务,原始任务的结果是通过整合各个子任务的处理结果形成的 \u0026#x21a9;\u0026#xfe0e;\n 意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":25,"section":"posts","tags":["redis","分布式计算","云计算","数据库"],"title":"分布式-Redis","uri":"https://vhope.cf/zh/posts/redis/"},{"content":"走得慢的时候，为什么不跑呢？#️⃣\n哈希散列表 两个概念：\n散列表：\n散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。\n散列函数：\n散列函数，顾名思义，它是一个函数。如果把它定义成 hash(key) ，其中 key 表示元素的键值，则 hash(key) 的值表示经过散列函数计算得到的散列值。\n散列函数特点：\n 确定性 散列碰撞（collision） 不可逆性(一个哈希值对应无数个明文，理论上你并不知道哪个是。) 混淆特性  常见的散列函数：\n MD51 SHA-12  为什么哈希算法查找数组元素会更快？\n 原来使用下标进行匹配的画，会一个一个从一整个数组进行元素匹配，知道找到相等的元素才得到数组的信息。例如在Arr[20]查找值为12的,就需要从下标0到19进行查找。\n但是哈希散列表将一个一个按顺序的查找转换为使用计算的方式进行查找，将运算结果的下标映射成一个哈希表，实现了跳跃式的查找，从而效率更高。\n 问题:散列冲突\n 对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的散列冲突。\n 解决散列函数的两个方法：\n  链表法\n就是使用链表来保存冲突下标的数据，例如$12 % 5 = 2$和$7 % 5 = 2$,那么在下标为2的表下用一个链表存储12和7。\n  开放寻址法。\n常见三种方法：线性探测法、二次探测法、双散列\n假设哈希函数为：\n$$\nH(key) = key \\mod10\n$$\n线性探测法：\n还是$12 % 10 = 2 $和$22 % 10 = 2$这两个例子，当22这个数字需要存入哈希表时，发现已经有12这个元素存放在下标为2的哈希表上了，那么对Hash后的数字加一在进行Hash。即对7进行这样的操作：\n$$\nH((H(key)+1)) = ((22 \\mod 10) + 1) \\mod 10 = (2 + 1) \\mod 10 = 3\n$$\n但是这种方式的问题是冲突较多的时候会出现数据聚集在一个区域，这样不利于查询数据。\n二次探测法：\n二次探测法使用下面的函数解决冲突：\n$$\n(H(key) \\pm j^2) \\mod 10,j = 0,1,2\u0026hellip;\n$$\n这种方法较为复杂，而且虽然不会连续的聚集一片，但是会在多个间断的位置聚集。\n双散列：\n双散列，顾名思义就需要增加一个二级散列函数，例如$G(key) = q - (key \\mod q) q为素数且q\u0026lt;N$，发现冲突使用如下操作：\n$$\nH(key) + j * G(key),j = 0,1,2\u0026hellip;\u0026hellip;\n$$\n双散列方法有很多组合的方法，这里只是其中的一种，也有一些例如:$H(key) + G(key)$,没有j这个参数。\n  密码学中的哈希算法  hash（散列、杂凑）函数，是将任意长度的数据映射到有限长度的域上。直观解释起来，就是对一串数据m进行杂糅，输出另一段固定长度的数据h，作为这段数据的特征（指纹）。也就是说，无论数据块m有多大，其输出值h为固定长度。到底是什么原理？将m分成固定长度（如128位），依次进行hash运算，然后用不同的方法迭代即可（如前一块的hash值与后一块的hash值进行异或）。如果不够128位怎么办？用0补全或者用1补全随意，算法中约定好就可以了。\n 一般来说，公司不会直接将用户的密码保存在数据库中，而是保存经过哈希操作的密码得到的哈希值。这样，当哈希值被不法分子窃取，也不能还原出用户的密码；并且，公司只需要将用户输入的密码进行哈希操作，将哈希值与存储在数据库中的哈希值进行对比就能够验证用户了。\n哈希的其他用法 数据校验：\n  Git的- git commit id\n每次git提交后都有一个commit id，比如:\n19d02d2cc358e59b3d04f82677dbf3808ae4fc40\n  版权校验\n判断两个文件是不是一样的，对两个文件都进行哈希操作，得到哈希值，若哈希值相同，则两个文件为同一个文件。\n  大文件分块校验\n例如使用bt下载，在p2p网络中会把一个大文件拆分成很多小的数据各自传输。这样的好处是如果某个小的数据块在传输过程中损坏了，只要重新下载这个块就好。为了确保每一个小的数据块都是发布者自己传输的，我们可以对每一个小的数据块都进行一个hash的计算，维护一个hash List，在收到所有数据以后，我们对于这个hash List里的每一块进行遍历比对。这里有一个优化点是如果文件分块特别多的时候，如果遍历对比就会效率比较低。可以把所有分块的hash值组合成一个大的字符串，对于这个字符串再做一次Hash运算，得到最终的hash（Root hash）。在实际的校验中，我们只需要拿到了正确的Root hash，即可校验Hash List，也就可以校验每一个数据块了。\n  负载均衡：\n一致性hash的基本原理是将输入的值hash后，对结果的hash值进行2^32取模，这里和普通的hash取模算法不一样的点是在一致性hash算法里将取模的结果映射到一个环上。将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一个openid必定会被缓存到固定的服务器上，那么，当下次想要访问这个用户的数据时，只要再次使用相同的算法进行计算，即可算出这个用户的数据被缓存在哪个服务器上，直接去对应的服务器查找对应的数据即可。这里的逻辑其实和直接取模的是一样的。如下图所示：\n这部分不是很深入，之后再补充\u0026hellip;\u0026hellip;🚴\n参考链接：\n https://www.zhihu.com/question/26762707?sort=created-知乎 动画：什么是散列表？-五分钟算法 什么是 hash？-知乎   MD5 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 MD5 实现。 \u0026#x21a9;\u0026#xfe0e;\n SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":26,"section":"posts","tags":["Hash","Algorithm","md5","sha"],"title":"什么是Hash？","uri":"https://vhope.cf/zh/posts/hash/"},{"content":"排序是最基本的算法，里面包含了最基础的思想。一个简单的优化可以让排序快很多。\n$O(n^2)$的排序算法 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13  //冒泡排序 template \u0026lt;typename T\u0026gt; void bubbleSort(T *arr, int size) { for (int i = 0; i \u0026lt; size; ++i) { for (int j = 0; j \u0026lt; size - i - 1; ++j) { if (arr[j] \u0026gt; arr[j + 1]) swap(arr[j], arr[j + 1]); } } }   插入排序 ​\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; void insertSort(T *arr,int size) { for(int i = 0;i \u0026lt; size;++i) { int j; for(j = i;j \u0026gt; 0 \u0026amp;\u0026amp; arr[j] \u0026lt; arr[j-1];--j){swap(arr[j],arr[j-1]);} } }   选择排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14  //选择排序 复杂度O(n^2) template\u0026lt;typename T\u0026gt; void selectionSort(T *arr,int size) { int k; for(int i = 0;i \u0026lt; size-1; ++i) { k = i; for(int j = i+1;j \u0026lt; size;++j) if(arr[j] \u0026lt; arr[k]) k = j; if(k != i) mySwap(arr[k],arr[i]); } }   测试排序使用时间的时候，总是选择排序快于插入排序，按理说，插入排序应该比选择排序要快啊，因为插入排序可以提前终止循环，这是为什么呢？\n 原因是选择排序比较的是下标，而插入排序每一次比较都要交换，而交换所耗费的时间是高于简单的比较的。\n 插入排序优化-将交换变成赋值\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; void insertSort(T *arr,int size) { for(int i = 0;i \u0026lt; size;++i) { T e = arr[i]; int j; for(j = i;j \u0026gt; 0 \u0026amp;\u0026amp; arr[j-1] \u0026gt; e;--j){arr[j] = arr[j-1];} arr[j] = e; } }   运行时间明显变快了\n 对于近乎有序的数据来说，插入排序的速度要快很多，近乎$O (n)$。而插入排序的实际应用有很多，比如日志，日志的时间是近乎有序的，但是生成日志可能会出错，需要进行时间排序处理，这个时候使用插入排序会更好；还有银行的一些流水单等等\n 拓展： C++运算符重载\n 一般在类中实现，有两种可以实现的方法\n  运算符重载例子，使用在一个类中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Student { public: string name; int score; bool operator\u0026lt;(const Student \u0026amp;otherStudent) { return this-\u0026gt;score \u0026lt; otherStudent.score; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const Student \u0026amp;student) { os \u0026lt;\u0026lt; \u0026#34;Student:\u0026#34; \u0026lt;\u0026lt; student.name \u0026lt;\u0026lt; \u0026#34;\u0026#34;\u0026lt;\u0026lt;student.score\u0026lt;\u0026lt;endl; return os; } };      使用友元函数\n1 2 3 4 5 6 7 8  返回值类型 operator 运算符(形参表) { ... } //例Complex是一个复数类 friend Complex operator+(const Complex \u0026amp;c1,const Complex \u0026amp;c2){ return Complex(c1.i + c2.i,c1.j + c2.j); }     使用类里面的函数\n1 2 3 4 5 6 7 8  返回值类型 operator 运算符(形参表) { ... } //例Complex是一个复数类 Complex operator+(const Complex \u0026amp;complex){ return Complex(this-\u0026gt;i + complex.i,this-\u0026gt;j + complex.j); }     它们的区别就是参数的个数不同以及需不需要加上fridend这个关键字\n$O(n\\log (n))$的排序算法 归并排序 代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  template \u0026lt;typename T\u0026gt; void __merge(T *arr, int l, int middle, int r) { T aux[r - l + 1]; for (int i = l; i \u0026lt;= r; ++i) aux[i - l] = arr[i]; int i = l, j = middle + 1; for (int k = l; k \u0026lt;= r; ++k) { if (i \u0026gt; middle) { arr[k] = aux[j - l]; j++; } else if (j \u0026gt; r) { arr[k] = aux[i - l]; i++; } else if (aux[i - l] \u0026lt; aux[j - l]) { arr[k] = aux[i - l]; i++; } else { arr[k] = aux[j - l]; j++; } } } template \u0026lt;typename T\u0026gt; void __mergeSort(T *arr, int l, int r) { if (l \u0026gt;= r) return; int middle = (l + r) / 2; __mergeSort(arr, l, middle); __mergeSort(arr, middle+1, r); if(arr[middle] \u0026gt; arr[middle+1]) __merge(arr, l, middle, r); } //归并排序 template \u0026lt;typename T\u0026gt; void mergeSort(T *arr, int size) { __mergeSort(arr, 0, size - 1); }   下面这段代码的标记部分需要考虑溢出的问题\n 归并排序快是快，但是要耗费多一倍$O(n)$的存储空间，也就是使用空间换时间。\n 希尔排序 动画演示(来自@五分钟算法)：\n代码实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //希尔排序 template \u0026lt;typename T\u0026gt; void shellSort(T *arr, int size) { int dk[] = {5, 3, 1}; for (int index = 0; index \u0026lt; 3; ++index) { for (int i = 0; i \u0026lt; size / dk[index]; ++i) { int j; int e = arr[i]; for (j = i + dk[index]; j \u0026gt; dk[index] \u0026amp;\u0026amp; arr[j] \u0026gt; e; j -= dk[index]) { arr[j] = arr[j - dk[index]]; } arr[j] = e; } } }    希尔排序相当于是插入排序的升级版，增加了一个步长参数，使用希尔排序可以让零散的数据实现跳跃行的交换，最后逐渐将数组转化为有序，这样最后使用步长为1的插入排序就非常快了。\n 快速排序 被称为二十世纪影响最大的算法之一！\n动画演示(来自@五分钟算法)：\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  template\u0026lt;typename T\u0026gt; int __partition(T *arr,int l,int r){ T v = arr[l]; int j = l; for(int i = l+1;i \u0026lt;= r;++i){ if(arr[i] \u0026lt; v){ swap(arr[i],arr[++j]); } } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void __quickSort(T *arr,int l,int r) { if(l \u0026gt;= r) return; int p = __partition(arr,l,r); __quickSort(arr,l,p-1); __quickSort(arr,p+1,r); } //快速排序 template\u0026lt;typename T\u0026gt; void quickSort(T *arr,int size) { __quickSort(arr,0,size-1); }   优化一：\n在数组的元素个数小于15个的时候使用插入排序进行优化:\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; void __quickSort(T *arr,int l,int r) { + if(r - l \u0026lt;= 15) insertionSort(arr,l,r);  int p = __partition(arr,l,r); __quickSort(arr,l,p-1); __quickSort(arr,p+1,r); }   优化二：\n使用随机值作为划分标准\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  template\u0026lt;typename T\u0026gt; int __partition(T *arr,int l,int r){ + swap(arr[l],arr[rand() % (r-l+1) + l]);  T v = arr[l]; int j = l; for(int i = l+1;i \u0026lt;= r;++i){ if(arr[i] \u0026lt; v){ swap(arr[i],arr[++j]); } } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void quickSort(T *arr,int size) { + srand(time(NULL));  __quickSort(arr,0,size-1); }   缺点:\n 在近乎有序的数组排序中，快速排序的性能很差。时间复杂度也近乎$O(n^2 )$ 对于有很多重复元素的数组，快速排序的性能也很差  快速排序版本二：两路快排 使用两个下标分别处理大于v与小于v的部分。(v为基准元素)\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  template\u0026lt;typename T\u0026gt; int __partition2(T *arr,int l,int r){ swap(arr[l],arr[rand() % (r-l+1) + l]); T v = arr[l]; int i = l + 1,j = r; while(true) { while(arr[i] \u0026lt; v \u0026amp;\u0026amp; i \u0026lt;= r) ++i; while(arr[j] \u0026gt; v \u0026amp;\u0026amp; j \u0026gt;= l+1) --j; if(i \u0026gt; j) break; swap(arr[i++],arr[j--]); } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void __quickSort2(T *arr,int l,int r) { if(r - l\u0026lt;= 15){ insertSort(arr,l,r); return; } int p = __partition2(arr,l,r); __quickSort2(arr,l,p-1); __quickSort2(arr,p+1,r); } //快速排序版本二，双路快排 template\u0026lt;typename T\u0026gt; void quickSort2(T *arr,int size) { srand(time(NULL)); __quickSort2(arr,0,size-1); }   快速排序版本三：三路快排 使用三个下标分别处理大于v、等于v与小于v的部分。(v为基准元素)\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  template\u0026lt;typename T\u0026gt; void __quickSort3(T *arr,int l,int r) { if(r - l\u0026lt;= 15){ insertSort(arr,l,r); return; } swap(arr[l],arr[rand() % (r-l+1) + l]); T v = arr[l]; int lt = l; //arr[l+1...lt] \u0026lt; v  int gt = r + 1; //arr[gt...r] \u0026gt; v  int i = l+1; //arr[lt+1...i] == v  while(i \u0026lt; gt){ if(arr[i] \u0026lt; v){ swap(arr[i++],arr[++lt]); }else if(arr[i] \u0026gt; v){ swap(arr[i],arr[--gt]); }else{ i++; } } swap(arr[l],arr[lt]); __quickSort3(arr,l,lt-1); __quickSort3(arr,gt,r); } //快速排序版本三，三路快排 template\u0026lt;typename T\u0026gt; void quickSort3(T *arr,int size) { srand(time(NULL)); __quickSort3(arr,0,size-1); }   堆排序 基数排序 桶排序 排序算法总结 图片：\n未完待续\u0026hellip;\u0026hellip;🛴\n参考：\n https://www.cnblogs.com/onepixel/p/7674659.html https://github.com/MisterBooo/Article ","description":"","id":27,"section":"posts","tags":["算法","排序","C++"],"title":"排序算法总结","uri":"https://vhope.cf/zh/posts/algorithmstructure/sort/"},{"content":"机器学习有这些基本的算法组成，要门机器学习，就需要打个地基✒\nK近邻算法-KNN-(k-Nearest-Neighbors) 可以解决的问题:\n 分类问题 回归问题  预测一个人是天才还是白痴 首先先生成模拟数据，,x1和x2分别表示两个特征\nIQ值低的数据\n1 2 3  x1_low = np.random.random(10) + 3 x2_low = np.random.random(10) + 6 x1_low,y2_low   (array([3.72183336, 3.16146551, 3.88914234, 3.85673496, 3.1573191 , 3.4293751 , 3.96033808, 3.78793864, 3.94939642, 3.57378294]), array([6.47227974, 6.49537929, 6.98666118, 6.79440424, 6.99201224, 6.73386195, 6.63275792, 6.65411763, 6.42891099, 6.49695701])) IQ值高的数据\n1 2 3  x1_high = 4 + np.random.random(8) x2_high = 7 + np.random.random(8) x1_high,x2_high   (array([4.39543051, 4.73302502, 4.02667743, 4.46232039, 4.68128181, 4.92115752, 4.45267816, 4.84647668]), array([7.40538131, 7.3356809 , 7.90412483, 7.45237382, 7.15550294, 7.3764611 , 7.52492352, 7.67692014])) 总的数据和标签\n1 2 3 4 5 6  x1 = np.append(x1_low,x1_high) x2 = np.append(x2_low,x2_high) x_train = np.c_[x1.T,x2.T] print(x_train) y_train = np.append(np.zeros_like(x_low),np.ones_like(x_high)) print(y_train)   [[3.72183336 6.47227974] [3.16146551 6.49537929] [3.88914234 6.98666118] [3.85673496 6.79440424] [3.1573191 6.99201224] [3.4293751 6.73386195] [3.96033808 6.63275792] [3.78793864 6.65411763] [3.94939642 6.42891099] [3.57378294 6.49695701] [4.28739637 7.71057536] [4.31513454 7.70173516] [4.10934692 7.38111019] [4.35094666 7.33731866] [4.01739934 7.41472044] [4.98558165 7.72054925] [4.80075428 7.12604512] [4.48912715 7.08753069]] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1.] 绘制散点图\n1 2 3 4 5  plt.scatter(x_train[y_train==0,0],x_train[y_train==0,1]) plt.scatter(x_train[y_train==1,0],x_train[y_train==1,1]) plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;IQ\u0026#39;) plt.show()    上图红色表示天才，蓝色表示白痴\n 假设输入一个样本的数据为 (4.36,7.465)，判断它天才还是白痴\n1 2 3 4 5 6 7 8  example = np.array([4.36,7.456]) # 首先再图上画出来观察 plt.scatter(x_train[y_train==0,0],x_train[y_train==0,1]) plt.scatter(x_train[y_train==1,0],x_train[y_train==1,1]) plt.scatter(example[0],example[1],color=\u0026#39;black\u0026#39;) plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;IQ\u0026#39;) plt.show()    黑点表示输入的样本\n 获取距离列表\n1 2  distance = [sqrt(sum(((x-example)**2))) for x in x_train] distance   [1.172587826601725, 1.5359938425092403, 0.6648201732802982, 0.8312548678718089, 1.2890795094301544, 1.177941448784469, 0.9151268590623418, 0.9850226059672444, 1.1061225623709607, 1.2401212526176475, 0.2647260841097585, 0.24979727210937175, 0.26160170347749107, 0.1190261413334191, 0.3450785650776031, 0.6792191910080055, 0.5505765678982287, 0.39044007348145965] 对于KNN，假设k=3，就是求出与样本最近的三个点的数据\n1 2  result = np.argsort(distance) result[:k]   array([13, 11, 12], dtype=int64)  可以得知，前三个的训练样本的点的下标分别围殴13，11，12\n 接下来根据这三个训练样本的类别来预测输入的样本是天才还是白痴，假如这三个训练样本是天才的数量多于白痴，就认为它是天才；不然，就认为它是白痴\n1 2 3 4 5 6 7  from collections import Counter votes = Counter(r) y_hat = votes.most_common(1)[0][0] if y_hat == 1: print(\u0026#34;预测它为天才\u0026#34;) else: print(\u0026#34;预测它为白痴\u0026#34;)   预测它为天才 主成分分析法-PCA-(Principal Component Analysis)  PAC主要用于数据的降维\n 二维降到一维\n 由上面两个降维的图来看，第二张图片是一个更好的图，因为图二点和点的距离相对比较大，也就是说，点之间的区分度比较高\n 更好的降维方案\n 此时点和点之间的距离最大，区分度更大\n 那么如何定义样本之间的间距呢？\n可以使用方差(Variance),方差可以表示样本整体分布的疏密程度\n$$\nVar(x) = \\frac{1}{m}\\sum_{i = 1}^{m}(x_{i} - \\bar x)^2\n$$\n可以转化成：\n​\t希望找到一条轴，使得样本投影到该轴上的各点之间的方差最大\nPCA操作步骤：\n  将样例的均值归为0(demean)\n这样，就相当于坐标轴变成如下的图：\n  当均值$\\bar x = 0$时，原来的方差公式变为\n$$\nVar(x) = \\frac{1}{m}\\sum_{i = 1}^{m}(x_{i} - \\bar x)^2 \\Rightarrow Var(x) = \\frac{1}{m}\\sum_{i = 1}^{m}x_{i}^2\n$$\n假设两个维度的特征为$w1$,$w2$,那么需要求得的直线的方向为$w =（w_{1},w_{2}）$,映射到$w$后，有:\n$$\nVar(X_{project}) = \\frac{1}{m} \\sum_{1}^{m} (X_{project}^{(i)} - \\bar X{project})^2\n$$\n使得上面的公式最大\n其实最后的结果还是向量，因为$X$每一个点都包含两个元素，即应该是\n由均值为0，得到\n  计算过程\n目标即：\n与线性回归的不同：\n PCA的两个坐标轴表示的是两个特征，而线性回归的横轴是特征，纵轴是输出标记 PCA使得点之间的方差最大，而线性回归则是需要使得输出标记尽量拟合一条直线，是在纵轴上的  决策树 例子：\n数值特征例子：\n特点：\n 非参数学习算法 可以解决分类问题 天然的解决多分类问题 也可以解决回归问题 非常好的可解释性  问题：\n 每个节点在哪个维度作划分 某个维度的哪个值作划分    支持向量机-SVM-(Support Vector Machine) 主要思想：\nSVM分类:\n  Hard Margin SVM\t解决的是线性可分问题\n  Soft Margin SVM 可解决线性不可分问题\n  🤠未完待续\u0026hellip;\u0026hellip;\n","description":"机器学习必须掌握的基础算法，学会这些基础，对后面的理解才会透彻","id":28,"section":"posts","tags":["机器学习","SVM","决策树","kNN","PCA"],"title":"机器学习基本算法","uri":"https://vhope.cf/zh/posts/machine-learning-base/"},{"content":"一些英雄的图案🌿\n","description":"","id":29,"section":"gallery","tags":[""],"title":"Hero","uri":"https://vhope.cf/zh/gallery/hero/"},{"content":"使用Scrapy爬取文章的一个小项目..\nScrapy 框架图：\n抓取小程序社区文章 创建爬虫项目 创建项目（项目名为MyTest）\n1  scrapy startproject MyTest   创建爬虫🐞(先进入到MyTest目录)\n1  scrapy genspider -t crawl wx wxapp-union.com    wx为爬虫的名字，wxapp-union.com为爬取的域名，使用了模板crawl\n 定义爬取的数据结构 爬取的数据结构类继承Item类，在items.py文件中，如下是设置需要爬取的数据结构，其中包括:标题、作者、时间、访问者、前言、正文。\n1 2 3 4 5 6 7 8 9 10  from scrapy import Item,Field # 定义文章数据结构 class ArticleItem(Item): title = Field() author = Field() _time = Field() visitors = Field() pre_talk = Field() article_content = Field()   编写爬虫规则与解析规则  爬虫的爬取网页的链接的规则和解析页面的规则都是在新建的spider文件中的类中，也即在wx.py中\n 编写的spider类如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import scrapy from scrapy.linkextractors import LinkExtractor from scrapy.spiders import CrawlSpider, Rule from MyTest.items import ArticleItem class WxSpider(CrawlSpider): name = \u0026#39;wx\u0026#39; allowed_domains = [\u0026#39;wxapp-union.com\u0026#39;] start_urls = [\u0026#39;http://www.wxapp-union.com/portal.php?mod=list\u0026amp;catid=2\u0026amp;page=255\u0026#39;] rules = ( Rule(LinkExtractor(allow=r\u0026#39;.+mod=list\u0026amp;catid=2\u0026amp;page=\\d\u0026#39;), follow=True), Rule(LinkExtractor(allow=r\u0026#39;.+article-.+\\.html\u0026#39;),callback=\u0026#34;parse_item\u0026#34;,follow=False) ) def parse_item(self, response): title = response.xpath(\u0026#39;//h1[@class=\u0026#34;ph\u0026#34;]/text()\u0026#39;).get() author = response.xpath(\u0026#39;//p[@class=\u0026#34;authors\u0026#34;]//a\u0026#39;).get() _time = response.xpath(\u0026#39;//span[@class=\u0026#34;time\u0026#34;]/text()\u0026#39;).get() visitors = response.xpath(\u0026#39;//div[contains(@class,\u0026#34;focus_num\u0026#34;)]//a/text()\u0026#39;).get() pre_talk = response.xpath(\u0026#39;//div[@class=\u0026#34;blockquote\u0026#34;]//p/text()\u0026#39;).get() article_content = response.xpath(\u0026#39;//td[@id=\u0026#34;article_content\u0026#34;]\u0026#39;).get() item = ArticleItem(title=title,author=author,_time=_time,visitors=visitors,pre_talk=pre_talk,article_content=article_content) print(\u0026#39;*\u0026#39;*40) print(title) print(\u0026#39;*\u0026#39;*40) return item    首先rules定义了爬取链接规则，有两个规则，第一个规则是爬取页面的链接，每一页有多个文章的链接，而第二个规则则是定义爬取的具体文章内容的链接。 第一个规则需要Follow，因为需要根据每一页的内容查找文章的链接；而第二个规则是文章链接，故不需要继续Follow 第一个页面链接规则不需要回调函数，因为不需要解析，只需要获取文章链接；第二个文章链接规则则需要设置回调函数来对返回的文章网页内容进行解析。  parse_item说明：\n parse_item是解析页面返回内容的函数，其返回Item数据结构，使用Xpath分别获取数据结构各个元素的内容并且返回Item\n 保存数据  pipelines是一个最后处理Item的管道\n 在pipelines.py文件中新建pipleline对返回的Item进行处理，可以保存为文件，或者存储到数据库。\n首先文件中需要导入必要的库‘\n1 2 3 4 5  import re\t# 正则处理 from html2text import HTML2Text\t# 将网页转化为Markdown格式 from scrapy.exporters import JsonLinesItemExporter\t# 输出Json文件输出器 from urllib.parse import urljoin\t# 补全URL，因为有些URL只显示相对位置 import pymongo\t# MongoDB操作库   第一个Pipeline：保存到Json文件 程序的构造函数新建一个Json文件输出器，process_item进行数据的存储，关闭的时候close_spider会调用关闭文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 存储到Json文件中 class JsonPipeline(object): def __init__(self): self.f = open(\u0026#39;wxjc.json\u0026#39;,\u0026#39;wb\u0026#39;) self.exporter = JsonLinesItemExporter(self.f, ensure_ascii=False,encoding=\u0026#34;utf-8\u0026#34;) def process_item(self, item, spider): # 将内容转化为MarkDown格式 item[\u0026#39;article_content\u0026#39;] = convert_md(item[\u0026#39;article_content\u0026#39;]) self.exporter.export_item(item) return item def close_spider(self,spider): self.f.close()   第二个Pipeline：保存到Markdown文件 方法与第一发Pipeline类似，只是写文件使用最简单的追加方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 写入Markdown class MDPipeline(object): def __init__(self): self.f = open(\u0026#39;wx_teaches.md\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) def process_item(self,item,spider): if self.f: self.f.write(\u0026#39;\\n\u0026#39;) self.f.write(\u0026#34;# \u0026#34; + item[\u0026#39;title\u0026#39;] + \u0026#39;\\n\u0026#39;) header_info = \u0026#34;作者:{} 发布时间:{} Visitors:{}\\n\u0026#34;.format(item[\u0026#39;author\u0026#39;],item[\u0026#39;_time\u0026#39;],item[\u0026#39;visitors\u0026#39;]) self.f.write(header_info) self.f.write(\u0026#39;\u0026gt; \u0026#39; + item[\u0026#39;pre_talk\u0026#39;] + \u0026#39;\\n\u0026#39;) self.f.write(item[\u0026#39;article_content\u0026#39;]) return item def close_spider(self,spider): self.f.close()   第三个Pileline：保存到MongoDB 其中使用了类方法装饰器@classmethod,意思就是直接用类名调用该函数，就能够直接返回一个MongoPipeline类了，还定义了打开spider与关闭spider的操作，就是连接数据库与关闭数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 存储到MongoDB数据库 class MongoPipeline(object): def __init__(self,mongo_uri,mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls,crawler): return cls(mongo_uri = crawler.settings.get(\u0026#39;MONGO_URI\u0026#39;), mongo_db = crawler.settings.get(\u0026#39;MONGO_DB\u0026#39;)) def open_spider(self,spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db =self.client[self.mongo_db] def process_item(self,item,spider): name = item.__class__.__name__ # \u0026lt;a href=\\\u0026#34;space-uid-17761.html\\\u0026#34;\u0026gt;Rolan\u0026lt;/a\u0026gt;  item[\u0026#39;author\u0026#39;] = re.search(\u0026#39;\u0026lt;a.*?\u0026gt;(.*?)\u0026lt;/a\u0026gt;\u0026#39;,item[\u0026#39;author\u0026#39;]).group(1) self.db[name].insert(dict(item)) return item def close_spider(self,spider): self.client.close()    最后需要在settings.py中添加如下字段:\n1 2  MONGO_URI = \u0026#39;localhost\u0026#39; MONGO_DB = \u0026#39;WX\u0026#39;    最后需要在settings.py中添加如下字段 1 2 3 4 5 6 7 8 9  ITEM_PIPELINES = { \u0026#39;MyTest.pipelines.JsonPipeline\u0026#39;: 300, \u0026#39;MyTest.pipelines.MDPipeline\u0026#39;: 301, \u0026#39;MyTest.pipelines.MongoPipeline\u0026#39;: 400, } # 修改为False ROBOTSTXT_OBEY = False # 设置延迟1s DOWNLOAD_DELAY = 1   开始爬取 可以在项目目录中新建一个脚本start.py，文件内容如下，自动运行脚本\n1 2  from scrapy import cmdline cmdline.execute(\u0026#39;scrapy crawl test\u0026#39;.split(\u0026#39;\u0026#39;))   爬取结果 Json结果 Markdown结果 Markdown文件由于太大了使用Markdown文件打不开，只好使用文本编辑器打开\nMongoDB结果 ","description":"","id":30,"section":"posts","tags":["爬虫","Scrapy"],"title":"Scrapy框架","uri":"https://vhope.cf/zh/posts/spider/scrapy-1/"},{"content":"好的工具🗝 就成功了一半。\n工具🚡 创造与记录 GitBook 使用前提：  安装NodeJS 使用npm安装：npm install gitbook-cli -g(这是命令行工具)  GitNote GitMind GitMind 是一款全新的云端智能思维导图、流程图制作软件，同时支持在电脑、手机浏览器上使用。\n官网：https://gitmind.cn/\n微信版本：\nNotion Typora caliibre 信息聚合 irreader🔖 下载地址:http://irreader.fatecore.com/\n羽雀-云端知识库☁ 如果英语不好，或者看着英文的文档很烦恼，可以试试这个。🍃\n地址:https://www.yuque.com/\n图片   https://xinquji.com/r/d232a93deb8766\n  https://burst.shopify.com/\n ","description":"实用的工具集合","id":31,"section":"talks","tags":[""],"title":"Tools","uri":"https://vhope.cf/zh/talks/tools/"},{"content":"All about Intresting in Github.\nPython好玩的库 html2text  将网页转化为Markdown文件格式\n 使用前提： 1  pip install htmltotext   使用方法： 1 2 3  ## 转化为TEXT h = HTML2Text() text = h.handle(parse_html) # text为markdown文件   pypandoc  对文件进行任意的转换\n 使用前提： 安装pypandoc库：pip install pypandoc.\n使用方法 导入库:import pypandoc\nMarkdown \u0026mdash;\u0026ndash;\u0026gt; docx 1  output = pypandoc.convert_file(\u0026#39;somefile.md\u0026#39;, \u0026#39;docx\u0026#39;, outputfile=\u0026#34;somefile.docx\u0026#34;)   Markdown \u0026mdash;\u0026ndash;\u0026gt; Rst 1 2 3  output = pypandoc.convert_file(\u0026#39;somefile.md\u0026#39;, \u0026#39;rst\u0026#39;)\t# way1 output = pypandoc.convert_file(\u0026#39;somefile.txt\u0026#39;, \u0026#39;rst\u0026#39;, format=\u0026#39;md\u0026#39;)\t# way 2 output = pypandoc.convert_text(\u0026#39;#some title\u0026#39;, \u0026#39;rst\u0026#39;, format=\u0026#39;md\u0026#39;)\t# 直接转化文本    其中有对应的工具Pandoc\n 如何把 Markdown 文件批量转换为 PDF mdout转换脚本 项目地址:https://github.com/JabinGP/mdout\n使用方法：  打开项目地址查看，其中主要命令为:mdout filename -t pdf\n","description":"Github上好玩的那些库~","id":32,"section":"talks","tags":[""],"title":"Good库","uri":"https://vhope.cf/zh/talks/github-lib/"},{"content":"🚴一些收集视频的方法⚒\n视频归总方法 BiliBli视频嵌入代码 使用方法 首先找到嵌入代码\n然后复制代码到Markdown文件就可以得到如下显示效果：\n 代码如下: 1  \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=6731067\u0026amp;cid=10959711\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt;    其中可以在ifram中添加相关属性\n weibo上传的视频 使用方法 在微博中上传视频后，打开视频的页面，按F12打开工具,鼠标点击视频找到链接\n接下来直接在Markdown中添加代码\nYour browser does not support the video tag.\n代码如下:\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/03/02/GabXC4JmfN6H2hE.png\u0026#34; src=\u0026#34;https://f.video.weibocdn.com/00393mgEgx07BmNCEF4j01041200eeW00E010.mp4?label=mp4_720p\u0026amp;template=1280x720.25.0\u0026amp;trans_finger=721584770189073627c6ee9d880087b3\u0026amp;Expires=1583079687\u0026amp;ssig=%2BAmJANwAPn\u0026amp;KID=unistore,video\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   QQ空间发布的视频 使用方法 与微博的操作类似，打开视频页面，先点击下载按钮\n然后会自动跳转，搜索栏上的地址就是视频的地址\n接下来直接在Markdown中添加代码\nYour browser does not support the video tag.\n代码如下:\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/03/02/GabXC4JmfN6H2hE.png\u0026#34; src=\u0026#34;http://photovideo.photo.qq.com/1075_0b53zeiu6vidieapa3kya5pdbsiej6zqhfsa.f20.mp4?dis_k=97f710c26b204f7f2312614fbcf8f897\u0026amp;dis_t=1583082992\u0026amp;vuin=1427298682\u0026amp;save=1\u0026amp;d=1\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   ","description":"","id":33,"section":"posts","tags":["blog","视频","BliBli","weibo"],"title":"视频的收集","uri":"https://vhope.cf/zh/posts/settings/collect-videos/"},{"content":"在Pt页面增加了一些用JS实现的PPT，主要展示一些效果。🔌\n网页PPT 主题 beige black blood monokai league moon night serif simple solarized sky white 使用方法🌌 在markdown文件的ymal头部添加:revealTheme: serif\n在线制作PPT Slides https://slides.com/\n","description":"","id":34,"section":"posts","tags":["ppt","blog"],"title":"Slides和网页PPT","uri":"https://vhope.cf/zh/posts/settings/ppt-use/"},{"content":"数据分析，begin！📅\n Latex公式参考：\nhttps://www.cnblogs.com/1024th/p/11623258.html\n 概率分析\n中位数\n$$\n\\frac{df(x)}{dx}\\mid_{x_{mode}=0}\n$$\n​\n","description":"","id":37,"section":"posts","tags":["概率","Latex"],"title":"Data Analysis Begin","uri":"https://vhope.cf/zh/posts/bigdata/data-analysis-begin/"},{"content":"使用MXNet的好处你永远想象不到。🉑\n本地环境搭建教程  参考:\nhttps://discuss.gluon.ai/t/topic/13576?u=bigbigwolf-ai\n 范数 L0范数：指向量中非0元素的个数。（难优化求解）\nL1范数：指向量中各个元素的绝对值之和\nL2范数：指向量各元素的平方和然后求平方根\n设$n$维向量$x$中的元素为$x_1, \\ldots, x_n$。向量$x$的$L_{p}$范数为:\n$$\n|\\boldsymbol{x}|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.\n$$\n$L_{1}$范数：\n$$\n|\\boldsymbol{x}|_1 = \\sum_{i=1}^n \\left|x_i \\right|.\n$$\n$L_{2}$范数：\n$$\n|\\boldsymbol{x}|_2 = \\sqrt{\\sum_{i=1}^n x_i^2}.\n$$\n设$X$是一个$m$行$n$列矩阵。矩阵$X$的Frobenius范数为该矩阵元素平方和的平方根：\n$$\n|\\boldsymbol{X}|_F = \\sqrt{\\sum_{i=1}^m \\sum_{j=1}^n x_{ij}^2},\n$$\n查阅文档 1 2  from mxnet import nd print(dir(nd.random))   ['NDArray', '_Null', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_internal', '_random_helper', 'current_context', 'exponential', 'exponential_like', 'gamma', 'gamma_like', 'generalized_negative_binomial', 'generalized_negative_binomial_like', 'multinomial', 'negative_binomial', 'negative_binomial_like', 'normal', 'normal_like', 'numeric_types', 'poisson', 'poisson_like', 'randint', 'randn', 'shuffle', 'uniform', 'uniform_like']  help函数可以查询具体的函数作用及用法\n1  help(nd.ones_like)   Help on function ones_like: ones_like(data=None, out=None, name=None, **kwargs) Return an array of ones with the same shape and type as the input array. Examples:: x = [[ 0., 0., 0.], [ 0., 0., 0.]] ones_like(x) = [[ 1., 1., 1.], [ 1, 1., 1.]] Parameters ---------- data : NDArray The input out : NDArray, optional The output NDArray to hold the result. Returns ------- out : NDArray or list of NDArrays The output of this function.  线性回归 导入必要的库\n1 2 3 4 5  %matplotlib inline from IPython import display from matplotlib import pyplot as plt from mxnet import autograd, nd import random   生成数据集，其中每个例子输入数据个数为2，有1000个数据\n1 2 3 4 5 6 7  num_inputs = 2 num_examples = 1000 true_w = nd.array([2, -3.4]) true_b = nd.array([4.2]) features = nd.random.normal(scale=1, shape=(num_examples, num_inputs)) labels = nd.dot(true_w,features.T) + true_b labels += nd.random.normal(scale=0.01, shape=labels.shape)   查看数据\n1  features[0], labels[0]   ( [ 0.28752208 -0.04466231] \u0026lt;NDArray 2 @cpu(0)\u0026gt;, [4.927063] \u0026lt;NDArray 1 @cpu(0)\u0026gt;)  定义相关函数\n1 2 3 4 5 6 7 8 9 10 11  def use_svg_display(): # 用矢量图显示 display.set_matplotlib_formats(\u0026#39;svg\u0026#39;) def set_figsize(figsize=(3.5, 2.5)): use_svg_display() # 设置图的尺寸 plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = figsize set_figsize() plt.scatter(features[:, 1].asnumpy(), labels.asnumpy(), 1); # 加分号只显示图   data_iter函数作用:\n 扰乱读取顺序，使得读取随机 按Batch_size分段取数据，需要判断是否到结尾，使用yield构建生成器节省内存  1 2 3 4 5 6 7 8  # 本函数已保存在d2lzh包中方便以后使用 def data_iter(batch_size, features, labels): num_examples = len(features) indices = list(range(num_examples)) random.shuffle(indices) # 样本的读取顺序是随机的 for i in range(0, num_examples, batch_size): j = nd.array(indices[i: min(i + batch_size, num_examples)]) yield features.take(j), labels.take(j) # take函数根据索引返回对应元素   1 2 3 4 5  batch_size = 10 for X, y in data_iter(batch_size, features, labels): print(X, y) break   [[-0.65439206 0.74410725] [ 0.69013244 -0.6483847 ] [-0.59409887 0.3589477 ] [-0.47491348 0.6438462 ] [ 0.5074032 0.42834154] [-0.18589513 -0.21707669] [ 0.70281196 -1.3320632 ] [ 1.2072632 1.6909351 ] [-0.17264698 -1.5742793 ] [-1.6516455 -0.29966688]] \u0026lt;NDArray 10x2 @cpu(0)\u0026gt; [ 0.37379816 7.7938933 1.7758217 1.0414512 3.743439 4.5605783 10.148926 0.84148276 9.19984 1.9295483 ] \u0026lt;NDArray 10 @cpu(0)\u0026gt;  初始化\n1 2  w = nd.random.normal(scale=0.01, shape=(num_inputs, 1)) b = nd.zeros(shape=(1,))   添加保存梯度的空间\n1 2  w.attach_grad() b.attach_grad()   1 2  def linreg(X, w, b): # 本函数已保存在d2lzh包中方便以后使用 return nd.dot(X, w) + b   1 2  def squared_loss(y_hat, y): # 本函数已保存在d2lzh包中方便以后使用 return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2   1 2 3  def sgd(params, lr, batch_size): # 本函数已保存在d2lzh包中方便以后使用 for param in params: param[:] = param - lr * param.grad / batch_size   开始训练\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  lr = 0.03 num_epochs = 3 net = linreg loss = squared_loss for epoch in range(num_epochs): # 训练模型一共需要num_epochs个迭代周期 # 在每一个迭代周期中，会使用训练数据集中所有样本一次（假设样本数能够被批量大小整除）。X # 和y分别是小批量样本的特征和标签 for X, y in data_iter(batch_size, features, labels): with autograd.record(): l = loss(net(X, w, b), y) # l是有关小批量X和y的损失 l.backward() # 小批量的损失对模型参数求梯度 sgd([w, b], lr, batch_size) # 使用小批量随机梯度下降迭代模型参数 train_l = loss(net(features, w, b), labels) print(\u0026#39;epoch %d, loss %f\u0026#39; % (epoch + 1, train_l.mean().asnumpy()))   epoch 1, loss 0.040809 epoch 2, loss 0.000157 epoch 3, loss 0.000051  对比\n1  true_w, w   ( [ 2. -3.4] \u0026lt;NDArray 2 @cpu(0)\u0026gt;, [[ 1.9991481] [-3.3992586]] \u0026lt;NDArray 2x1 @cpu(0)\u0026gt;)  1  true_b, b   ( [4.2] \u0026lt;NDArray 1 @cpu(0)\u0026gt;, [4.19921] \u0026lt;NDArray 1 @cpu(0)\u0026gt;) ","description":"","id":38,"section":"posts","tags":["python","MXNet","深度学习","liner"],"title":"MXNet回顾","uri":"https://vhope.cf/zh/posts/dl/mxnet-begin/"},{"content":"重新学习一下DL，这次使用PyTorch框架🔦\n 参考资料：\nhttps://github.com/dsgiitr/d2l-pytorch\n 导入PyTorch库 1 2  import torch import numpy as np   创建Tensor 5x3的未初始化的张量\n1 2  x = torch.empty(5,3) x   tensor([[1.0286e-38, 9.0919e-39, 8.9082e-39], [9.2755e-39, 8.4490e-39, 1.0194e-38], [9.0919e-39, 8.4490e-39, 8.7245e-39], [1.0102e-38, 1.0653e-38, 8.7245e-39], [1.0286e-38, 9.6429e-39, 4.2244e-39]])  5x3随机初始化的张量\n1 2  x = torch.rand(5,3) x   tensor([[0.2518, 0.0419, 0.3233], [0.1493, 0.1408, 0.8559], [0.5145, 0.4648, 0.4605], [0.2555, 0.2502, 0.4506], [0.9798, 0.5056, 0.2726]])  5x3全0的张量\n1 2  x = torch.zeros(5,3) # 可以指定类型 x = torch.zeros(5,3,dtype=torch.long) x   tensor([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])  数据张量\n1 2  x = torch.tensor([5.5,3]) x   tensor([5.5000, 3.0000])  默认创建和原来的张量一样的dtype和device的张量，也可以另外设置\n1 2 3 4  x = x.new_ones(5,3,dtype=torch.double) print(x) x = torch.randn_like(x,dtype=torch.float) print(x)   tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) tensor([[-0.7829, -0.4010, 0.3230], [ 0.2660, 0.4766, 0.3186], [ 0.6096, 1.1226, -1.7942], [ 1.3255, 0.1835, -0.9078], [ 1.7743, -0.0944, -0.1704]])  获取Tensor的形状\n1  x.shape,x.size()   (torch.Size([5, 3]), torch.Size([5, 3]))  其他创建Tensor的函数:\n   函数 功能     Tensor(*sizes) 基础构造函数   tensor(data,) 类似np.array的构造函数   ones(*sizes) 全1Tensor   zeros(*sizes) 全0Tensor   eye(*sizes) 对角线为1，其他为0   arange(s,e,step) 从s到e，步长为step   linspace(s,e,steps) 从s到e，均匀切分成steps份   rand/randn(*sizes) 均匀/标准分布   normal(mean,std)/uniform(from,to) 正态分布/均匀分布   randperm(m) 随机排列     这些创建方法都可以在创建的时候指定数据类型dtype和存放device(cpu/gpu)\n 操作 1 2 3  x = torch.rand(5,3) y = torch.rand(5,3) x,y   (tensor([[0.7706, 0.7674, 0.0476], [0.3675, 0.3652, 0.1215], [0.2842, 0.4927, 0.0903], [0.1202, 0.7635, 0.1862], [0.1391, 0.5023, 0.0580]]), tensor([[0.2149, 0.4744, 0.6664], [0.5948, 0.3451, 0.6485], [0.2303, 0.6660, 0.3796], [0.7194, 0.3815, 0.7536], [0.7886, 0.0630, 0.2459]]))  加法，三种方法\n1 2 3 4  z1 = torch.add(x,y) z2 = x.add_(y) # x会改变 z3 = x + y z1,z2,z3   (tensor([[0.9855, 1.2418, 0.7140], [0.9623, 0.7103, 0.7700], [0.5145, 1.1588, 0.4699], [0.8396, 1.1450, 0.9397], [0.9276, 0.5653, 0.3040]]), tensor([[0.9855, 1.2418, 0.7140], [0.9623, 0.7103, 0.7700], [0.5145, 1.1588, 0.4699], [0.8396, 1.1450, 0.9397], [0.9276, 0.5653, 0.3040]]), tensor([[1.2004, 1.7163, 1.3804], [1.5571, 1.0554, 1.4185], [0.7448, 1.8248, 0.8495], [1.5590, 1.5265, 1.6933], [1.7162, 0.6283, 0.5499]]))  索引\n1 2  y = x[0, :] y   tensor([0.9855, 1.2418, 0.7140])  修改y会修改原来的数据，因为共享内存\n1 2 3  y+=1 print(y) print(x[0,:])   tensor([1.9855, 2.2418, 1.7140]) tensor([1.9855, 2.2418, 1.7140])  PyTorch还提供了一些高级的选择函数:\n   函数 功能     index_select(input, dim, index) 在指定维度dim上选取，比如选取某些行、某些列   masked_select(input, mask) 例子如上，a[a\u0026gt;0]，使用ByteTensor进行选取   nonzero(input) 非0元素的下标   gather(input, dim, index) 根据index，在dim维度上选取数据，输出的size与index一样    改变形状 用view()来改变Tensor的形状：\n1 2 3  y = x.view(15) z = x.view(-1,5) # -1为自动计算维度 print(x.size(),y.size(),z.size())   torch.Size([5, 3]) torch.Size([15]) torch.Size([3, 5])   注意view()返回的新Tensor与源Tensor虽然可能有不同的size，但是是共享data的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，view仅仅是改变了对这个张量的观察角度，内部数据并未改变)\n 1 2  x += 1 x,y   (tensor([[4.9855, 5.2418, 4.7140], [3.9623, 3.7103, 3.7700], [3.5145, 4.1588, 3.4699], [3.8396, 4.1450, 3.9397], [3.9276, 3.5653, 3.3040]]), tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040]))  使用reshape()函数会拷贝一份\n1 2  y = x.reshape(15) y   tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040])  也可以使用克隆后view\n 使用clone还有一个好处是会被记录在计算图中，即梯度回传到副本时也会传到源Tensor。\n 1 2  y = x.clone().view(15) y   tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040])  item(), 它可以将一个标量Tensor转换成一个Python number：\n1 2 3  x = torch.randn(1) print(x) print(x.item())   tensor([0.3816]) 0.3816383183002472  线性代数API    函数 功能     trace 对角线元素之和(矩阵的迹)   diag 对角线元素   triu/tril 矩阵的上三角/下三角，可指定偏移量   mm/bmm 矩阵乘法，batch的矩阵乘法   addmm/addbmm/addmv/addr/baddbmm.. 矩阵运算   t 转置   dot/cross 内积/外积   inverse 求逆矩阵   svd 奇异值分解    广播机制 什么是广播机制？简单的说就是形状不同的运算会自动变换为适合的运算\n1 2 3 4 5  x = torch.arange(3).view(1,3) print(x) y = torch.arange(2).view(2,1) print(y) print(x + y)   tensor([[0, 1, 2]]) tensor([[0], [1]]) tensor([[0, 1, 2], [1, 2, 3]]) ","description":"","id":39,"section":"posts","tags":["PyTorch","python","Tensor"],"title":"Pytorch Begin","uri":"https://vhope.cf/zh/posts/dl/pytorch-begin/"},{"content":"一份还算可以的翻墙清单📇\n本文介绍的方法归总: PC端 Mobile端   谷歌访问助手 插件(可以现在极简插件中下载） Astar VPN 插件 SSR    云帆VPN 老王VPN     'use strict'; var containerId = JSON.parse(\"\\\"635a6660b3cf14fc\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  PC端 谷歌访问助手 首先是不能通过谷歌的应用商店下载的，可以在国内的一些插件网站下载，这些推荐极简插件，找到谷歌访问助手进行下载。\n将CRT文件拖入谷歌浏览器的拓展程序界面中(这里用的助手是另一个版本)\n之后就可以访问谷歌的一部分服务了，例如谷歌搜索，Gmail，谷歌应用商店.\n安装过程可能会出现一些问题，具体可以参考:安装指引    其他类似的插件   PP谷歌访问助手:https://chrome.zzzmh.cn/info?token=kahndhhhcnignmbbpiobmdlgjhgfkfil 集装箱:https://chrome.zzzmh.cn/info?token=kbgigmcnifmaklccibmlepmahpfdhjch 谷歌访问助手:https://chrome.zzzmh.cn/info?token=gocklaboggjfkolaknpbhddbaopcepfp 谷歌学术助手:https://chrome.zzzmh.cn/info?token=jkicnibdkfemnfhojeajbldjgdddpajk 谷歌服务助手:https://chrome.zzzmh.cn/info?token=cgncbhnhlkbdieckbbmeppcefokppagh 谷歌上网助手:https://chrome.zzzmh.cn/info?token=nonmafimegllfoonjgplbabhmgfanaka    Astar VPN Astar VPN也是一个Chrome插件，在谷歌应用商店可以下载。经过第一步之后，we\u0026rsquo;re good to go!😁\n应用商店搜索Astar VPN进行下载，直接就可以在Chrome中进行自动安装。\n之后再插件选项中开启该插件，其中可以选择不同的服务器进行连接，速度还不错。\n使用该插件进行科学上网是真正意义上的，它可以访问国外任何网站!  ShadowsSocks ShadowsSocks是一款在github上的开源软件，可以用来进行连接节点服务器，但是节点需要自己去找，下面会介绍节点的选择。\n首先去github下载这个软件，链接为：https://github.com/shadowsocks/shadowsocks-windows/releases/tag/4.1.9.2\n将两个文件解压之后，将第一个文件夹内的exe文件移动到第二个文件夹的根目录并且打开即可\n关于免费节点，这里有一个网址：https://free-ss.site/(需要科学上网)\n右键ShadowSocks的图标，选择服务器，在选择扫描屏幕二维码，即可添加节点，之后点击系统代理并开启系统代理为全局模式。\n之后就可以🤙🤙🤙!\nMobile端 下面两个软件都是需要科学上网的，建议先在PC端下载再传到手机安装。  云帆VPN 下载地址：https://apkpure.com/store/apps/details?id=cc.dingnet.yunfangp\n虽然每天只能使用1小时，但是基本够了。\n老王VPN 下载地址：https://apkpure.com/wang-vpn-%E2%9D%A4%EF%B8%8F-free-fast-stable-best-vpn-just-try-it/com.findtheway\n老王的东西永远免费！\n参考链接\n 2020年Android高速稳定翻墙方法 Windows上长期有效的免费且高速稳定翻墙法！ ","description":"","id":40,"section":"posts","tags":["科学上网","ShadowShocks"],"title":"2020翻墙指南👈","uri":"https://vhope.cf/zh/posts/settings/2020-fanqiang/"},{"content":"👱‍♀介绍一些markdown中比较实用的一些写作方法。\n任务列表✍  a task list item list syntax required normal formatting, @mentions, #1234 refs incomplete completed  上面的代码如下：\n1 2 3 4 5  - [ ] a task list item - [ ] list syntax required - [ ] normal **formatting**, @mentions, #1234 refs - [ ] incomplete - [x] completed   数学公式📐 使用MathJax渲染LaTeX数学表达式。💡\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\n\\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\\n\\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\\n\\end{vmatrix}\n$$\n上面的代码如下：\n1 2 3 4 5 6 7  $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\\\\\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\\\\\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\\\\\ \\end{vmatrix} $$   $$\n\\begin{align*}\ny = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\n\u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\n\u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\n\u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\n\u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\n\u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t)\n\\end{align*}\n$$\n上面代码如下：\n1 2 3 4 5 6 7 8 9 10  $$ \\begin{align*} y = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\\\\ \u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\\\\ \u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\\\\ \u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\\\\ \u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\\\\ \u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{align*} $$   脚注👣 如下是使用的代码，将鼠标悬停在“ fn1”或“ fn2”上标上可以查看脚注的内容。您可以将任何喜欢的唯一标识用作脚注标记（例如“ fn1”）。\n1 2  [^fn1]: Here is the *text* of the first **footnote**. [^fn2]: Here is the *text* of the second **footnote**   你也可以内嵌脚注，就像^[Here is the text of the first footnote.]\n水平线〰 🌟在空行输入***或---，如下：\nYMAL首要事项🤔 包含YAML前事块的文件将作为特殊文件进行处理，下面是一个例子\n1 2 3 4  ---layout:posttitle:BloggingLikeaHacker---  目录📑 输入[toc]并回车即可。\n内部链接🔗 这是一个跳转到任务列表的链接,this link ！\n代码如下：\n1  [this link](#任务列表✍)   参考链接📖 参考链接使用两组方括号的格式，第一个是显示的文字，第二个括号内是查找的id，代码如下：\n1 2 3 4 5  This is [an example][id] reference-style link. Then, anywhere in the document, you define your link label on a line by itself like this: [id]: http://example.com/ \u0026#34;Optional Title Here\u0026#34;   隐式链接，直接使用Google查阅：\n[Google][] And then define the link: [Google]: http://google.com/ 删除线❌ 删除Mistaken text.，代码为~~Mistaken text.~~\n高亮🔆 ==highlight==，使用两个等号在两边进行包围，代码如下：\n1  ==highlight==   插入视频📹 Your browser does not support the video tag.\n上面的代码即：\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/02/29/S4oN2djFDZYiqAx.png\u0026#34; src=\u0026#34;https://files.catbox.moe/bqrntc.flv\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; loop=\u0026#34;loop\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   插入音乐🎼 Your browser does not support the audio tag.\n上面的代码即：\n1  \u0026lt;audio src=\u0026#34;https://files.catbox.moe/wjiywu.mp3\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; loop=\u0026#34;loop\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the audio tag.\u0026lt;/audio\u0026gt;   更多：\n随机图片🌳 网址:https://picsum.photos/1920/1080\n","description":"","id":41,"section":"posts","tags":["markdown","Typora"],"title":"Markdown深入使用","uri":"https://vhope.cf/zh/posts/settings/markdown-deep/"},{"content":"SM.MS sm.ms 支持的图片格式包括 JPG、JPEG、GIF、PNG 及 BMP，单档不超过 5 MB，单次可上传图片最大 10 张。图片永久保存，请勿上传政治相关图片\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤(15 年成立)\n如优图床 支持大量免费图床分发，网站稳定性未知\n速度：动态 ❤ ❤ ❤ ❤ ❤\n牛图网 速度：日本服务器 ❤ ❤ ❤ ❤(2010 年)\nniupic.com 稳定性不错，不要上传违法图片\nvim-cn 上传界面十分简单，但十分稳定。\n速度： ❤ ❤ ❤(12年到现在)\nimgbb 无需注册，支持最大 16M 图片上传，支持 https，速度不错\n速度：亚太服务器 ❤ ❤ ❤ ❤\nmeotu 16 年成立的免费图片外链网站。上传下载速度快。\n需要注册，默认原图上传，支持 https\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\n遇见图床 18 年成立的免费图片外链网站。上传下载速度快。\n需要注册，默认原图上传，支持最大 10M，支持 https\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\nz4a 图床 需要注册，支持 HTTPS 速度块\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\nz4a.net 由于成立时间较短，稳定性未知。\nupload 2012 年成立的免费图片上传外链网站，至今依然稳定\n无需注册，默认原图上传，支持 https\n速度：亚太服务器 ❤ ❤ ❤\ncatbox 无需注册，支持 https\n速度：海外服务器 ❤ ❤ ❤\ncatbox.moe 支持 200m 主流格式文件外链网站\n","description":"","id":42,"section":"posts","tags":["photo","图床"],"title":"几款好用的图床","uri":"https://vhope.cf/zh/posts/settings/free-image-bed/"},{"content":"Freenom 是目前为数不多的免费域名提供商，提供 .ga, .ml, .gq, .tk, .cf 五个免费顶级域。当然也有一些付费的域名，对于普通人来说，免费域名就够了。😏\n第一步，找域名 打开Freenom，登陆后直接在搜索栏搜索自己想要的域名名字，然后系统会返回可以使用的免费域名，选择一个结算即可\n第二步，配置解析服务 使用cloudflare解析服务 打开cloudflare，首先需要注册一个账号。然后他会要求输入需要解析的域名\n填写相应的DNS信息，并且将下面的NS信息填写到freenom的custom nameservers\n等待个几分钟就好了。Over 🤞\n","description":"","id":43,"section":"posts","tags":["域名","freenom"],"title":"Freenom 免费域名申请","uri":"https://vhope.cf/zh/posts/settings/freenom-domain/"},{"content":"安装MinGW之后，我们可以那它来作为C或C++的编译器.🕸\nCMD编译程序  编译过程分为四个步骤：预处理、编译、汇编、链接。\n 使用g++可以在命令行分别实现上面四个步骤。使用下面的程序作为例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; // this is my test program  #ifndef myNum#define myNum 666 #endifint main() { cout \u0026lt;\u0026lt; \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;myNum = \u0026#34; \u0026lt;\u0026lt; myNum \u0026lt;\u0026lt;endl; return 0; }   预处理 预处理主要完成的工作有：\n（1）删除#define，展开宏；\n（2）处理条件编译指令，预处理程序先判断条件，在根据条件修改源代码；\n（3）删除注释；\n（4）添加行号，以及文件名标识，便于调试\n（5）删除“#include”，插入相应的头文件；\n 使用下面的命令，得到预处理后的文件test.i\n1  g++ -E test.cpp -o test.i   查看test.i文件\n编译 使用下面的代码生成汇编文件test.s\n1  g++ -S test.i -o test.s   注意：直接从test.cpp文件得到汇编文件也可以。直接使用命令 g++ -S test.cpp -o test.s  查看test.s文件\n汇编 使用下面的命令将汇编指令转化为机器指令，生成文件test.o\n1  g++ -c test.s -o test.o   查看文件test.o\n链接 通过链接库文件，可以将目标文件test.o转化为可执行文件test.exe\n注意:Windows下可执行文件的后缀为exe，而Linux下不需要后缀。  CMD输入以下代码\n1  g++ test.o -o test.exe   注意:Windows下.o文件已经可以执行，在命令行输入test.o就可以看到如下的效果：\n 另外一个命令是\n1  g++ test.o -o test.exe -L 所需库文件路径   其中L为link的缩写。 快速生成可执行文件 一般情况下，可以直接使用g++ test.cpp -o test 就可以生成可执行程序了。\n运行程序 如下：\nMinGW + SublimeText配置C++环境 下载MinGW和SublimeText SublimeText下载\nMinGW下载及相关配置\n使用SublimeText 因为前面配置好环境变量了，所以可以直接在SublimeText下编译运行程序\nTools-\u0026gt;build(或者按快捷键Ctrl+B 或 Ctrl + Shift + B)\n可以在最下面一栏看到输出结果\nenjoy it!\n解决SublimeText下不能使用输入的问题 SublimeText是把shell执行的结果读回来显示在终端，这意味无法使用输入语句，无法使用调试功能。  解决方法:让程序直接运行在CMD\n在sublime-\u0026gt;Tools\u0026gt;Build System里新建编译系统，输入以下内容构建C++编译环境,保存名字为C++Buider\n1 2 3 4 5 6 7 8 9 10 11 12  {\u0026#34;cmd\u0026#34;: [\u0026#34;g++\u0026#34;,\u0026#34;$file_name\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_base_name}\u0026#34;,\u0026#34;-lm\u0026#34;,\u0026#34;-Wall\u0026#34;],\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c, source.c++\u0026#34;,\u0026#34;shell\u0026#34;: false,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;,\u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;,\u0026#34;/c\u0026#34;,\u0026#34;g++\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;${file}\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;,\u0026#34;\u0026amp;\u0026amp;\u0026#34;,\u0026#34;start\u0026#34;,\u0026#34;cmd\u0026#34;,\u0026#34;/k\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;]}]}  然后可以使用快捷键Ctrl + Shift + B，会显示如下，使用命令行打开模式选项即可\n结果如下：\n其他编译环境的配置也类似：\nC编译配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12  {\u0026#34;cmd\u0026#34;: [\u0026#34;gcc\u0026#34;,\u0026#34;$file_name\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_base_name}\u0026#34;,\u0026#34;-lm\u0026#34;,\u0026#34;-Wall\u0026#34;],\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c, source.c++\u0026#34;,\u0026#34;shell\u0026#34;: false,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;,\u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;,\u0026#34;/c\u0026#34;,\u0026#34;gcc\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;${file}\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;,\u0026#34;\u0026amp;\u0026amp;\u0026#34;,\u0026#34;start\u0026#34;,\u0026#34;cmd\u0026#34;,\u0026#34;/k\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;]}]}  Java编译配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  { \u0026#34;cmd\u0026#34;: [\u0026#34;javac\u0026#34;, \u0026#34;$file_name\u0026#34;], \u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;source.java\u0026#34;, \u0026#34;shell\u0026#34;: false, \u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;, \u0026#34;variants\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;javac\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;\u0026amp;\u0026amp;\u0026#34;, \u0026#34;start\u0026#34;, \u0026#34;cmd\u0026#34;, \u0026#34;/k\u0026#34;, \u0026#34;java $file_name\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;javac\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;\u0026amp;\u0026amp;\u0026#34;, \u0026#34;start\u0026#34;, \u0026#34;cmd\u0026#34;, \u0026#34;/k\u0026#34;, \u0026#34;gdb ${file_path}/${file_base_name}\u0026#34;] }] }   解决不能输入中文的问题 使用下面的编译配置文件即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  {\u0026#34;encoding\u0026#34;: \u0026#34;GBK\u0026#34;,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file_name\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34;\u0026#34;,\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c++\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;Run in sublime\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file_name\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; cmd /c \\\u0026#34;${file_path}/${file_base_name}\\\u0026#34;\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;CMD Run\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; start cmd /c \\\u0026#34;\\\u0026#34;${file_path}/${file_base_name}\\\u0026#34; \u0026amp; pause\\\u0026#34;\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;gdb Debug\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -g -std=c++11 \\\u0026#34;$file\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; start cmd /c gdb ${file_path}/${file_base_name} \u0026amp; pause\u0026#34;}]}  配置代码格式化 从菜单里选View-\u0026gt;Show Console，跳出Console，下面有一行输入的（光标位置），把下面这段代码输入进去回车(只适用sublime Text 3)\n1  import urllib.request,os; pf = \u0026#39;Package Control.sublime-package\u0026#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), \u0026#39;wb\u0026#39;).write(urllib.request.urlopen( \u0026#39;http://sublime.wbond.net/\u0026#39; + pf.replace(\u0026#39;\u0026#39;,\u0026#39;%20\u0026#39;)).read())   安装CoolFormat，按Ctrl+Shift+P，然后输入install,就会出现“Package Control: Install Package”，输入CoolFormat进行下载，下载完成之后输入Ctrl+Shift+P，然后输入CoolFormat，选下Formatter Settings，可以看到如下配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ;Pleasevisithttp://akof1314.github.io/CoolFormat/doc/index.htmlformoreinformation[SynTidy]C++=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;Java=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;C#=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;Objective-C=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;HTML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-fu-js-ll-n-ox-pe-qa-qn-m-wa-wj-wp-ws-sw-fo-i0-d1-ce0-ie0-oe0-w0-sbo0\u0026#34;\u0026#34;XML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-js-ll-n-ix-qa-qn-m-wa-wj-wp-ws-sw-fo-i1-ce0-ie0-oe0-w0\u0026#34;\u0026#34;PHP=\u0026#34;\u0026#34;-sas-icd-samt-salo-saeo-saro-sabo-saao-samp-aas-rsl-iel-rpc-rst-st\u0026#34;\u0026#34;JavaScript=\u0026#34;\u0026#34;-nb-cn4\u0026#34;\u0026#34;CSS=\u0026#34;\u0026#34;-c2-rub-cl0-os1-cc-cf-cfp0-rs2\u0026#34;\u0026#34;JSON=\u0026#34;\u0026#34;-cn3\u0026#34;\u0026#34;SQL=\u0026#34;\u0026#34;-cn2-el-ml0\u0026#34;\u0026#34;Verilog=\u0026#34;\u0026#34;-A1\u0026#34;\u0026#34;  建立快捷键\n进入菜单选Preferences-\u0026gt;Browse Packages，然后进CoolFormat，里面有个Default.sublime-keymap\n打开后，里面有快捷方式的按键,更改如下：\n1 2 3 4 5 6 7 8 9  [{\u0026#34;keys\u0026#34;: [\u0026#34;ctrl+q\u0026#34;], \u0026#34;command\u0026#34;: \u0026#34;coolformat\u0026#34;, \u0026#34;args\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;quickFormat\u0026#34;}},{\u0026#34;keys\u0026#34;: [\u0026#34;ctrl+alt+shift+s\u0026#34;], \u0026#34;command\u0026#34;: \u0026#34;coolformat\u0026#34;, \u0026#34;args\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;selectedFormat\u0026#34;}}]   这样以后写完的代码直接按 “Ctrl+Q” 便可以格式化代码\n 另一种格式化代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ;Pleasevisithttp://akof1314.github.io/CoolFormat/doc/index.htmlformoreinformation[SynTidy]C++=\u0026#34;\u0026#34;-A2-p-N-Y-o-T-N-k3\u0026#34;\u0026#34;Java=\u0026#34;\u0026#34;-A1-p-N-T-Y-k3\u0026#34;\u0026#34;C#=\u0026#34;\u0026#34;-A1-p-N-Y-T-k3\u0026#34;\u0026#34;Objective-C=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;HTML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-fu-js-ll-n-ox-pe-qa-qn-m-wa-wj-wp-ws-sw-fo-i0-d1-ce0-ie0-oe0-w0-sbo0\u0026#34;\u0026#34;XML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-js-ll-n-ix-qa-qn-m-wa-wj-wp-ws-sw-fo-i1-ce0-ie0-oe0-w0\u0026#34;\u0026#34;PHP=\u0026#34;\u0026#34;-sas-icd-samt-salo-saeo-saro-sabo-saao-samp-aas-rsl-iel-rpc-rst-st\u0026#34;\u0026#34;JavaScript=\u0026#34;\u0026#34;-nb-cn4\u0026#34;\u0026#34;CSS=\u0026#34;\u0026#34;-c2-rub-cl0-os1-cc-cf-cfp0-rs2\u0026#34;\u0026#34;JSON=\u0026#34;\u0026#34;-cn3\u0026#34;\u0026#34;SQL=\u0026#34;\u0026#34;-cn2-el-ml0\u0026#34;\u0026#34;  ","description":"","id":44,"section":"posts","tags":[""],"title":"MinGW在Windows的使用","uri":"https://vhope.cf/zh/posts/settings/mingw-use/"},{"content":"HUGO + Github + Github Action持续集成部署个人博客\nHUGO本地环境 首先在HUGO的官网下载Hugo的Windows安装包，然后将路径添加到环境变量即可。\nstep1:下载hugo\nstep2:配置环境变量\nHUGO站点配置及主题配置 创建站点 在目录下直接输入下面的代码即可创建一个名为blog的hugo站点(注意：新建的站点是没有自带主题的)\n1  hugo new site blog   或者进入blog文件夹内直接输入以下语句：\n1  hugo new site .   下载主题 可以在hugo theme下载主题，然后根据主题的文档进行配置\n放到站点文件夹themes内，配置config.toml\n本地测试运行 输入hugo server测试\nGithub配置 创建站点仓库并且设置GithubPage 可以在Setting中看见如下：\n创建一个存储项目的仓库 配置Github Action 首先在项目仓库点击action，选择Simple workflow，输入一下的配置代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  name:CI#自动化的名称on:push:# push的时候触发branches:# 那些分支需要触发- masterjobs:build:runs-on:ubuntu-latest# 镜像市场steps:- name:checkout# 步骤的名称uses:actions/checkout@v1#软件市场的名称with:# 参数submodules:true- name:SetupHugouses:peaceiris/actions-hugo@v2.2.2with:hugo-version:\u0026#39;0.64.1\u0026#39;extended:true- name:Buildrun:hugo-D- name:Deployuses:peaceiris/actions-gh-pages@v2.5.1env:ACTIONS_DEPLOY_KEY:${{secrets.ACTIONS_DEPLOY_KEY}}EXTERNAL_REPOSITORY:redisread/redisread.github.ioPUBLISH_BRANCH:masterPUBLISH_DIR:./public  准备部署，我们开发的项目及github pages实际是分开的，一个用于保存项目，相当于源代码，另外一个用于保存最终的网页文件。\n  使用git生成ssh key(相当于生成对密钥)\n1 2 3 4  ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key)    假设 开发项目为 HUGO_blog 部署的项目为 redisread.github.io\n   打开HUGO_blog仓库的settings，再点击Secrets，然后添加刚刚生成的私钥，name为ACTIONS_DEPLOY_KEY\n  同理，打开redisread.github.io，点击Deploy keys，添加公钥，Allow write access一定要勾上，否则会无法提交\n  然后，你就可以提交代码了，push成功后，打开仓库actions，至此部署成功，大功告成！\n","description":"Guide to set Hugo site.","id":45,"section":"posts","tags":["Hugo","Github"],"title":"Hugo配置","uri":"https://vhope.cf/zh/posts/hugo/first/"},{"content":"使用Github+PicGo建立一个免费的个人图床。\nPicGo介绍 PicGo是一款图片上传的工具，目前支持微博图床，七牛图床，腾讯云，又拍云，GitHub等图床\n在Github创建图床 创建Repository 生成一个Token用于操作GitHub repository 步骤如下:\n{% note warning %}\n注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存\n{% endnote %}\n配置PicGo 下载PicGo Windows用户下载exe文件\n配置图床    设定仓库名的时候，是按照“账户名/仓库名的格式填写”\n  分支名统一填写“master”\n  将之前的Token黏贴在这里\n  存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹\n  自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/用户名/RepositoryName/分支名，，自定义域名需要按照这样去填写\n   快捷键及相关配置  这里配置上传快捷键为ctrl+shift+c\n 使用 经过上面的配置就大功告成了，每次截图之后，只需要ctrl+shift+c一下就可以把剪切板上面的截图转化为在线网络图片链接。\n","description":"","id":46,"section":"posts","tags":["PicGo","Github","图床"],"title":"配置基于Github的PicGo图床","uri":"https://vhope.cf/zh/posts/settings/image-bed/"},{"content":"写在源文件中的源代码是人类可读的源。它需要\u0026quot;编译\u0026rdquo;，转为机器语言，这样 CPU 可以按给定指令执行程序。C 语言编译器用于把源代码编译成最终的可执行程序。🐤\n安装 首先,到：https://sourceforge.net/projects/mingw-w64/files/latest/download，下载最新版本的 MinGW 安装程\n然后，运行 Download mingw-get-setup.exe ,点击\u0026quot;运行\u0026rdquo;，continue等，注意记住安装的目录，之后需要配置环境变量，例如D:\\MinGW\\bin\n假如网速不好，可以通过下面的链接进行离线下载，下载完成之后使用7Zip解压，然后把解压的文件移动到安装路径即可。\nhttps://pan.baidu.com/s/1W4fHsUeaw1C9vp1lvRygbw\n注：使用这种方式下面的步骤不需要执行了，已经在离线包中集成了。可直接输入gcc -v查看gcc版本。\n 验证安装：\n在开始菜单中，点击\u0026quot;运行\u0026rdquo;，输入 cmd,打开命令行:输入 mingw-get,如果弹出 MinGw installation manager 窗口，说明安装正常，然后关闭窗口。\n安装GCC等编译器 在cmd中输入如下命令进行安装：\n安装gcc\n1  mingw-get install gcc   安装g++\n1  mingw-get install g++   安装gdb\n1  mingw-get install gdb   使用 在桌面创建一个hello.c的程序\n1 2 3 4 5 6 7 8 9  #include \u0026lt;iostream\u0026gt;using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   在 cmd 中输入命令\n1  gcc hello.c   在当前目录下(记住是命令的当前目录)会生成 a.exe 的可执行文件，在 cmd 中输入 a.exe 就可以执行程序了。\n","description":"","id":47,"section":"posts","tags":["gcc","MinGW"],"title":"windows下gcc的安装和使用","uri":"https://vhope.cf/zh/posts/settings/gcc-windows/"},{"content":"我是一个不够严谨的程序员🙉.\n我喜欢📖,还有🏓.\n或许有时候我想的不够远，但是有时候我想的很深入。\n我最喜欢的 Aaron Swartz 语录:\n 在长大的过程中，我才慢慢发现，我身边的所有事，别人跟我说的所有事，那些所谓本来如此，注定如此的事，它们其实没有非得如此，事情是可以改变的。更重要的是，有些事既然错了，那就该做出改变。\n我对学校十分失望，我觉得老师们根本不懂自己所讲的是什么，他们居高临下，管这管那；作业就像是种把戏，就好像知识一种强制所有学生一起庸庸碌碌的手段。于是我就开始去阅读那些关于教育史和这套教育体系演变的书籍。然后你就能发现，如果要真正学到东西，那就不能机械重复老师所教的，这有点儿使得我渐渐学会了质疑。我质疑我所上的学校，我质疑简历这所学校的这个社会，我质疑学校教人们追求的那套事理，我质疑建立起这整个体系的政府。\n我总是深入思考，我希望别人也能想远一点。我为理想而工作，并从别人身上学习，我不喜欢拒人于外。我是个完美主义者，但我不会要求出版界也精益求精。除了教育和娱乐以外，我不会浪费时间在那些不会有影响的事情上。我试着和每个人都友好相处，但我讨厌人们不认真对待我。我不记恨他人，因为这于创造无益。但我从自身经历中学习，我想让世界变得更美好。\n我深深地觉得，光安生与当下这世界是不够的，那样子知识别人给什么你就照收，大人们说什么你就照做，你照着父母说的去做，照着社会说的去做。我觉得你应该总持有质疑，我觉得从科学的角度看，你所学的一切都知识暂时性的，任何所学都有改口、驳斥、质疑的余地。我觉得这情况对社会也适用。当我意识到社会上有着我能尽份力去解决的真正严重的、基础性的问题时，我没法去遗忘它、回避它。\n ","description":"Zzo about page","id":48,"section":"","tags":null,"title":"About","uri":"https://vhope.cf/zh/about/"},{"content":"Markdownify box This is boxmd shortcode Simple box This is **box** shortcode  Code tabs Make it easy to switch between different code\njava javascript  1  System.out.println(\u0026#39;Hello World!\u0026#39;);     1  console.log(\u0026#39;Hello World!\u0026#39;);       'use strict'; var containerId = JSON.parse(\"\\\"642b4352e05d9e04\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Tabs for general purpose Windows MacOS Ubuntu  Windows section 1  console.log(\u0026#39;Hello World!\u0026#39;);   ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n MacOS section Hello world!  Ubuntu section Great!    'use strict'; var containerId = JSON.parse(\"\\\"f09fb25fccaa3686\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Expand   Expand me  Title contents     Expand me2  Title2 contents2   Alert Colored box\nthis is a text this is a text this is a text this is a text Notice success text  info text  warning text  error text  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":49,"section":"posts","tags":["shortcode"],"title":"Shortcodes","uri":"https://vhope.cf/zh/posts/hugo/shortcodes/"},{"content":"A Short Video：  ——以下 Aaron Swartz的宣言，我想这才是信息革命的真谛——\n信息就是力量。但就像所有力量一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 Reed Elsevier 这样的出版商大把钱。\n有人努力去改变这种状况。开放访问运动 (Open Access Movement) 奋勇斗争，确保科学家们没有将他们的版权签署给别人，而是将他们的成果发布到网络上，允许任何人访问它们。但即便是最好的情况，他们的行为也只作用于未来发布的东西。之前的都将失去。\n这样的代价实在太高。强制学者付钱以阅读他们同行的成果？扫描整个图书馆却只允许 Google 的人阅读它们？提供科学文章给那些第一世界的精英大学，却不给身在南半球的儿童？这实在蛮横且无法接受。\n“我同意，”有些人就说了，“但是我们能做什么呢？那些公司握有版权，他们靠限制访问赚取大把的钱，而且这是完全合法的 - 我们没有办法阻止他们。”但有些事我们能做，这些事我们已经在做：我们可以反击。\n那些能够访问这些资源的人 - 学生，图书管理员，科学家 - 你们被赋予了特权。你们能享受到这知识的盛宴，而其他人却被排除在外。但是你们不必 - 事实上，从道义层面来说，你们不能 - 为保留自己保留这份特权。你们有义务和全世界分享它。而且你们已经在做了：和同行们交换密码，回应朋友们的下载请求。\n同时，那些被拒之门外的人们并没有袖手旁观。你们溜过洞穴，翻越围墙，解放那些被出版商封锁的信息并分享给你的朋友们。\n但所有这些行动都是在黑暗中进行，隐藏于地底。它们被称作偷窃或盗版，仿佛分享大量的知识精神上等同于抢劫一艘船只并谋杀其船员。但是分享绝非不道德的，它是一种道德使命。只有那些利欲熏心的人才会拒绝让朋友复制一份。\n大公司，当然，就是利欲熏心。使它们运转的法律要求使然 - 稍微出点事投资人就得叛乱。它们收买的政治家们支持它们，通过法案让它们拥有专属的权力决定谁可以复制。\n遵从不公正的法律不会带来公正。步入光明的时候到了，在公民不服从的伟大传统下，宣告我们对这种私人盗窃公共文化的反抗。\n我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。\n只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？\n亚伦·斯沃茨 (Aaron Swartz)\n2008 年 7 月，意大利 Eremo\nInformation is power. But like all power, there are those who want to keep it for themselves. The world\u0026rsquo;s entire scientific and cultural heritage, published over centuries in books and journals, is increasingly being digitized and locked up by a handful of private corporations. Want to read the papers featuring the most famous results of the sciences? You\u0026rsquo;ll need to send enormous amounts to\npublishers like Reed Elsevier.\nThere are those struggling to change this. The Open Access Movement has fought valiantly to ensure that scientists do not sign their copyrights away but instead ensure their work is published on the Internet, under terms that allow anyone to access it. But even under the best scenarios, their work will only apply to things published in the future. Everything up until now will have been lost.\nThat is too high a price to pay. Forcing academics to pay money to read the work of their colleagues? Scanning entire libraries but only allowing the folks at Google to read them? Providing scientific articles to those at elite universities in the First World, but not to children in the Global South? It\u0026rsquo;s outrageous and unacceptable.\n\u0026ldquo;I agree,\u0026rdquo; many say, \u0026ldquo;but what can we do? The companies hold the copyrights, they make enormous amounts of money by charging for access, and it\u0026rsquo;s perfectly legal - there\u0026rsquo;s nothing we can do to stop them.\u0026rdquo; But there is something we can, something that\u0026rsquo;s already being done: we can fight back.\nThose with access to these resources - students, librarians, scientists - you have been given a privilege. You get to feed at this banquet of knowledge while the rest of the world is locked out. But you need not - indeed, morally, you cannot - keep this privilege for yourselves. You have a duty to share it with the world. And you have: trading passwords with colleagues, filling download requests for friends.\nMeanwhile, those who have been locked out are not standing idly by. You have been sneaking through holes and climbing over fences, liberating the information locked up by the publishers and sharing them with your friends.\nBut all of this action goes on in the dark, hidden underground. It\u0026rsquo;s called stealing or piracy, as if sharing a wealth of knowledge were the moral equivalent of plundering a ship and murdering its crew. But sharing isn\u0026rsquo;t immoral - it\u0026rsquo;s a moral imperative. Only those blinded by greed would refuse to let a friend make a copy.\nLarge corporations, of course, are blinded by greed. The laws under which they operate require it - their shareholders would revolt at anything less. And the politicians they have bought off back them, passing laws giving them the exclusive power to decide who can make copies.\nThere is no justice in following unjust laws. It\u0026rsquo;s time to come into the light and, in the grand tradition of civil disobedience, declare our opposition to this private theft of public culture.\nWe need to take information, wherever it is stored, make our copies and share them with the world. We need to take stuff that\u0026rsquo;s out of copyright and add it to the archive. We need to buy secret databases and put them on the Web. We need to download scientific journals and upload them to file sharing networks. We need\nto fight for Guerilla Open Access.\nWith enough of us, around the world, we\u0026rsquo;ll not just send a strong message opposing the privatization of knowledge - we\u0026rsquo;ll make it a thing of the past.\nWill you join us?\nAaron Swartz\nJuly 2008, Eremo, Italy\n","description":"","id":50,"section":"talks","tags":[""],"title":"My Awesome links","uri":"https://vhope.cf/zh/talks/mylinks/"},{"content":"Sample images about life.\n","description":"my gallery","id":52,"section":"gallery","tags":[""],"title":"life","uri":"https://vhope.cf/zh/gallery/life/"},{"content":"between 40 and 240 in movies\ngood movies！🎥\n","description":"my gallery","id":53,"section":"gallery","tags":[""],"title":"movie","uri":"https://vhope.cf/zh/gallery/movie/"},{"content":"一个测试视频:  ","description":"","id":57,"section":"talks","tags":[""],"title":"B站视频","uri":"https://vhope.cf/zh/talks/blibli/"},{"content":"UE编辑器下模拟使用HitProxy 需要从 UGameViewportClient 类继承 修改返回值为true,路径：\\Source\\Runtime\\Engine\\Private\\GameViewportClient.h\n1  virtual bool RequiresHitProxyStorage() override { return true; }   在FViewportClient类中新建DrawHitProxy函数 文件UnrealClient.h\n在GameViewportClient类中声明并且实现 声明：\\Source\\Runtime\\Engine\\Private\\GameViewportClient.h\n将GameViewportClient类中的函数Draw()内容复制到该函数DrawHitProxy，修改下面的的地方：\n修改FViewport类中的GetRawHitProxyData函数 在GetRawHitProxyData函数中进行以下的修改：Engine\\Source\\Runtime\\Engine\\Private\\UnrealClient.cpp\n调用\u0026ndash;获取屏幕坐标Hitproxy 相关类型 HHitProxy：用于检测用户界面命中的基类\nFHitProxyMap：从2D坐标到缓存命中代理的地图。\n参考：\n How to select an actor in-game using GetHitProxy? UE4 编辑器的光标拾取 编辑器Viewport窗口中的鼠标拾取原理 场景基本对象 渲染总流程 https://docs.unrealengine.com/zh-CN/Programming/Rendering/MeshDrawingPipeline/index.html Unreal Mesh Drawing源码分析 白袍笑道  ","description":"","id":58,"section":"posts","tags":null,"title":"","uri":"https://vhope.cf/zh/posts/ue/ue-hitproxy/"}]