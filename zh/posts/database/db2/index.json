[{"content":"mysql的MVCC机制 MVCC的维基百科解释：多版本并发控制(Multiversion concurrency control， MCC 或 MVCC)，是数据库管理系统常用的一种并发控制，也用于程序设计语言实现事务内存。\n MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别\n MVCC作用\nMVCC意图解决读写锁造成的多个、长时间的读操作饿死写操作问题。所以MVCC通过保存某个时间点的快照来实现该机制，每个事务读到的数据项都是一个历史快照（snapshot)并依赖于实现的隔离级别。写操作不覆盖已有数据项，而是创建一个新的版本，直至所在操作提交时才变为可见。快照隔离使得事物看到它启动时的数据状态。\n MVCC可以无锁实现。\n 常见的数据库优化方法  或者索引相关的点你全部都知道么？聚簇索引，非聚簇索引，普通索引，唯一索引，change buffer，表锁、行锁、间隙锁以及行锁并发情况下的最大TPS是多少？还有索引为啥会选择错误？这些大家知道嘛？\n 数据库的组成结构图：\n我们所谓的调优也就是在，执行器执行之前的分析器，优化器阶段完成的。\n  先跑sql explain\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n1  EXPLAIN SELECT * from user_info WHERE id \u0026lt; 300;   EXPLAIN 命令的输出内容大致如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  mysql\u0026gt; explain select * from user_info where id = 2\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: const possible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec)   各列的含义如下:\n  id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n  select_type: SELECT 查询的类型.\n它的常用取值有:\n SIMPLE, 表示此查询不包含 UNION 查询或子查询 PRIMARY, 表示此查询是最外层的查询 UNION, 表示此查询是 UNION 的第二或随后的查询 DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询 UNION RESULT, UNION 的结果 SUBQUERY, 子查询中的第一个 SELECT DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.    table: 查询的是哪个表\n  partitions: 匹配的分区\n  type: join 类型\ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.\ntype 常用的取值有:\n system: 表中只有一条数据. 这个类型是特殊的 const 类型. const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.    possible_keys: 此次查询中可能选用的索引\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\n  key: 此次查询中确切使用到的索引.\n  ref: 哪个字段或常数与 key 一起被使用\n  rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n  filtered: 表示此查询条件所过滤的数据的百分比\n  extra: 额外的信息\n    排除缓存干扰(Mysql8.0之前需要需要排除)\n我们在执行SQL的时候，记得加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。\n 为什么缓存会失效，而且是经常失效？\n缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空，其实我们很少存在不更新的表。\n   覆盖索引\n我们在数据库查询的操作中，可能有回表的操作，我们希望不进行回表操作，在自己的索引上就查到自己想要的，不进行主键索引查找。\n如果在我们建立的索引上就已经有我们需要的字段，就不需要回表了，在电商里面也是很常见的，我们需要去商品表通过各种信息查询到商品id，id一般都是主键，可能sql类似这样：\n1  select itemId from itemCenter where size between 1 and 6   因为商品id itemId一般都是主键，在size索引上肯定会有我们这个值，这个时候就不需要回主键表去查询id信息了。\n由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。\n  联合索引——构建两个属性之间的快速查询\n还是商品表举例，我们需要根据他的名称，去查他的库存，假设这是一个很高频的查询请求，你会怎么建立索引呢？\n 思考回表的消耗对SQL进行优化。\n 建立一个，名称和库存的联合索引，这样名称查出来就可以看到库存了，不需要查出id之后去回表再查询库存了，联合索引在我们开发过程中也是常见的，但是并不是可以一直建立的，大家要思考索引占据的空间。\n  最左匹配原则\n如果利用一个模糊查询 itemname like ’敖丙%‘，这样还是能利用到这个索引的，而且如果有这样的联合索引，大家也没必要去新建一个商品名称单独的索引了。\n 很多时候我们索引可能没建对，那你调整一下顺序，可能就可以优化到整个SQL了。\n   索引下推\n知道了前缀索引规则，那我就说一个官方帮我们优化的东西，索引下推。\n1  select * from itemcenter where name like \u0026#39;敖%\u0026#39; and size=22 and age = 20;   所以这个语句在搜索索引树的时候，只能用 “敖”，找到第一个满足条件的记录ID1，当然，这还不错，总比全表扫描要好。\n然后我们还可以使用索引下推进行优化：\n在MySQL 5.6之前，只能从ID1开始一个个回表，到主键索引上找出数据行，再对比字段值。\n而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n  唯一索引普通索引选择\n当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。\n在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。\n 将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。\n 那么，什么条件下可以使用change buffer呢？\n对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。\n要判断表中是否存在这个数据，而这必须要将数据页读入内存才能判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。\n因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。\nchange buffer用的是buffer pool里的内存，因此不能无限增大，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置，这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。\n将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一，change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。\n  前缀索引\n我们存在邮箱作为用户名的情况，每个人的邮箱都是不一样的，那我们是不是可以在邮箱上建立索引，但是邮箱这么长，我们怎么去建立索引呢？\nMySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。\n  Mysql各种引擎和区别  MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。\n MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。\n但是最常用的是InnoDB和Mylsam。\nInnoDB\nInnoDB是一个事务型的存储引擎，有行级锁定和外键约束。\nInnodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。\n 适用场景：\n经常更新的表，适合处理多重并发的更新请求。\n 索引结构：InnoDB是B+Treee索引结构。并且Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。\n InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。\n Mylsam\nMyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。\n 适用场景：\n不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。\n不支持外键的表设计。\n查询速度很快，如果数据库insert和update的操作比较多的话比较适用。\n整天对表进行加锁的场景。\nMyISAM极度强调快速读取操作。\n 索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。\nInnoDB和MyISAM的区别\n  事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能\n  性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。\n  行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。\n  索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。\nMyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。\nInnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。\n  服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。\nMyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。\nInnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。\n  锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。\n  参考链接：\n 有哪些常见的数据库优化方法？ MySQL 性能优化神器 Explain 使用分析  ","description":"","id":0,"section":"posts","tags":["Database"],"title":"数据库知识(2)","uri":"https://vhope.cf/zh/posts/database/db2/"},{"content":"546. 移除盒子 给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。\n你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k \u0026gt;= 1），这样一轮之后你将得到 k*k 个积分。\n当你将所有盒子都去掉之后，求你能获得的最大积分和。\n示例：\n输入：boxes = [1,3,2,2,2,3,4,3,1] 输出：23 解释： [1, 3, 2, 2, 2, 3, 4, 3, 1] ----\u0026gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) ----\u0026gt; [1, 3, 3, 3, 1] (1*1=1 分) ----\u0026gt; [1, 1] (3*3=9 分) ----\u0026gt; [] (2*2=4 分) 提示：\n 1 \u0026lt;= boxes.length \u0026lt;= 100 1 \u0026lt;= boxes[i] \u0026lt;= 100  分析 一般来说，求最值的问题几乎和动态规划有关系，那么这题也是从动态规划的角度去思考解决方案。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { int len; int removeBoxes(vector\u0026lt;int\u0026gt;\u0026amp; boxes,int i,int j,int k,vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;\u0026amp; dp) { if(i \u0026gt; j) return 0; if(dp[i][j][k] \u0026gt; 0) return dp[i][j][k]; for(;i+1 \u0026lt;= j \u0026amp;\u0026amp; boxes[i+1] == boxes[i];++i,++k); int res = (k+1) * (k+1) + removeBoxes(boxes,i+1,j,0,dp); for(int m = i + 1;m \u0026lt;= j;++m) if(boxes[m] == boxes[i]) res = max(res,removeBoxes(boxes,i+1,m-1,0,dp) + removeBoxes(boxes,m,j,k+1,dp)); return dp[i][j][k] = res; } public: int removeBoxes(vector\u0026lt;int\u0026gt;\u0026amp; boxes) { len = boxes.size(); // dp[i][j][k] 表示从i到j的范围有k个相同颜色的数字在i的前面，并且下标i的颜色也与它们相同  vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(len+1,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(len+1,vector\u0026lt;int\u0026gt;(len+1,0))); return removeBoxes(boxes,0,len-1,0,dp); } };   ","description":"","id":1,"section":"posts","tags":["leetcode","算法","动态规划"],"title":"Leetcode每日一题(1)","uri":"https://vhope.cf/zh/posts/leetcode/leetcode-day1/"},{"content":"数据库事务 事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。\n数据库事务四大特性(ACID)  原子性：不可分割，要么全部完成提交，要么全部回滚 一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 隔离性：多用户一起进行事务操作互不影响，相互隔离。 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。  数据库事务隔离级别 读取的问题\nusers    id name age     1 Joe 20   2 Jill 25      脏读\n当一个事务允许读取另外一个事务修改但未提交的数据时，就可能发生脏读。\n例子中，事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了。\n  不可重复读\n在一次事务中，当一行数据获取两遍得到不同的结果表示发生了“不可重复读”.\n在基于锁的并发控制中“不可重复读”现象发生在当执行SELECT 操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁； 多版本并发控制中当没有要求一个提交冲突(commit conflict)的事务回滚也会发生“不可重复读”现象。\n这个例子中，事务2提交成功，因此他对id为1的行的修改就对其他事务可见了。但是事务1在此前已经从这行读到了另外一个“age”的值。在可序列化（SERIALIZABLE）和可重复读的隔离级别，数据库在第二次SELECT请求的时候应该返回事务2更新之前的值。在提交读和未提交读，返回的是更新之后的值，这个现象就是不可重复读。\n 解决不可重复读：\n 要求事务2延迟到事务1提交或者回滚之后再执行。这种方式实现了T1, T2 的串行化调度。串行化调度可以支持可重复读。 另一种策略是多版本并发控制。为了得到更好的并发性能，允许事务2先提交。但因为事务1在事务2之前开始，事务1必须在其开始执行时间点的数据库的快照上面操作。当事务1最终提交时候，数据库会检查其结果是否等价于T1, T2串行调度。如果等价，则允许事务1提交，如果不等价，事务1需要回滚并抛出个串行化失败的错误     幻读\n在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为“幻影读（phantom read）”\n当事务没有获取*范围锁*的情况下执行*SELECT \u0026hellip; WHERE*操作可能会发生“幻影读”。\n“幻影读”是不可重复读的一种特殊场景：当事务1两次执行SELECT \u0026hellip; WHERE检索一定范围内数据的操作中间，事务2在这个表中创建了(如INSERT)了一行新数据，这条新数据正好满足事务1的“WHERE”子句。\n需要指出的是事务1执行了两遍同样的查询语句。如果设了最高的隔离级别，两次会得到同样的结果集，这也正是数据库在可序列化（SERIALIZABLE）隔离级别上需要满足的。但是在较低的隔离级别上，第二次查询可能会得到不同的结果集。\n   事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题\n 隔离级别\n  读未提交（READ UNCOMMITTED）\n未提交读（READ UNCOMMITTED）是最低的隔离级别。允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改。\n  读提交 （READ COMMITTED）\n在提交读（READ COMMITTED）级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁一直保持到事务结束，但是读锁在SELECT操作完成后马上释放。\n  可重复读 （REPEATABLE READ）\n在可重复读（REPEATABLE READS）隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束。\n 为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。\n 我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。\n按照上面这张图理解，一行记录现在有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。\n读提交和可重复读的时候都提到了一个词，叫做快照，学名叫做一致性视图，这也是可重复读和不可重复读的关键。可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。\n  串行化 （SERIALIZABLE）\n串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。\n 在基于锁机制并发控制的DBMS实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在SELECT 的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个“范围锁”（range-locks）。这种机制可以避免“幻读”（phantom reads）现象\n   并发写问题\n存在这的情况，两个事务，对同一条数据做修改。最后结果应该是哪个事务的结果呢，肯定要是时间靠后的那个。\n假设事务A执行 update 操作， update 的时候要对所修改的行加行锁，这个行锁会在提交之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行，如果事务A的时间太长，那么事务B很有可能出现超时异常。如下图所示。\n需要注意的是，加入查询的字段设置了索引，那么数据库系统可以很方便的给该行数据加上一个行锁；加入没有设置索引的话，数据库系统会直接将该表的所有行加上行锁，然后再遍历一遍，释放掉没用的行锁。\n解决幻读\n并发写问题的解决方式就是行锁，而解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。\n在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。可能会有如下的B+树：\n如图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁的。\n在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。当事务A执行update user set name='风筝2号’ where age = 10; 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。不仅插入 age = 10 的记录需要等待事务A提交，age\u0026lt;10、10\u0026lt;age\u0026lt;30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。\n 这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。\n 隔离级别vs读现象\n   隔离级别 脏读 不可重复读 幻影读     未提交读 可能发生 可能发生 可能发生   提交读 - 可能发生 可能发生   可重复读 - - 可能发生   可序列化 - - -    可序列化（Serializable）隔离级别不等同于可串行化（Serializable）。可串行化调度是避免以上三种现象的必要条件，但不是充分条件。\n “可能发生”表示这个隔离级别会发生对应的现象，“-”表示不会发生。采用哪种隔离级别要根据系统需求权衡决定，其中，可重复读是 MySQL 的默认级别。\n 隔离级别vs 锁持续时间\n在基于锁的并发控制中，隔离级别决定了锁的持有时间。\u0026ldquo;C\u0026rdquo;-表示锁会持续到事务提交。 \u0026ldquo;S\u0026rdquo; –表示锁持续到当前语句执行完毕。如果锁在语句执行完毕就释放则另外一个事务就可以在这个事务提交前修改锁定的数据，从而造成混乱\n   隔离级别 写操作 读操作 范围操作 (\u0026hellip;where\u0026hellip;)     未提交读 S S S   提交读 C S S   可重复读 C C S   可序列化 C C C    MySQL隔离操作：\n 查看Mysql默认的隔离级别：  1 2 3 4 5 6 7  mysql\u0026gt; show variables like \u0026#39;transaction_isolation\u0026#39;; +-----------------------+-----------------+ | Variable_name | Value | +-----------------------+-----------------+ | transaction_isolation | REPEATABLE-READ | +-----------------------+-----------------+ 1 row in set, 1 warning (0.11 sec)   可以发现Mysql默认的隔离级别为可重复读\n修改改数据库的隔离级别：set [作用域] transaction isolation level [事务隔离级别]，具体如下：\n1  SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}。   数据库索引(INDEX) 数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。\nMysql创建索引：\n1  CREATE INDEX INDEX_NAME ON TABLE_NAME (COLUMN_LIST)   数据库的三大范式 第一范式\n当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分\n第二范式\n如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式\n第三范式\n设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码\n参考链接：\n https://www.cnblogs.com/fengzheng/p/12557762.html https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#%E8%84%8F%E8%AF%BB ","description":"","id":2,"section":"posts","tags":["Database"],"title":"数据库知识(1)","uri":"https://vhope.cf/zh/posts/database/db1/"},{"content":"关于程序的装入   绝对装入：绝对映射，程序中逻辑地址与内存物理地址完全相同 （单片机)\n  可重定位装入：静态映射，在装入时对逻辑地址进行修改\n  动态运行时装入：逻辑地址到物理地址的映射在程序运行时才执行 (现代PC机)\n  而动态重定位如下：\n 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间。\n 关于程序的链接   静态链接方式(Static Linking)\n在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。\n  装入时动态链接(Load time Dynamic Linking)\n将用户源程序编译后所得到的一组目标模块，在装入内存时，釆用边装入边链接的链接方式。\n  运行时动态链接(Run-time Dynamic Linking）\n对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n  连续分配方式   单一连续分配\n只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给 OS 使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间，提供给用户使用。\n  固定分区连续分配\n将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行。当有一空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。\n另外可以设置分区大小不等的一些分区，如下：\n  动态分区分配\n动态分区分配数据结构：\n  空闲分区表\n在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。\n  空闲分区链\n为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链，如下图所示：\n  分配算法：\n 首次适应算法 循环首次适应算法 最佳适应算法 最差适应算法 快速适应算法  例子：\n假设有新程序F装入，大小为32K，当前已有程序B和D，最近一次空间分配是D：\n  动态重定位分区分配\n对内存中正在使用的分区进行搬迁，使多个小的空闲分区（碎片）合并为一个大的空闲分区\n  算法：\n什么是内存碎片？\n内部碎片是指已经分配给作业但不能被利用的内存空间，外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块。通俗点的理解就是，某个作业所占用的内存区域如果没有装满，就是内部碎片，而作业与作业之间，如果有内存区域没有分配给某个作业，但又不能分配给任何作业，就是外部碎片。\n 连续分配: 为用户进程分配的必须是一个连续的内存空间。\n非连续分配: 为用户进程分配的可以是一些分散的内存空间。\n 非连续分配方式 思想\n假设进程A大小为23MB,但是每个分区大小只有10MB,如果进程只能占用一个分区,那显然放不下。\n解决思路:\n如果允许进程占用多个分区,那么可以把进程拆分成10MB+10MB+3MB三个部外,再把这三个部分分别放到三个分区中(这些分区不要求连续)\u0026hellip;\n进程A的最后一个部分是3MB,放入分区后会产生7MB的内部碎片，如果每个分区大小为2MB,那么进程A可以拆分成11*2MB +1MB共12个部分,只有最后一部分1MB占不满分区,共产生1MB的内部碎片.\n显然,如果把外区大小设置的更小一些,内部碎片会更小,内学利用率会更高.\n具有快表的地址变换机构：（时间局部性与空间局部性原理）\n快表,又称联想寄存器(TLB) ,是一种访问速度比内存快很多的高速缓冲存储器,用来存放当\u0026quot;前访间的若干页表项,以加速地址变换的过程。与此对应,内存中的页表常称为慢表。\n多级页表\n问题\n加载一个大的页表需要占用很大的内存\n解决\n将大表分为几个小表。类似CIDR。\n可将长长的页表进行分组,使每个内存块刚好可以放入一个分组(比如上个侧子中,页面大小4KB,每个页表项48,每个页面可存放1K个页表项,因此每1K个连续的页表项为一组,每组刚好占一个内存块,再讲各组离散地放到各个内存块中)另外,要为离散分配的页表再建立一张页表,称为页目录表,或称外层页表,或称顶层页表\n参考链接：\n 【操作系统 - 4】动态分区分配算法 程序的链接的三种方式 连续分配管理方式  ","description":"","id":4,"section":"posts","tags":["Linux"],"title":"Linux内存管理","uri":"https://vhope.cf/zh/posts/linux/memory-control/"},{"content":"网络层 网际协议IP是TCP/IP体系中两个最主要的协议之一[STEV94][COME06][FORO10]，也是最重要的因特网标准协议之一。\n与IP协议配套使用的还有三个协议：\n 地址解析协议ARP (Address Resolution Protocol) 网际控制报文协议ICMP (Internet Control Message Protocol) 网际组管理协议IGMP (Internet Group Management Protocol)  在这一层中，ARP画在最下面，因为IP经常要使用这个协议。ICMP和IGMP画在这一层的上部，因为它们要使用IP协议。由于网际协议IP是用来使互连起来的许多计算机网络能够进行通信，因此TCP/IP体系中的网络层常常称为网际层(internet layer)，或IP层。\n虚拟互连网络  从一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：\n(1) 物理层使用的中间设备叫做转发器(repeater)。\n(2) 数据链路层使用的中间设备叫做网桥或桥接器(bridge)。\n(3) 网络层使用的中间设备叫做路由器(router)[插图]。\n(4) 在网络层以上使用的中间设备叫做网关(gateway)。\n用网关连接两个不兼容的系统需要在高层进行协议的转换。\n IP网：\n异构的互联网链路\nH1→R1→R2→R3→R4→R5→H2\nARP协议  已经知道了一个机器（主机或路由器）的IP地址，需要找出其相应的硬件地址\n ARP协议工作原理：\n当主机A要向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的硬件地址，再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。\n当找不到时，执行下面的操作：\n ARP进程在本局域网上广播发送一个ARP请求分组 在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组 主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，并在这个ARP响应分组中写入自己的硬件地址。  在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们不直接使用硬件地址进行通信，而是要使用抽象的IP地址并调用ARP来寻找出相应的硬件地址呢？\n由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的IP地址把这个复杂问题解决了。连接到因特网的主机只需拥有统一的IP地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用ARP的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。\nIP数据报 IP报文格式：\n片偏移的列子：\n一数据报的总长度为3 820字节，其数据部分为3 800字节长（使用固定首部），需要分片为长度不超过1 420字节的数据报片。因固定首部长度为20字节，因此每个数据报片的数据部分长度不能超过1 400字节。于是分为3个数据报片，其数据部分的长度分别为1 400，1 400和1000字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。下如给出分片后得出的结果（请注意片偏移的数值）\n下面是数据报首部与分片有关的字段中的数值，其中标识字段的值是任意给定的（12345）。具有相同标识的数据报片在目的站就可无误地重装成原来的数据报。\n首部检验和 占16位。这个字段只检验数据报的首部，但不包括数据部分\n这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP首部的检验和不采用复杂的CRC检验码而采用下面的简单计算方法：在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算[插图]把所有16位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。\nIP层转发分组 网络拓扑图：\n在简化图中，网络变成了一条链路，但每一个路由器旁边都注明其IP地址。使用这样的简化图，可以使我们不用关心某个网络内部的具体拓扑以及连接在该网络上有多少台计算机，因为这些对于研究分组转发问题并没有什么关系。这样的简化图强调了在互联网上转发分组时，是从一个路由器转发到下一个路由器。\n总之，在路由表中，对每一条路由最主要的是以下两个信息：\n（目的网络地址，下一跳地址）\n于是，我们就根据目的网络地址来确定下一跳路由器，这样做得出以下的结果。\n(1) IP数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。\n(2) 只有到达最后一个路由器时，才试图向目的主机进行直接交付。\n网际控制报文协议ICMP 为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP。\n ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告.一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。所以我们就需要一种协议来完成这样的功能–ICMP协议。\n ICMP报文格式\nICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。\n几种常用的ICMP报文类型\nICMP报文的代码字段是为了进一步区分某种类型中的几种不同的情况。检验和字段用来检验整个ICMP报文。我们应当还记得，IP数据报首部的检验和并不检验IP数据报的内容，因此不能保证经过传输的ICMP报文不产生差错。\nICMP差错报告 ICMP差错报文共有五种，即：\n  终点不可达 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。\n  源点抑制 当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。\n  时间超过 当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。\n  参数问题 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。\n  改变路由（重定向） 路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。\n如果默认路由器发现主机发往某个目的地址的数据报的最佳路由不应当经过默认路由器而是应当经过网络上的另一个路由器R时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器R （而不是默认路由器）。\n  所有的ICMP差错报告报文中的数据字段都具有同样的格式：\n下面是不应发送ICMP差错报告报文的几种情况。\n● 对ICMP差错报告报文不再发送ICMP差错报告报文。\n● 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。\n● 对具有多播地址的数据报都不发送ICMP差错报告报文。\n● 对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。\nICMP询问报文 常用的ICMP询问报文有两种，即:\n 回送请求和回答 ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。 时间戳请求和回答 ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用来进行时钟同步和测量时间。  应用 ping ICMP报文的一个最大用途就是ping命令，用来测试两个主机之间的连通性：\ntracert Traceroute从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP用户数据报[插图]。第一个数据报P1的生存时间TTL设置为1。当P1到达路径上的第一个路由器R1时，路由器R1先收下它，接着把TTL的值减1。由于TTL等于零了，R1就把P1丢弃了，并向源主机发送一个ICMP时间超过差错报告报文。源主机接着发送第二个数据报P2，并把TTL设置为2。P2先到达路由器R1，R1收下后把TTL减1再转发给路由器R2。R2收到P2时TTL为1，但减1后TTL变为零了。R2就丢弃P2，并向源主机发送一个ICMP时间超过差错报告报文。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的TTL是1。主机不转发数据报，也不把TTL值减1。但因IP数据报中封装的是无法交付的运输层的UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报告报文。\n这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的ICMP报文正好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间\n","description":"网络层浅析","id":5,"section":"posts","tags":["计算机网络","网络层"],"title":"网络层","uri":"https://vhope.cf/zh/posts/network/net-level/"},{"content":" 公司\t岗位\t题目\t帖子时间\n==字节跳动\tjava\t剑指 Offer 53 - II. 0～n-1中缺失的数字\t2020.07.18== （双指针）\n==字节跳动\tjava\t如何判断一个单链表是不是有环\t2020.07.18== （快慢指针）\n==字节跳动\tjava\t给你一个数组，求三个数字之和为100.\t2020.07.18== （调用两数之和，哈希）\n==字节跳动\t客户端\t算法题（合并链表\t2020.07.18==\n==字节跳动\t客户端\t求岛屿个数\t2020.07.18==\n==字节跳动\t客户端\t树找两节点最长距离\t2020.07.18==\n字节跳动\tjava\t1243534543634交换各位的数字，找出大于目前这个数的最小的一个数。\t2020.07.18\n字节跳动\t后端\t对一个奇数位升序，偶数位降序的链表，进行排序，例如 1-\u0026gt;100-\u0026gt;20-\u0026gt;80-\u0026gt;40-\u0026gt;30\t2020.07.18\n字节跳动\t后端\t算法题：(1)设计sqtr(x)\t2020.07.18\n字节跳动\t后端\t2、算法题：(1)判断回文链表\t2020.07.18\n字节跳动\t后端\t(2)对于给定的数据，找出比这个数大的最小回文数（正反读都一样的数），如 12310 -\u0026gt; 12321\t2020.07.18\n字节跳动\t后端\t第一道代码：数组只交换一次求最大\t2020.07.18\n字节跳动\t后端\t第二道代码： 单链表判断是否有环\t2020.07.18\n字节跳动\t客户端\tleetcode原题 从一个数 l 一直 与 操作到 r ，怎么做最快，复杂度最小\t2020.07.18\n字节跳动\t客户端\tk个一组反转链表\t2020.07.18\n字节跳动\t客户端\t二叉树的非递归后序遍历\t2020.07.18\n字节跳动\t后端\t括号匹配\t2020.07.17\n字节跳动\t客户端\t按字典序全排列输出\t2020.07.17\n字节跳动\t客户端\t跳台阶\t2020.07.17\n字节跳动\t图形/图像岗\t一棵完全二叉树的最底层的最右节点\t2020.07.17\n字节跳动\t测试\t求子集\t2020.07.17\n字节跳动\t测试\t二维有序数组（从左到右递增，从上到下也递增），找目标数（我写的二分法）\t2020.07.17\n字节跳动\t算法\t1.判断左右括号是否合理\t2020.07.16\n字节跳动\t算法\t2.朴素贝叶斯的算法实现\t2020.07.16\n字节跳动\t算法\t3.两个很大的数据集存着url 找到两个数据集共有的url\t2020.07.16\n字节跳动\t算法\t4.一个二维矩阵由小到大排列 找target数字\t2020.07.16\n字节跳动\t算法\t5.二叉树按行输出\t2020.07.16\n字节跳动\t算法\t1.给二叉树前序遍历和中序遍历 输出这个树\t2020.07.16\n字节跳动\t算法\t2.翻转链表\t2020.07.16\n字节跳动\t算法\t3. 把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\t2020.07.16\n字节跳动\t算法\t给一个类似树的结构，每个节点都可以有多个节点（不止两个树）然后每个根节点和字节点间的路径不一样，求叶子结点到叶子结点的最大路径\t2020.07.16\n字节跳动\t后端\t链表每k个翻转\t2020.07.16\n字节跳动\t后端\t判断单链表有没有环，有的话找入口\t2020.07.16\n字节跳动\t安卓\t. 算法题：根据前中序重构二叉树\t2020.07.16\n字节跳动\t安卓\t算法：螺旋矩阵\t2020.07.16\n字节跳动\t后台\t给定m和n，输出从1~n中任意多个数字，且和为mu的组合(数字不能重复使用)\t2020.07.16\n字节跳动\t后台\t算法题(求第n个丑数,leetcode原题,难度mid)\t2020.07.16\n字节跳动\t后台\t第一题是求开根号n的值\t2020.07.16\n字节跳动\t后台\t第二题是输出交错后的链表(比如链表a-b-c-d-e,交错后输出为a-e-b-d-c)\t2020.07.16\n字节跳动\t后台\t反转链表\t2020.07.16\n字节跳动\t后台\t找峰值\t2020.07.16\n字节跳动\t客户端\t1. 有两个单链表，其有交叉节点，求交叉节点。\t2020.07.16\n字节跳动\t客户端\t2. LRU算法，给一个整数数组，若LRU的窗口大小是4，求下一个元素进来后剔除哪个元素。\t2020.07.15\n字节跳动\t客户端\t3. 求最小子数组，leetcode209题。\t2020.07.15\n字节跳动\t后端\t2N的格子 12的格子填满它有多少种方法， 给个数组，找出右边第一个比它大的元素， 链表两两反转\t2020.07.15\n字节跳动\t前端\t删除链表的倒数第n个\t2020.07.15\n字节跳动\t大数据\t算法题1: 请对3个有序数组进行归并排序\t2020.07.15\n字节跳动\t大数据\t算法题2: 求一个字符串中最长不重复子串的长度\t2020.07.15\n字节跳动\t服务端\t给定一个int数组A，数组中元素互不重复，给定一个数x，求所有求和能得到x的数字组合，组合中的元素来自A，可重复使用。\t2020.07.15\n字节跳动\t后端\t手撕代码:Z字型遍历二叉树（剑指offer原题，LeetCode第1553题）\t2020.07.15\n字节跳动\t算法\ttopk\t2020.07.15\n字节跳动\tjava\t手撕平方根\t2020.07.15\n字节跳动\t测试\t反转链表？\t2020.07.15\n字节跳动\t前端\t给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\t2020.07.15\n字节跳动\t后端\t算法题1：很大量的int型数，输出前100最大的数（中等）\t2020.07.15\n字节跳动\t后端\t算法题2：单向链表，头尾奇偶交替输出（中等）\t2020.07.15\n字节跳动\t后端\t单链表反转\t2020.07.15\n字节跳动\t后端\t平衡二叉搜索树插入算法\t2020.07.15\n字节跳动\t客户端\t2. 一个二叉树， 求路径之和。。。。\t2020.07.15\n字节跳动\t后台\t算法：掷骰子走路，1～6，给定的输入n，走到第n个格子有多少种走法\t2020.07.15\n字节跳动\t后台\t算法：青蛙跳格子，数组里元素表示该位置石头个数，每次跳3-5格，问跳出数组最少踩多少石头。\t2020.07.15\n字节跳动\t后台\t算法：给定链表和k，要求每k个元素翻转一次\t2020.07.15\n字节跳动\t计算机视觉工程师\t做道题吧，LeetCode4：两个有序数组的中位数\t2020.07.15\n字节跳动\t后端\t算法：找出数组里出现次数大于n/k的数\t2020.07.14\n字节跳动\t后端\t算法判断树是否对称，用bfs做了\t2020.07.14\n字节跳动\t客户端\t11.手撕代码：1）给定数组，求连续子串的最大和\t2020.07.14\n字节跳动\t客户端\t2）用两个栈实现队列\t2020.07.14\n字节跳动\t客户端\t10.手撕代码：1）给定一个二维数组，从左到右，从上到下都是递增的，查找某个元素\t2020.07.14\n字节跳动\t客户端\t2）给定一个矩阵，每次只能向右或向下走，从左上角开始到右下角一共有多少种走法\t2020.07.14\n字节跳动\t客户端\t，第一题就是给一个矩阵，从右上角往左下角一层一层斜着遍历，类似于这样：\t2020.07.14\n字节跳动\t客户端\t层次遍历二叉树\t2020.07.14\n字节跳动\t客户端\tleetcode 236\t2020.07.14\n字节跳动\t客户端\tleetcode 62，\t2020.07.14\n字节跳动\t服务端\t1.给一个正整数，表示成一个或多个不同的正整数的和，输出所有的解决方案（深搜，但是我实现的时候写的不好）\t2020.07.14\n字节跳动\t服务端\t2.给一个n*n的方阵，螺旋填入数字\t2020.07.14\n字节跳动\tandroid\t（手撕）1：[2,3] 表示 孩子和父母。输入一组这样的数据， 给两个数，问是否有共同祖先。\t2020.07.14\n字节跳动\t后端\t力扣 124.\t2020.07.14\n字节跳动\t后端\t第二题：二叉树的左视图\t2020.07.14\n字节跳动\t后台\t第一题，一个int数组，找出两个异或最大的数字，时间要求O(n)\t2020.07.14\n字节跳动\t后台\t第二题，四个int数组，从每个数组里边挑一个数，加起来等于指定数，要求打印出所有非重复的组合，要求最大n2。\t2020.07.14\n字节跳动\tjava\t代码题：不含重复字符的最长子串（leetcode原题）\t2020.07.14\n字节跳动\t后端\t2.最长上升子序列的状态转移,时间复杂度\t2020.07.14\n字节跳动\t后端\t给出前序和中序数组,生成后序数组\t2020.07.14\n字节跳动\t后端\t11.算法题：给一棵二叉树和一个整数，要求输出二叉树中路径和等于这个整数的路径，如\t2020.07.14\n字节跳动\t后端\t1。算法题，两个链表了类型的整数求和，如1-\u0026gt;2-\u0026gt;5与3-\u0026gt;6求和得到1-\u0026gt;4-\u0026gt;1。用栈或者反转链表\t2020.07.13\n字节跳动\t后端\t算法题：找波谷数；\t2020.07.13\n字节跳动\t后端\t算法题：复制带随机指针的单向链表；\t2020.07.13\n字节跳动\t后端\t14. 算法题：找到两个链表的公共节点\t2020.07.13\n字节跳动\t后端\t1. 给定两个单链表，判断是否有公共节点\t2020.07.13\n字节跳动\t后端\t3. 求字符数组的全排列（用的交换的方式，但是面试官问思路却有点紧张，没回答好，然后他问我leetcode刷了多少道题，八成认为我是直接背的题了，难受）\t2020.07.13\n字节跳动\t后端\t查找有序数组中一个目标值出现的第一次位置，没有找到返回 -1\t2020.07.13\n字节跳动\t后端\t5. 算法：滑动窗口寻找满足的字符串\t2020.07.13\n字节跳动\t后端\t爬楼梯\t2020.07.13\n字节跳动\t前端\tleetcode 93 没写出来。。面试官说我思绪混乱 导致后面脑子空白\t2020.07.13\n字节跳动\t前端\t二叉树层序遍历\t2020.07.13\n字节跳动\t后端\t说思路：实现一个栈，o(1)时间找最大值\t2020.07.13\n字节跳动\t后端\t写代码：矩阵从左上到右下找最小路径\t2020.07.13\n字节跳动\t后端\t说思路：删除单链表的倒数第k个节点\t2020.07.13\n字节跳动\t客户端\t编程：判断两个链表是否相交并返回交点；\t2020.07.13\n字节跳动\t测试\t代码：无重复最长字串\t2020.07.13\n字节跳动\t测试\t10、算法：求数组中升序的子序列\t2020.07.13\n字节跳动\t测试\t11、算法：两个链表找公共节点\t2020.07.13\n字节跳动\t前端\tMerge 两个有序的链表\t2020.07.13\n字节跳动\tios\t1. 如何用两个栈实现一个队列？如何优化前面说的那种思路？\t2020.07.13\n字节跳动\tios\t2. 编程题：上台阶(那个简单的fabonacci)然后就又来了一道\t2020.07.13\n字节跳动\tios\t3. 编程题：区间合并求并集\t2020.07.13\n字节跳动\tios\t算法题：连续子数组的最大和\t2020.07.13\n字节跳动\tios\t1. 二分查找在升序数组中找出绝对值最小的那个数\t2020.07.13\n字节跳动\tios\t2. 8个桶(每个桶只能放一个球)，5个球，三个连续的情况有几种。一般情况下呢\t2020.07.13\n字节跳动\t后端\tmerge k list\t2020.07.13\n字节跳动\t客户端\tLeetCode 25. K个一组反转链表\t2020.07.13\n字节跳动\t客户端\tLeetCode 53.最大子序和\t2020.07.13\n字节跳动\t客户端\t给定一个包含大写英文字母和数字的句子，找出这个句子所包含的最大的十六进制整数，返回这个整数的值。数据保证该整数在int表示范围内。\t2020.07.13\n字节跳动\t后端\t01矩阵最大正方形,经典题了,dp选左上最小+1,随便写了一下,没让跑test.\t2020.07.13\n字节跳动\t后端\t二叉树找target路径\t2020.07.13\n字节跳动\t后端\t二叉树转单链表,常规题,递归一下完事了.\t2020.07.13\n字节跳动\t后端\t算法题：从左上角走到右下角有多少种不同的路线\t2020.07.13\n字节跳动\tC++客户端\t10.leetcode 奇偶链表\t2020.07.12\n字节跳动\tC++客户端\t二进制中1的个数\t2020.07.12\n字节跳动\tC++客户端\t反转字符串\t2020.07.12\n字节跳动\t游戏客户端\t字符串数组两个字符串的最小距离（easy）\t2020.07.12\n字节跳动\t游戏客户端\t做题，数组中和最大的连续子数组（mid）\t2020.07.12\n字节跳动\t客户端\t189. 旋转数组\t2020.07.12\n字节跳动\t游戏客户端\t手撕 无序数组两数之和\t2020.07.12\n字节跳动\t游戏客户端\t手撕代码 两个栈实现队列\t2020.07.12\n字节跳动\t游戏客户端\t手撕代码 实现洗牌算法\t2020.07.12\n字节跳动\t算法\t二叉树子路径和为k的路径个数\t2020.07.12\n字节跳动\t算法\t1. 求和为k的子数组个数\t2020.07.12\n字节跳动\t算法\t2. 判断是否存在个数超过数组长度一半的数\t2020.07.12\n字节跳动\t客户端\t10、简化路径（算法提）\t2020.07.12\n字节跳动\t客户端\t11、二叉树的右视图（算法题）\t2020.07.12\n字节跳动\tandriod\t代码题：旋转数组\t2020.07.12\n字节跳动\tandriod\t代码题：两数相加（链表，要求原地实现，空间复杂度O(1)，这个犯蠢撕了好久结果还是靠强行打印发现的问题）\t2020.07.12\n字节跳动\tandriod\t代码题：a) 螺旋遍历矩阵\t2020.07.12\n字节跳动\tandriod\t；b)（变种）原地旋转图像\t2020.07.12\n字节跳动\t服务端\t算法题 反转链表（白给）\t2020.07.12\n字节跳动\t后端\t两个有序链表合并\t2020.07.12\n字节跳动\t后端\t给定2D矩阵，求里面1构成的正方形的最大面积。\t2020.07.12\n字节跳动\t后端\t算法题：接雨水\t2020.07.12\n字节跳动\t前端\t14.找出两个链表的交叉点（\t2020.07.12\n字节跳动\t客户端\t10.手撕代码：从无序数组中找到右边第一个大的数（与leetcode 739 每日体温类似）\t2020.07.12\n字节跳动\t后端\t22.抛硬币（一个0.3 一个0.7 如何保证公平）\t2020.07.12\n字节跳动\t后端\t23 z字形打印二叉树\t2020.07.12\n字节跳动\t后端\t- 一颗搜索二叉树有两个节点是颠倒的，恢复成正确的\t2020.07.12\n字节跳动\t后端\t- 单链表高位在前、低位在后，大数计算\t2020.07.12\n字节跳动\t后端\t- 阶乘\t2020.07.12\n字节跳动\t后端\t- 一个有序、有重复元素数组找到有多少满足 a + b = target的\t2020.07.12\n字节跳动\t前端\t1.斐波那契 递归实现/dp实现/空间优化\t2020.07.11\n字节跳动\t前端\t. 算法题 找出sum大于等于target的最短连续数组的长度 要通过所有测试数据 （找bug找半天，面试官一直温柔的说别着急哈哈）\t2020.07.11\n字节跳动\t测试\t10.代码:链表的逆序输出\t2020.07.11\n字节跳动\t测试\t11.代码:判断回文\t2020.07.11\n字节跳动\tC++客户端\t两两反转链表\t2020.07.10\n字节跳动\tC++客户端\t算法：判断两个链表是否相交\t2020.07.10\n字节跳动\tC++客户端\t算法：查找二叉树中两个节点的最近公共祖先\t2020.07.10\n字节跳动\t前端\t7.算法：合并有序数组\t2020.07.10\n字节跳动\t前端\t12 算法：逆序输出数字。\t2020.07.10\n字节跳动\t后端\t手撕：层序遍历\t2020.07.10\n字节跳动\t后端\t二叉树中序遍历\t2020.07.10\n字节跳动\t后端\t手撕 lru\t2020.07.10\n字节跳动\t算法\t第K大个数\t2020.07.10\n字节跳动\t算法\t链表找环\t2020.07.10\n字节跳动\t算法\t合并数组\t2020.07.10\n字节跳动\t后端\t编程题：字符串转换为整数，leetcode第67题\t2020.07.10\n字节跳动\t后端\t3 sum\t2020.07.10\n字节跳动\t客户端\t字符串反转\t2020.07.10\n字节跳动\t后端\t先问两个无序数组怎么找交集。\t2020.07.10\n字节跳动\t客户端\t手撕数组A-数组B\t2020.07.10\n字节跳动\t客户端\t手撕旋转矩阵90度\t2020.07.10\n字节跳动\tc++、\t手撕代码 求m个数中最大的n个数\t2020.07.10\n字节跳动\t服务端\t7.手撕代码，一道旋转链表的题目，leetcode easy水平\t2020.07.10\n字节跳动\t服务端\t8.手撕代码，一道矩阵相乘，也很简单。\t2020.07.10\n字节跳动\t算法\t给定一个数组，求连续子序列乘积为完全平方数的最大长度\t2020.07.10\n字节跳动\t算法\t判断给定序列是否为二叉搜索树的前序遍历\t2020.07.10\n字节跳动\t前端\t算法题：数组去重\t2020.07.10\n字节跳动\t前端\t爬楼梯\t2020.07.10\n字节跳动\t后端\t算法题，最长连续相同字符的子串\t2020.07.10\n字节跳动\t后端\t写个题，每K个节点翻转链表\t2020.07.10\n字节跳动\t后端\t1.原题，字符串全排列\t2020.07.09\n字节跳动\t后端\t2.原题，二叉树的最大路径和\t2020.07.09\n字节跳动\t后端\t1、类似于并查集的问题，最终求连通分量的数量\t2020.07.09\n字节跳动\t客户端\t算法题 镜像二叉树\t2020.07.09\n字节跳动\t测试\t算法题： leetcode1636\t2020.07.09\n字节跳动\t测试\t我一道leetcode 32\t2020.07.09\n字节跳动\t测试\t我一道leetcode 1\t2020.07.09\n字节跳动\t测试\tLeetCode 20 有效的括号\t2020.07.09\n字节跳动\t测试\t平衡二叉树\t2020.07.09\n字节跳动\t测试\t，二叉树遍历\t2020.07.09\n字节跳动\t后台\t回文串判断\t2020.07.09\n字节跳动\t后台\t二叉搜索树转链表\t2020.07.09\n字节跳动\t后台\t二叉树求和leetcode129-讲一下时间复杂度\t2020.07.09\n字节跳动\t后台\t1）求链表的倒数第k个节点\t2020.07.09\n字节跳动\t后台\t（2）序列化和反序列化二叉树\t2020.07.09\n字节跳动\t后台\t（3）求数组的极值点，找出一个满足的就行（二分查找）\t2020.07.09\n字节跳动\t后台\t前序遍历和中序遍历重构二叉树 （不给用HashMap 好在做出来了）\t2020.07.09\n字节跳动\t后台\t算法题：判断回文链表（中间拆分两条链表 后面的反转链表 对比数值是否相等）\t2020.07.09\n字节跳动\t后台\t算法题：奇数位升序偶数位降序的链表要求时间O(n)空间O(1)的排序？（奇偶拆分 偶链反转 归并merge）\t2020.07.09\n字节跳动\t测试\t手撕代码：求一个数组的所有子集\t2020.07.09\n字节跳动\t测试\t手撕代码：驼峰数组最大值\t2020.07.09\n字节跳动\t客户端\t问了一道链表反转；\t2020.07.09\n字节跳动\t客户端\t1、力扣原题113 路径综合\t2020.07.09\n字节跳动\t客户端\t2、给定一个升序数组，可能会有重复的数字，将数组里的数平方后，有多少不同的数。\t2020.07.09\n字节跳动\t前端\t二叉树所有根到叶子节点路径上所有节点，组成的数字之和\t2020.07.08\n字节跳动\t后端\t手撕代码：链表加法\t2020.07.08\n字节跳动\t客户端\t手写算法：链表合并\t2020.07.08\n字节跳动\t客户端\t手写算法：判断一棵树是否是镜像树\t2020.07.08\n字节跳动\t前端\t8、 算法题：判断给定的一颗树是否是 二叉查找树\t2020.07.08\n字节跳动\t前端\t9、算法题：给定一个数字数组，及数字出现次数，\t2020.07.08\n字节跳动\t客户端\t如何判断一颗树是否是完全二叉树\t2020.07.08\n字节跳动\t客户端\tlru\t2020.07.08\n字节跳动\tios\t算法题：求k大数\t2020.07.08\n字节跳动\tios\tleetcode1 两数之和\t2020.07.08\n字节跳动\tios\t剑指offer 62 圆圈中剩下的数字（约瑟夫环问题）\t2020.07.08\n字节跳动\tios\tleetcode 41 缺失的第一个正数\t2020.07.08\n字节跳动\t前端\t输出数组第k大元素\t2020.07.08\n字节跳动\t服务端\t括号匹配\t2020.07.08\n字节跳动\t后端\t链表的两两翻转\t2020.07.08\n字节跳动\t后端\tLRu\t2020.07.08\n字节跳动\t测试\t算法：返回一棵树的最大叶节点距离\t2020.07.07\n字节跳动\t测试\t对含有重复数字的数组去重并排序，手撕快排\t2020.07.07\n字节跳动\t测试\t算法:两个大数字符串求和输出字符串\t2020.07.07\n字节跳动\t测试\tlru\t2020.07.07\n字节跳动\t后端\t一面：最大连续子序列和和回文链表\t2020.07.07\n字节跳动\t后端\t二面：一个奇数位升序、偶数位降序的单向无环链表，排成一个有序链表\t2020.07.07\n字节跳动\t后端\t三面：S型打印二叉树，两条单向链表的相交节点，任意数组中的第一个缺失的正整数\t2020.07.07\n字节跳动\t客户端\t字符串反转\t2020.07.07\n字节跳动\t测试\t来个简单的—第一题：求二叉树最大长度\t2020.07.07\n字节跳动\t测试\t第二题：用String存两个很长的数，求和\t2020.07.07\n字节跳动\t后端\t1. 第一题 判断是否回文链表\t2020.07.07\n字节跳动\t后端\t2. 第二题 求逆数对\t2020.07.07\n字节跳动\t后端\t3.第三题 动态规划\t2020.07.07\n字节跳动\t后端\t1.第一题 最大化股票交易\t2020.07.07\n字节跳动\t后端\t2.第二题 最大化股票交易（有限交易）\t2020.07.07\n字节跳动\t客户端\t手撕代码 反转链表。\t2020.07.07\n字节跳动\t测试\t7.代码：驼峰字符串问题\t2020.07.07\n字节跳动\t后台\t算法题：滑动窗口匹配字符串\t2020.07.07\n字节跳动\t前端\t1. 实现斐波纳西数列（\t2020.07.07\n字节跳动\t算法\t用两个栈实现一个队列\t2020.07.07\n字节跳动\t算法\t一个list，一个target，求list中两数之和等于target的所有组合，list中有重复的，算medium吧。\t2020.07.07\n字节跳动\t算法\t1. Leetcode124\t2020.07.07\n字节跳动\t后端\t补充：8. 大数问题中的topK问题\t2020.07.07\n字节跳动\t后端\t补充：9. 给整数数组做数字次数统计，答unordered_map，让我再想其他方法，不会。\t2020.07.07\n字节跳动\t后端\t1.给你一个数组和一个target，找出和是target整数倍的连续子串\t2020.07.07\n字节跳动\t后端\t2.一个括号字符串，找出最长合法长度（写完了，优化一下，优化了）\t2020.07.07\n字节跳动\t算法\t子序最大和（要求子序列长度大于等于k）\t2020.07.07\n字节跳动\t后端\tLC128\t2020.07.07\n字节跳动\t客户端\t找链表交点，\t2020.07.07\n字节跳动\t客户端\t1. 判断二叉树是否镜像\t2020.07.07\n字节跳动\t客户端\t2. 给一个分数n/m，如果这个分数是无线循环小数，找出循环位。\t2020.07.07\n字节跳动\t客户端\t3. I am student 返回 student am I\t2020.07.07\n字节跳动\t客户端\t6.先升后降数组，找峰值的坐标，二分法\t2020.07.07\n字节跳动\t测试\t5. 撕代码环节：题目为leetcode第三题，求最长连续不含重复字符子串\t2020.07.07\n","description":"","id":6,"section":"talks","tags":[""],"title":"Leetcode高频","uri":"https://vhope.cf/zh/talks/leetcode-hot/"},{"content":"描述符的就绪状态有两种判断方法: 边沿触发和水平触发。\n水平触发\n我认为这是“拉”模式或“民意调查”模式。为了确定描述符是否就绪，进程尝试执行非阻塞 I/O 操作。一个进程可以多次执行这样的操作。这允许在处理任何后续 I/O 操作方面有更大的灵活性ー例如，如果描述符已经准备好，进程可以选择读取所有可用的数据或者根本不执行任何 I/O 操作，或者选择不读取缓冲区中所有可用的输入数据。让我们通过一个例子来看看它是如何工作的。\n在 t0时，进程可以在非阻塞描述符上尝试 I/O 操作。如果 I/O 操作阻塞，系统调用将返回一个错误。\n然后在 t1时，进程可以再次尝试在描述符上进行 I/O。假设调用再次阻塞，并返回一个错误。\n然后在时间 t2，进程再次尝试描述符上的 I/O。假设调用再次阻塞，并返回一个错误。\n假设在 t3时，进程轮询描述符的状态，描述符就绪。然后进程可以选择实际执行整个 I/O 操作(例如，读取套接字上的所有可用数据)。\n让我们假设在 t4时进程轮询描述符的状态，而描述符没有准备好。调用再次阻塞，并且 I/O 操作返回一个错误。\n假设在 t5时，进程轮询描述符的状态，描述符就绪。进程随后可以选择只执行部分 I/O 操作(例如，只读取所有可用数据的一半)。\n​\t假设在 t6时，进程轮询描述符的状态，描述符就绪。这一次，进程可以选择根本不执行后续的 I/O。\n边缘触发 流程只有在文件描述符“就绪”时才会收到通知(通常是在文件描述符上有任何新活动时，因为它是上次被监视的)。我认为这就是“推送”模型，因为通知被推送到进程中，说明文件描述符的准备就绪情况。此外，对于 push 模型，只通知进程说描述符已经为 I/O 准备好了，而不提供其他信息，例如到达 socket 缓冲区的字节数。\n因此，当一个进程试图执行任何后续 I/O 操作时，它只配备了不完整的数据。为了解决这个问题，进程可以在每次获得描述符准备就绪通知时，尝试执行尽可能大的 I/O，因为如果不这样做，就意味着进程必须等待下一个通知到来，即使在下一个通知到来之前，在描述符上可以进行 I/O。\n开始：\n在 t2时，进程得到一个关于描述符已经准备好的通知。\n可用于 I/O 的字节流存储在缓冲区中。假设当进程在时间 t2获得通知时，有1024个字节可供读取。\n假设该进程只读取1024个字节中的500个字节。\n这意味着在 t3、 t4和 t5时，缓冲区中仍然有524个字节可供进程读取而不会阻塞。但是，由于进程只能在获得下一个通知后执行 I/O，因此在这段时间内，这524个字节将保留在缓冲区中。\n假设进程在时间 t6获得下一个通知，当额外的1024个字节到达缓冲区时。缓冲区上可用的数据总量现在是1548字节ー524字节，以前没有读过，1024字节是新到的。\n假设进程现在读取1024个字节。\n这意味着在第二次 I/O 操作结束时，524个字节仍然保留在缓冲区中，在下一个通知到达之前，进程将无法读取这个缓冲区。\n虽然在通知到达后立即执行所有 I/O 可能是临时的，但这样做会产生一些后果。单个描述符上的大型 I/O 操作可能会饿死其他描述符。此外，即使在级别触发通知的情况下，一个非常大的写或发送调用也有可能阻塞。\nMultiplexing I/O on descriptors 有几种在描述符上多路 I/O 的方法:\n— non-blocking I/O (the descriptor itself is marked as non-blocking, operations may finish partially)\n— signal driven I/O (the process owning the descriptor is notified when the I/O state of the descriptor changes)\n— polling I/O (with *select* or *poll* system calls, both of which provide level triggered notifications about the readiness of descriptors)\n— BSD specific kernel event polling (with the *kevent* system call).\n参考：\n https://medium.com/@copyconstruct/the-method-to-epolls-madness-d9d2d6378642  ","description":"","id":7,"section":"posts","tags":["Linux","epoll"],"title":"epoll的水平触发与边缘触发","uri":"https://vhope.cf/zh/posts/linux/epoll-lt-et/"},{"content":"HTTP/1.x  在早期，HTTP 使用一个简单的模型来处理这样的连接。这些连接的生命周期是短暂的：每发起一个请求时都会创建一个新的连接，并在收到应答时立即关闭。\n 当请求发起时，网络延迟和带宽都会对性能造成影响。现代浏览器往往要发起很多次请求(十几个或者更多)才能拿到所需的完整信息，证明了这个早期模型的效率低下。\n在 HTTP/1.x 里有多种模型：短连接, 长连接, 和 HTTP 流水线。\n短链接模型 HTTP/1.0 的默认模型。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。\n 在 HTTP/1.1 中，只有当 Connection 被设置为 close 时才会用到这个模型\n 长连接模型 保持连接去完成多次连续的请求，减少了不断重新打开连接的时间。在 HTTP/1.1 里，默认就是长连接的。\n 短连接有两个比较大的问题：创建新连接耗费的时间尤为明显，另外 TCP 连接的性能只有在该连接被使用一段时间后(热连接)才能得到改善。另外我们知道，TCP协议有个滑动窗口，有慢启动这回事，就是说每次建立新连接后，数据先是慢慢地传，然后滑动窗口慢慢变大，才能较高速度地传。\n 具体流程：\n一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。\n缺点：\n就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 DoS attacks 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。\n流水线模型 多个连续的请求甚至都不用等待立即返回就可以被发送。HTTP 流水线在现代浏览器中并不是默认被启用的。\n默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。\n流水线是在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续，尺寸会增加，但设置 TCP 的 MSS(Maximum Segment Size) 选项，仍然足够包含一系列简单的请求。\nHTTP/2 HTTP/2 没有改动 HTTP 的应用语义。 HTTP 方法、状态代码、URI 和标头字段等核心概念一如往常。 不过，HTTP/2 修改了数据格式化（分帧）以及在客户端与服务器间传输的方式。这两点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性。 因此，所有现有的应用都可以不必修改而在新协议下运行。\n 为什么不是 HTTP/1.2？\n为了实现 HTTP 工作组设定的性能目标，HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP/1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2。\n 二进制分帧层 HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。\n这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。 HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。\n数据流、消息和帧  数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。 消息：与逻辑请求或响应消息对应的完整的一系列帧。 帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。  关系：\n 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。  HTTP/2 帧结构如下：\n实际的传输过程可能是下面这样(吞吐量增大)：\n请求与响应复用 HTTP/2 中新的二进制分帧层实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。\n数据流优先级 我们来看一下上图中的几个操作示例。 从左到右依次为：\n 数据流 A 和数据流 B 都没有指定父依赖项，依赖于隐式“根数据流”；A 的权重为 12，B 的权重为 4。因此，根据比例权重：数据流 B 获得的资源是 A 所获资源的三分之一。 数据流 D 依赖于根数据流；C 依赖于 D。 因此，D 应先于 C 获得完整资源分配。 权重不重要，因为 C 的依赖关系拥有更高的优先级。 数据流 D 应先于 C 获得完整资源分配；C 应先于 A 和 B 获得完整资源分配；数据流 B 获得的资源是 A 所获资源的三分之一。 数据流 D 应先于 E 和 C 获得完整资源分配；E 和 C 应先于 A 和 B 获得相同的资源分配；A 和 B 应基于其权重获得比例分配。  流控制 流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力：发送方可能非常繁忙、处于较高的负载之下，也可能仅仅希望为特定数据流分配固定量的资源。 例如，客户端可能请求了一个具有较高优先级的大型视频流，但是用户已经暂停视频，客户端现在希望暂停或限制从服务器的传输，以免提取和缓冲不必要的数据。 再比如，一个代理服务器可能具有较快的下游连接和较慢的上游连接，并且也希望调节下游连接传输数据的速度以匹配上游连接的速度来控制其资源利用率；等等。类似TCP流量控制。\n服务器推送 TTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源（图 12-5），而无需客户端明确地请求。\n标头压缩 每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：\n 这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。  利用霍夫曼编码，可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。\n参考链接：\n HTTP 连接管理进化论 https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn  ","description":"http协议","id":8,"section":"posts","tags":["network","http","https"],"title":"Http协议浅析","uri":"https://vhope.cf/zh/posts/network/http/"},{"content":"Interview   C++空类产生哪些成员函数？\n构造、拷贝构造、取地址、、取地址const，赋值、析构\nC++ 空类默认产生的类成员函数\n  TCP三次握手和四次挥手，何时进入CLOSE-WAIT状态？\nhttps://zhuanlan.zhihu.com/p/86426969\n  智能指针，具体实现？\n自己动手实现一个C++智能指针\n  构造析构函数调用顺序（包括类里面的虚函数调用顺序）\nC++构造函数和析构函数的调用顺序\n  第三方库动态链接后存在程序内存空间的哪个位置？\ndynamic段中保存了可执行文件依赖哪些动态库,动态链接符号表的位置以及重定位表的位置等信息。当加载可执行文件时,操作系统根据dynamic段中的信息即可找到使用的动态库,从而完成动态链接。\n静态链接与动态链接：\nhttps://segmentfault.com/a/1190000016433897\nLinux 动态库剖析\n  进程/线程 区别 （线程共享进程的什么资源）？\nhttps://blog.csdn.net/WangQYoho/article/details/52598859\n  用户态和核心态的区别？\n 内核态（Kernel Mode）：运行操作系统程序 用户态（User Mode）：运行用户程序   当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。  https://blog.csdn.net/justlpf/article/details/99447462 用户态和核心态的区别\n  调度策略\n **先来先服务调度算法：**先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。 **短作业(进程)优先调度算法：**短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。 高优先权优先调度算法：为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存 **高响应比优先调度算法：**在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。 **时间片轮转法：**在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。 **多级反馈队列调度算法：**前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。    分页和分段有什么区别？\n 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定 段向用户提供二维地址空间；页向用户提供的是一维地址空间 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。    关于重载、重写、隐藏（总是不记得）的区别\nOverload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。 （1）相同的范围（在同一个类中）； （2）函数名字相同； （3）参数不同； （4）virtual 关键字可有可无。 Override(重写)：是指派生类函数覆盖基类函数，特征是： （1）不同的范围（分别位于派生类与基类）； （2）函数名字相同； （3）参数相同； （4）基类函数必须有virtual 关键字。注：重写基类虚函数的时候，会自动转换这个函数为virtual函数，不管有没有加virtual，因此重写的时候不加virtual也是可以的，不过为了易读性，还是加上比较好。 Overwrite(隐藏)：隐藏，是指派生类的函数屏蔽了与其同名的基类函数，规则如下： （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。   排序算法\n  STL容器的特点\n  分段和分页\n  基本分页储存管理方式?\n  基本分段储存管理方式?\n  几种页面置换算法，会算所需换页数?\n  虚拟内存的定义及实现方式?\n  函数调用和系统调用的区别？\n系统调用 （常见Linux及其分类表）\n  TLB的作用及工作过程\n  什么是虚拟内存？\n虚拟内存 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。\n通过虚拟地址访问内存有以下优势：\n 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。    描述符 Unix 中所有 I/O 的基本构建块是一个字节序列。大多数程序使用更简单的抽象——字节流或 I/O 流。\n流程通过描述符(也称为文件描述符)引用 I/O 流。管道、文件、 FIFOs、 POSIX IPC (消息队列、信号量、共享内存)、事件队列都是由描述符引用的 I/O 流的例子。\nclose-on-exec 当一个进程进行fork时，所有的描述符在子进程中被“复制”。如果任何一个描述符在 exec 上标记为 close，那么在父进程fork之后但在子进程执行之前，子进程中标记为“ close-on-exec”的描述符将被关闭，不再可用于子进程。\n1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;int main(char *argv[]) { int fd = open(\u0026#34;abc.txt\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0666); fork(); write(fd, \u0026#34;xyz\u0026#34;, 3); printf(\u0026#34;%ld\\n\u0026#34;, lseek(fd, 0, SEEK_CUR)); close(fd); return 0; }   文件接口 Socket文件描述符 大多数网络是使用套接字完成的。套接字由描述符引用，并充当通信的端点。两个进程可以创建两个套接字，并通过连接这两个端点建立一个可靠位元组流。一旦建立了连接，就可以使用上面描述的文件偏移量读取描述符或写入描述符。内核可以将一个进程的输出重定向到另一台机器上的另一个进程的输入。相同的读写系统调用用于字节流类型的连接，但不同的系统调用处理像网络数据报这样的寻址消息。\n大多数网络是使用套接字完成的。套接字由描述符引用，并充当通信的端点。两个进程可以创建两个套接字，并通过连接这两个端点建立一个可靠位元组流。一旦建立了连接，就可以使用上面描述的文件偏移量读取描述符或写入描述符。内核可以将一个进程的输出重定向到另一台机器上的另一个进程的输入。相同的读写系统调用用于字节流类型的连接，但不同的系统调用处理像网络数据报这样的寻址消息。\n非阻塞 大多数网络是使用套接字完成的。套接字由描述符引用，并充当通信的端点。两个进程可以创建两个套接字，并通过连接这两个端点建立一个可靠位元组流。一旦建立了连接，就可以使用上面描述的文件偏移量读取描述符或写入描述符。内核可以将一个进程的输出重定向到另一台机器上的另一个进程的输入。相同的读写系统调用用于字节流类型的连接，但不同的系统调用处理像网络数据报这样的寻址消息。\n当 I/O 事件发生时，比如新输入的到达或者套接字连接的完成，或者当 TCP 传输排队数据到套接字对等点之后，之前满的套接字发送缓冲区上有空间时，描述符就会变成就绪状态。\n数据库 http://blog.codinglabs.org/articles/theory-of-mysql-index.html\n  说一下聚簇索引 \u0026amp; 非聚簇索引？\nhttps://juejin.im/post/5cdd701ee51d453a36384939\n  数据库事务的四大特性以及事务的隔离级别？\nhttps://www.cnblogs.com/fjdingsd/p/5273008.html\n   参考连接 ：\n https://wdxtub.com/interview/14520847747820.html 操作系统 Linux下缓冲区溢出攻击的原理及对策 https://www.cnblogs.com/lesleysbw/p/6438941.html 《后端架构师技术图谱》  ","description":"","id":9,"section":"talks","tags":[""],"title":"interview","uri":"https://vhope.cf/zh/talks/interview/"},{"content":"树是一种非常实用的结构！🌴\n以下的二叉树采用的结构都为链式结构\n1 2 3 4 5  typedef struct BiTNode /* 结点结构 */ { int data; /* 结点数据 */ struct BiTNode *lchild, *rchild; /* 左右孩子指针 */ } BiTNode, *BiTree;   1. 二叉排序树  二叉排序树又称“二叉查找树”、“二叉搜索树”。\n 定义 或者是一棵空树，或者是具有下列性质的二叉树：\n  若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n  若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n  它的左、右子树也分别为二叉排序树。\n   中序遍历二叉排序树可得到一个依据关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即是对无序序列进行排序的过程。每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的时间复杂度等于树高，期望O(logn)，最坏O(n)（数列有序，树退化成线性表，如右斜树）。\n 查找算法 查找过程：\n1.若b是空树，则搜索失败，否则：\n2.若x等于b的根节点的数据域之值，则查找成功；否则：\n3.若x小于b的根节点的数据域之值，则搜索左子树；否则：\n4.查找右子树。\n5.若查找不成功， 则指针 p 指向查找路径上访问的最后一个结点并返回FALSE\n插入算法 插入过程：\n  先调用查找操作将要插入的关键字进行比较\n  如果在原有的二叉排序树中没有要插入的关键字，则将关键字与查找的结点p（在查找操作中返回的结点）的值进行比较\n  若p为空，则插入关键字赋值给该节点；\n  若小于结点p的值，则插入关键字作为结点p的左子树；\n  若大于结点p的值，则插入关键字作为结点p的右子树；\n   每次需要插入的节点都为叶子节点。\n 删除算法 删去一个结点，分三种情况讨论：\n  若*p结点为叶子结点，即PL(左子树)和PR(右子树)均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。\n  若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉排序树的特性。\n  若p结点的左子树和右 子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整。比较好的做法是，找到*p的**直接前驱（或直接后继）s，用s来替换结点p，然后再删除结点s。(依靠中序遍历在p节点下进行遍历得到的最后一个数即为替换的节点)\n  性能分析  最好的情况是二叉排序树的形态和折半查找的判定树相同，其平均查找长度和logn成正比（O(log2(n))）。 最坏情况下，当先后插入的关键字有序时，构成的二叉排序树为一棵斜树，树的深度为n，其平均查找长度为(n + 1) / 2。也就是时间复杂度为O(n)，等同于顺序查找。   虽然二叉排序树的最坏效率是O(n)，但它支持动态查找。最好是把它构建成一棵平衡的二叉排序树（平衡二叉树），这些平衡二叉树可以使树高为O(logn)，如AVL、红黑树等。\n 2. 平衡二叉树（AVL） 定义 它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。\n平衡因子(bf)：结点的左子树的深度减去右子树的深度，那么显然-1\u0026lt;=bf\u0026lt;=1;\n 在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。\n 查找、插入和删除在平均和最坏情况下的时间复杂度都是$O(log(n))$。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。\n查找操作 平衡二叉树的查找基本与二叉查找树相同。\n插入操作 在平衡二叉树中插入结点与二叉查找树最大的不同在于要随时保证插入后整棵二叉树是平衡的。那么调整不平衡树的基本方法就是： 旋转 。\n首先，还需要明白的一个概念就是：\n最小不平衡子树的根结点：也就是当你进行插入操作时，找到该需要插入结点的位置并插入后，从该结点起向上寻找（回溯），第一个不平衡的结点即平衡因子bf变为-2或2的节点。\n 那究竟是如何“转”的呢？\n其实，可以换一种思路思考，不让它叫“旋转”！而叫——\u0026gt;“两个结点的变换”\n 下面分情况分析四种旋转方式\n左左 即在x的左孩子a的左孩子c上插入一个结点y（该结点也可以是c,如图①），即y可以是c，也可以是c的左孩子（如图②），也可以是c的右孩子（不在画出）\n 这种左左插入方式有一个规律：不平衡子树的左子树深度比右子树深度大2.\n 图①②插入的节点都为y，此时向上回溯第一个不平衡的子树根节点为x，那么将x节点及其右子树(图①为NULL，图②为b)一起绕着x的左子树根节点(即a)右旋(即顺时针旋转),然后将a的右子树作为x的左子树，假如a的右子树为空则不必插入。那么这样旋转最后将不平衡子树变为平衡。\n右右 即在x的右孩子a的右孩子c上插入一个结点y（该结点也可以是c,如图①），即y可以是c，也可以是c的右孩子（如图②），也可以是c的左孩子（不在画出）\n 这种右右插入方式有一个规律：不平衡子树的左子树深度比右子树深度小2.\n 图①②插入的节点都为y，此时向上回溯找到第一个不平衡子树的节点为x，需要将节点x及其左子树(图①为NULL，图二为b)绕着x右子树(两图都为a为根节点的子树)进行左旋(逆时针旋转),然后将其右子树(a)的左节点作为x的右节点，这样使得不平衡子树又再度平衡。\n左右 即在x的左孩子a的右孩子c上插入一个结点y（该结点也可以是c,如图①），即y可以是c，也可以是c的右孩子（如图②），也可以是c的左孩子（不在画出）\n 这种左右插入的规律就是：不平衡子树的左子树高度比右子树大2且左子树的右子树比左子树的左子树深度深。\n 向上回溯的第一个不平衡子树为x，先对x的左子树左旋(旋转中心为c)，再对x的左子树进行右旋(旋转中心为c)。(旋转中心为左子树的右节点)\n 如果是图①，旋转中心为y\n 右左 即在x的右孩子a的左孩子c上插入一个结点y（该结点也可以是c,如图①），即y可以是c，也可以是c的右孩子（如图②），也可以是c的左孩子（不在画出）\n 这种右左插入的规律就是：不平衡子树的右子树高度比左子树大2且右子树的左子树比右子树的右子树深度深。\n 向上回溯的第一个不平衡子树为x，先对x的右子树右旋(旋转中心为c)，再对x的右子树进行左旋(旋转中心为c)。(旋转中心为左子树的右节点)\n 如果是图①，旋转中心为y\n AVL树的操作汇总：\n删除操作 删除类似插入的操作。删除时少一个结点，也就是该结点所在的子树深度可能会减小，而插入时多一个结点，该结点所在的子树深度可能会增加，所以递归删除一个结点时，回溯时找到最小不平衡子树的根结点时，要向相反的方向去找属于哪种情况；\n如图y为要删除的节点\n图①：y结点删除后，回溯到x结点从bf=-1变为bf=-2；则需从相反方向即从x的右孩子的方向向下检查属于哪种情况，显然第一个方向为1：右；第二个方向看a的bf的值——若为1时，那就相当于插入时‘右左’的情况；若为-1时，那就相当于插入时‘右右’的情况；可现在a的bf既不是1也不是-1而是0，这就是删除的特殊情况了！我们不妨试试对他进行类似于插入时的‘右右’操作，看怎么样~ 如上图，经过变换后该子树平衡了！但是因子的修改就跟插入时的‘右右’不一样了！此时变为：x的bf=-1,a的bf=1；所以我们不妨就把a的bf=0也归纳为删除的‘右右’或‘左左’（如图②，不再敖述）操作；\n那么删除时因子的改变需在插入时因子的改变中添加上：\n左左：前a:bf=0 后x:bf=1,a:bf=-1； 右右：前a:bf=0 后x:bf=-1,a:bf=1；其他不变！\n 可以想象，其实是很简单的道理：除了特殊情况其他都与插入的情况一模一样，说白了就是把深度大的子树（根结点的其中一个）向深度小子树贡献一个深度，那么这样一来，该子树（对于根结点所领导的树）的深度是不是比原来的小1了？！所以要继续向上一个一个进行检索，直到根结点为止！\n 代码实现 https://blog.csdn.net/nightwizard2030/article/details/72874715\n性能分析 优势 平衡二叉树的优势在于不会出现普通二叉查找树的最差情况。其查找的时间复杂度为$O(logN)$。\n缺陷  为了保证高度平衡，动态插入和删除的代价也随之增加. 所有二叉查找树结构的查找代价都与树高是紧密相关的，能否通过减少树高来进一步降低查找代价呢。  应用场景 应用：windows对进程地址空间的管理用到了AVL树。\n3. 红黑树 也被称为\u0026rdquo;对称二叉B树\u0026quot;。\n定义 红黑树(red-black tree) 是一棵满足下述性质的二叉查找树：\n  每一个结点要么是红色，要么是黑色。\n  根结点是黑色的。\n  所有叶子结点都是黑色的（实际上都是Null指针，下图用NIL表示）。叶子结点不包含任何关键字信息，所有查询关键字都在非终结点上。\n  每个红色结点的两个子节点必须是黑色的。换句话说：从每个叶子到根的所有路径上不能有两个连续的红色结点\n  从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点\n  几个概念：\n黑深度 ——从某个结点x出发(不包括结点x本身)到叶结点(包括叶子结点)的路径上的黑结点个数,称为该结点x的黑深度,记为$bd(x)$,根结点的黑深度就是该红黑树的黑深度。叶子结点的黑深度为0。比如：上图$bd(13)=2， bd(8)=2， bd(1)=1$\n内部结点 —— 红黑树的非终结点\n外部节点 —— 红黑树的叶子结点\n相关原理  从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。 红黑树的树高$(h)$不大于两倍的红黑树的黑深度$(bd)$，即$h\u0026lt;=2bd$ 一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高$h\u0026lt;=2log(n+1)$  查找操作 因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同.\n插入操作 我们首先以二叉查找树的方法增加节点并标记它为红色。下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。\n假设新加入的结点为N，父亲结点为P，叔父结点为Ui(叔父结点就是一些列P的兄弟结点)，祖父结点G(父亲结点P的父亲)。\n情况1. 当前红黑树为空，新结点N位于树的根上，没有父结点。\n此时很简单，我们将直接插入一个黑结点N（满足性质2），因为是特殊大的情况，不插入红色而插入黑色节点。\n情况2. 新结点N的父结点P是黑色。\n在这种情况下，我们插入一个红色结点N(满足性质5)\n 注意：在情况3，4，5下，我们假定新节点有祖父节点，因为父节点是红色；并且如果它是根，它就应当是黑色。所以新节点总有一个叔父节点，尽管在情形4和5下它可能是叶子。\n 情况3.如果父节点P和叔父节点U二者都是红色。\n如下图，因为新加入的N结点必须为红色，那么我们可以将父结点P(保证性质4)，以及N的叔父结点U(保证性质5)重新绘制成黑色。如果此时祖父结点G是根，则结束变化。如果不是根，则祖父结点重绘为红色(保证性质5)。但是，G的父亲也可能是红色的，为了保证性质4。我们把G递归当做新加入的结点N在进行各种情况的重新检查。\n 注意：在情形4和5下，我们假定父节点P 是祖父结点G 的左子节点。如果它是右子节点，情形4和情形5中的左和右应当对调。\n 情况4. 父节点P是红色而叔父节点U是黑色或缺少; 另外，新节点N是其父节点P的右子节点，而父节点P又是祖父结点G的左子节点。\n如下图, 在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色（与AVL树的左旋转相同）; 这导致某些路径通过它们以前不通过的新节点N或父节点P中的一个，但是这两个节点都是红色的，所以性质5没有失效。但目前情况将违反性质4，所以接着，我们按下面的情况5继续处理以前的父节点P。\n情况5. 父节点P是红色而叔父节点U 是黑色或缺少，新节点N 是其父节点的左子节点，而父节点P又是祖父结点的G的左子节点。\n如下图： 在这种情形下，我们进行针对祖父节点P 的一次右旋转; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G 的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4[3]。性质 5[4]也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G ，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。\n删除操作 相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（该节点右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。我们并不关心最终被删除的节点是否是我们开始想要删除的那个节点，只要节点里的值最终被删除就行了，至于树结构如何变化，这个并不重要。\n应用场景 工业界最主要使用的二叉搜索平衡树，广泛用在C++的STL中。如map和set都是用红黑树实现的。Java用它来实现TreeMap。著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。\n epoll在内核中的实现，用红黑树管理事件块 nginx中，用红黑树管理timer等  Code 实现：https://www.cnblogs.com/skywang12345/p/3624291.html\n红黑树节点定义 1 2 3 4 5 6 7 8 9 10 11 12  template \u0026lt;class T\u0026gt; class RBTNode { public: RBTColor color; // 颜色  T key; // 关键字(键值)  RBTNode *left; // 左孩子  RBTNode *right; // 右孩子  RBTNode *parent; // 父结点  RBTNode(T value, RBTColor c, RBTNode *p, RBTNode *l, RBTNode *r) : key(value), color(c), parent(), left(l), right(r) {} };   颜色定义 1 2 3 4 5  enum RBTColor { RED, BLACK };   4.B树 背景\n一个比较实际的问题：就是大量数据存储中，实现查询这样一个实际背景下，平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。那么如何减少树的深度（当然不能减少查询数据量），一个基本的想法就是：\n  每个节点存储多个元素 （但元素数量不能无限多，否则查找就退化成了节点内部的线性查找了）。\n  摒弃二叉树结构，采用多叉树 （由于节点内元素数量不能无限多，自然子树的数量也就不会无限多了）。\n  这样我们就提出来了一个新的查找树结构 ——多路查找树。 根据AVL给我们的启发，一颗平衡多路查找树(B~树) 自然可以使得数据的查找效率保证在O(logN)这样的对数级别上。\n 目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构\n B-树 B-树是一种多路搜索树。\nB-Tree 是满足下列条件的数据结构：\n d 为大于 1 的一个正整数，称为 B-Tree 的度。 h 为一个正整数，称为 B-Tree 的高度。 每个非叶子节点由 n-1 个 key 和 n 个指针组成，其中 d\u0026lt;=n\u0026lt;=2d。 每个叶子节点最少包含一个 key 和两个指针，最多包含 2d-1 个 key 和 2d 个指针，叶节点的指针均为 null 。 所有叶节点具有相同的深度，等于树高 h。 key 和指针互相间隔，节点两端是指针。 一个节点中的 key 从左到右非递减排列。 所有节点组成树结构。 每个指针要么为 null，要么指向另外一个节点。 如果某个指针在节点 node 最左边且不为 null，则其指向节点的所有 key 小于 v(key1)，其中 v(key1) 为 node 的第一个 key 的值。 如果某个指针在节点 node 最右边且不为 null，则其指向节点的所有 key 大于 v(keym)，其中 v(keym) 为 node 的最后一个 key 的值。 如果某个指针在节点 node 的左右相邻 key 分别是 keyi 和 keyi+1 且不为 null，则其指向节点的所有 key 小于 v(keyi+1) 且大于 v(keyi)。  性质：\n  根结点至少有两个子女；\n  每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 \u0026lt;= j \u0026lt;= m - 1；\n  除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ \u0026lt;= k \u0026lt;= m ；\n  所有的叶子结点都位于同一层。\n   用在磁盘文件组织 数据索引和数据库索引。\n B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，例：\n每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。\n两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。\n以根节点为例，关键字为 17 和 35，P1 指针指向的子树的数据范围为小于 17，P2 指针指向的子树的数据范围为 17~35，P3 指针指向的子树的数据范围为大于 35。\n模拟查找关键字 29 的过程：\n 根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】 比较关键字 29 在区间（17,35），找到磁盘块 1 的指针 P2。 根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】 比较关键字 29 在区间（26,30），找到磁盘块 3 的指针 P2。 根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】 在磁盘块 8 中的关键字列表中找到关键字 29。   B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。\n B+树 B+树是B-树的变体，也是一种多路搜索树：\n1.其定义基本与B-树同，除了：\n2.非叶子结点的子树指针与关键字个数相同；\n3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树\n（B-树是开区间）；\n5.为所有叶子结点增加一个链指针；\n6.所有关键字都在叶子结点出现；\n 用在磁盘文件组织 数据索引和数据库索引。MySQL常用的引擎InnoDB 和 Myisam 都是用 B+Tree 来存储数据的。\nB和B+主要用在文件系统以及数据库中做索引等，比如Mysql：B-Tree Index in MySql\n  在 B-Tree 中，每个节点中有 key，也有 data，而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小。当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。\n B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。\nB+Tree 在 B-Tree 的基础上有两点变化：\n 数据是存在叶子节点中的； 数据节点之间是有指针指向的。  由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：\nMySQL应用 我们通常所说的在某个字段上建索引，意思就是让 MySQL 对该字段以索引这种数据结构来存储，然后查找的时候就有对应的查找算法。\n建索引的根本目的是为了查找的优化，特别是当数据很庞大的时候，一般的查找算法有顺序查找、折半查找、快速查找等。\n InnoDB\nInnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。  InnoDB 中存在表锁和行锁，不过行锁是在命中索引的情况下才会起作用。\nInnoDB 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读；而在 Oracle 数据库中，只支持串行化级别和读已提交这两种级别，其中默认的为读已提交级别。\nInnoDB 通过 B+Tree 结构对 ID 建索引，然后在叶子节点中存储记录。\nMyisam\nMyisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。  Myisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。\n由于 Myisam 中的索引和数据分别存放在不同的文件，所以在索引树中的叶子节点中存的数据是该索引对应的数据记录的地址，由于数据与索引不在一起，所以 Myisam 是非聚簇索引。\n红黑树和多路查找树都是属于深度有界查找树（depth-bounded tree —DBT）\n2-3-4树 2-3-4 树在计算机科学中是阶为 4 的B树。\n2-3-4 树把数据存储在叫做元素的单独单元中。它们组合成节点，每个节点都是下列之一\n 2-节点，就是说，它包含 1 个元素和 2 个儿子， 3-节点，就是说，它包含 2 个元素和 3 个儿子， 4-节点，就是说，它包含 3 个元素和 4 个儿子 。  每个儿子都是（可能为空）一个子 2-3-4 树。根节点是其中没有父亲的那个节点；它在遍历树的时候充当起点，因为从它可以到达所有的其他节点。叶子节点是有至少一个空儿子的节点。\n同B树一样，2-3-4 树是有序的：每个元素必须大于或等于它左边的和它的左子树中的任何其他元素。每个儿子因此成为了由它的左和右元素界定的一个区间。\n2-3-4 树是红黑树的一种等同，这意味着它们是等价的数据结构。换句话说，对于每个 2-3-4 树，都存在着至少一个数据元素是相同次序的红黑树。在 2-3-4 树上的插入和删除操作也等价于在红黑树中的颜色翻转和旋转。这使得它成为理解红黑树背后的逻辑的重要工具。\n字典树 (又称trie 树，单词查找树)\n1.又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。\n典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。\n2.它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。\n3.字典树与字典很相似,当你要查一个单词是不是在字典树中,首先看单词的第一个字母是不是在字典的第一层,如果不在,说明字典树里没有该单词,如果在就在该字母的孩子节点里找是不是有单词的第二个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来储存字母,也可以储存数字等其它数据。\n 用在统计和排序大量字符串，如自动机。\ntrie 树的一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示\n还有比如IP选路，也是前缀匹配，一定程度会用到trie\n  后缀树\n  广义后缀树\n  参考：\n https://www.cnblogs.com/zhuyf87/archive/2012/11/09/2763113.html 二叉排序树 https://www.cnblogs.com/fornever/archive/2011/11/15/2249492.html 平衡二叉树（解惑） https://www.iteye.com/blog/hxraid-609949 平衡二叉查找树 https://www.iteye.com/blog/hxraid-611816 红黑树(RBT) https://www.zhihu.com/question/30527705 树的应用场景 说一下聚簇索引 \u0026amp; 非聚簇索引 MySQL索引背后的数据结构及算法原理 ","description":"","id":10,"section":"posts","tags":["二叉树"],"title":"高级的二叉树","uri":"https://vhope.cf/zh/posts/algorithmstructure/bst/"},{"content":"地址：http://markdown.xiaoshujiang.com/\nThis is a Test!\n","description":"","id":11,"section":"posts","tags":["小书匠"],"title":"使用小书匠在线编写博文","uri":"https://vhope.cf/zh/posts/hugo/xiaoshujiang/"},{"content":"在UE4中获取深度缓存，调用渲染命令读取。\n获取深度缓存 深度像素格式 键入命令vis scenedepthz uv0以查看实际使用的深度缓冲区。UE4对场景使用“反向”深度缓冲区。\nWay1：直接使用ENQUEUE_RENDER_COMMAND命令获取(效率较低) 在任意tick函数或者其他函数添加以下的命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  struct DepthPixel\t//定义深度像素结构体 \t{ float depth; char stencil; char unused1; char unused2; char unused3; }; float* cpuDataPtr;\t// Texture深度值数组首地址 \tTArray\u0026lt;DepthPixel\u0026gt; mydata;\t//最终获取色深度值数据 \tFIntPoint buffsize;\t//深度长宽大小X和Y  ENQUEUE_RENDER_COMMAND(ReadSurfaceFloatCommand)(\t// 将读取深度数据的命令推给渲染线程进行执行 \t[\u0026amp;cpuDataPtr, \u0026amp;mydata, \u0026amp;buffsize](FRHICommandListImmediate\u0026amp; RHICmdList) //\u0026amp;cpuDataPtr, \u0026amp;mydata, \u0026amp;buffsize为传入的外部参数 \t{ FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, 1); FTexture2DRHIRef uTex2DRes = FSceneRenderTargets::Get(RHICmdList).GetSceneDepthSurface();\tbuffsize = uTex2DRes-\u0026gt;GetSizeXY(); uint32 sx = buffsize.X; uint32 sy = buffsize.Y; mydata.AddUninitialized(sx * sy); uint32 Lolstrid = 0; cpuDataPtr = (float*)RHILockTexture2D(uTex2DRes,0,RLM_ReadOnly,Lolstrid,true);\t// 加锁 获取可读depth Texture深度值数组首地址 \tmemcpy(mydata.GetData(), cpuDataPtr, sx * sy * sizeof(DepthPixel));\t//复制深度数据 \tRHIUnlockTexture2D(uTex2DRes, 0, true);\t//解锁 \tFSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, -1);\t}); FlushRenderingCommands();\t//等待渲染线程执行  mydata; //最终获取深度数据   最终返回的mydata数据就是最终的深度值数组，其中每个深度值的结构是DepthPixel，其中一个成员为depth，另外四个不不使用。其中使用上面的几个命令需要添加\u0026quot;RHI.h\u0026quot;头文件\nWay2：写个请求类读取 UML图：\n流程图：\n1. 首先在项目的build.cs文件添加： 添加引擎源码地址\n1 2 3 4 5 6 7 8 9 10  // 添加引擎源码地址  string EnginePath = \u0026#34;C:/Program Files (x86)/UE4+VS2017/UnrealEngine/\u0026#34;; PrivateIncludePaths.AddRange( new string[] { EnginePath + \u0026#34;Source/Runtime/Renderer/Private\u0026#34;, EnginePath + \u0026#34;Source/Runtime/Renderer/Private/CompositionLighting\u0026#34;, EnginePath + \u0026#34;Source/Runtime/Renderer/Private/PostProcess\u0026#34; } );   添加引依赖项\n2. 类实现 将下面类代码复制到PostProcessing.h文件任意位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  /*****************************************Get Depth Class*******************************************************/ /*\t存储一个像素的缓存 depth 深度缓存 stencil （抠图缓存）*/ struct DepthPixel { float depth; char stencil; char unused1; char unused2; char unused3; }; /*\t存储整个视窗的缓存 data\t像素缓存数组 bufferSizeX\t缓存大小X bufferSizeY\t缓存大小Y pixelSizeBytes\t像素缓存字节数*/ struct DepthResult { TArray\u0026lt;DepthPixel\u0026gt; data; int bufferSizeX; int bufferSizeY; int pixelSizeBytes; }; /*\t获取深度缓存的类\t*/ class RENDERER_API DepthCapture { public: /*\t静态成员，当用户发出一个获取深度缓存的请求后，waitForCapture长度加1，新增DepthResult内容为空 当系统完成一个深度缓存的请求后，waitForCapture长度减一 */ static TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; waitForCapture; /*\t静态成员，当系统完成一个深度缓存的请求后，finishedCapture长度加1， 新增DepthResult含有深度缓存信息\t*/ static TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; finishedCapture; public: /*用户发出一个获取深度缓存的请求时调用*/ static void AddCapture() { waitForCapture.Enqueue(new DepthResult()); } /*系统完成一个深度缓存请求后调用*/ static void FinishedCapture(DepthResult *result) { finishedCapture.Enqueue(result); } /*返回是否存在已经完成的请求*/ static bool HasFinishedCapture() { return !finishedCapture.IsEmpty(); } /*如果存在已完成的请求，返回一个深度结果*/ static DepthResult* GetIfExistFinished() { DepthResult* result = NULL; if (!finishedCapture.IsEmpty()) { finishedCapture.Dequeue(result); } return result; } /*返回是否存在等待系统执行的请求*/ static bool HasCaptureRequest() { return !waitForCapture.IsEmpty(); } /*如果存在待完成的请求，返回一个深度结果（为空）*/ static DepthResult* GetIfExistRequest() { DepthResult* result = NULL; if (!waitForCapture.IsEmpty()) { waitForCapture.Dequeue(result); } return result; } //friend void AddPostProcessingPasses(FRDGBuilder\u0026amp; GraphBuilder, const FViewInfo\u0026amp; View, const FPostProcessingInputs\u0026amp; Inputs); }; /*****************************************end******************************************************/   将下面类中静态成员初始化和添加执行获取代码代码复制到PostProcessing.cpp文件任意位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  /*类静态成员的定义*/ TQueue\u0026lt;DepthResult *, EQueueMode::Mpsc\u0026gt; DepthCapture::waitForCapture; TQueue\u0026lt; DepthResult *, EQueueMode::Mpsc\u0026gt; DepthCapture::finishedCapture; /*获取深度缓存*/ void AddDepthInspectorPass(FRDGBuilder\u0026amp; GraphBuilder, const FViewInfo\u0026amp; View, DepthResult* result) { RDG_EVENT_SCOPE(GraphBuilder, \u0026#34;DepthInspector\u0026#34;); { // 获取渲染对象 \tFSceneRenderTargets\u0026amp; renderTargets = FSceneRenderTargets::Get(GRHICommandList.GetImmediateCommandList()); // 定义拷贝参数 \tuint32 striped = 0; FIntPoint size = renderTargets.GetBufferSizeXY(); result-\u0026gt;bufferSizeX = size.X; result-\u0026gt;bufferSizeY = size.Y; result-\u0026gt;data.AddUninitialized(size.X * size.Y); // 获取视窗某一帧的深度缓存对象 \tFRHITexture2D* depthTexture = (FRHITexture2D *)renderTargets.SceneDepthZ-\u0026gt;GetRenderTargetItem().TargetableTexture.GetReference(); // 执行拷贝深度缓存操作，将GPU显存中的缓存信息拷贝到CPU内存中，返回指向这块CPU内存的首地址 \tvoid* buffer = RHILockTexture2D(depthTexture, 0, EResourceLockMode::RLM_ReadOnly, striped, true); // 将缓存结果拷贝到result，用于输出 \tmemcpy(result-\u0026gt;data.GetData(), buffer, size.X * size.Y * 8); // 必须执行解锁语句，否则被锁住的GPU缓存信息将不能释放 \tRHIUnlockTexture2D(depthTexture, 0, true); // 拷贝结果入队 \tDepthCapture::FinishedCapture(result); } } ////////////////////////////////////////   PostProcessing.cpp中该位置添加以下代码：\n代码如下：\n1 2 3 4 5 6 7 8 9 10  // Capture depth buffer，otherwise the buffer will be changed \tif (DepthCapture::HasCaptureRequest()) { DepthResult *reuslt; reuslt = DepthCapture::GetIfExistRequest(); if (reuslt) { AddDepthInspectorPass(GraphBuilder, View, reuslt); } }   3. 调用 使用以下的代码可以获取深度值，获取的结果为result：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int tickcount = 0; // Called every frame void ATestPawn::Tick(float DeltaTime) { tickcount++; if (tickcount % 2 == 0)\t// 设计几帧调用  DepthCapture::AddCapture(); // 定时发出获取深度缓存的请求  // 如果存在已完成的深度缓存请求  if (DepthCapture::HasFinishedCapture()) { DepthResult *result; // 获取已完成的深度缓存结果  result = DepthCapture::GetIfExistFinished(); if (result) { int n = result-\u0026gt;data.Num(); //this is test  GEngine-\u0026gt;AddOnScreenDebugMessage(-1, -1, FColor::Blue, FString::Printf(TEXT(\u0026#34;Get Depth Size: %d \u0026#34;), n)); } } }   ","description":"","id":12,"section":"posts","tags":["C++","UE4","Game"],"title":"UE4获取深度值","uri":"https://vhope.cf/zh/posts/ue/ue-depth/"},{"content":"探索UE4游戏线程的进入\n游戏线程 \u0026amp; 渲染线程 UE4游戏线程启动 游戏线程每一帧更新所有内容。\n这个tick是哪里打开的？\n头文件：Engine\\Source\\Runtime\\Launch\\Private\\Launch.cpp\nLauch.cpp定义了一个全局的变量FEngineLoop GEngineLoop;\n该类路径：Engine\\Source\\Runtime\\Launch\\Public\\LaunchEngineLoop.h，继承一个接口类IEngineLoop，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145  /** * Implements the main engine loop.\t*/ class FEngineLoop #if WITH_ENGINE\t: public IEngineLoop #endif{ public: /** Default constructor. */ FEngineLoop(); virtual ~FEngineLoop() { } public: /** * Pre-Initialize the main loop, and generates the commandline from standard ArgC/ArgV from main(). * * @param ArgC The number of strings in ArgV. * @param ArgV The command line parameters (ArgV[0] is expected to be the executable name). * @param AdditionalCommandLine Optional string to append to the command line (after ArgV is put together). * @return Returns the error level, 0 if successful and \u0026gt; 0 if there were errors. */ int32 PreInit(int32 ArgC, TCHAR* ArgV[], const TCHAR* AdditionalCommandline = nullptr); /** * Pre-Initialize the main loop - parse command line, sets up GIsEditor, etc. * * @param CmdLine The command line. * @return The error level; 0 if successful, \u0026gt; 0 if there were errors. */ int32 PreInit(const TCHAR* CmdLine); /** First part of PreInit. */ int32 PreInitPreStartupScreen(const TCHAR* CmdLine); /** Second part of PreInit. */ int32 PreInitPostStartupScreen(const TCHAR* CmdLine); /** Load all modules needed before Init. */ void LoadPreInitModules(); /** Load core modules. */ bool LoadCoreModules(); /** Clean up PreInit context. */ void CleanupPreInitContext(); #if WITH_ENGINE\t/** Load all core modules needed at startup time. */ bool LoadStartupCoreModules(); /** Load all modules needed at startup time. */ bool LoadStartupModules(); /** * Initialize the main loop (the rest of the initialization). * * @return The error level; 0 if successful, \u0026gt; 0 if there were errors. */ virtual int32 Init() override; /** Initialize the timing options from the command line. */ void InitTime(); /** Performs shut down. */ void Exit(); /** Whether the engine should operate in an idle mode that uses no CPU or GPU time. */ bool ShouldUseIdleMode() const; // Advances the main loop.推进主循环 \tvirtual void Tick() override; /** Removes references to any objects pending cleanup by deleting them. */ virtual void ClearPendingCleanupObjects() override; #endif // WITH_ENGINE  /** RHI post-init initialization */ static void PostInitRHI(); /** Pre-init HMD device (if necessary). */ static void PreInitHMDDevice(); public: /** Initializes the application. */ static bool AppInit(); /** * Prepares the application for shutdown. * * This function is called from within guarded exit code, only during non-error exits. */ static void AppPreExit(); /** * Shuts down the application. * * This function called outside guarded exit code, during all exits (including error exits). */ static void AppExit(); private: /** Utility function that processes Slate operations. */ void ProcessLocalPlayerSlateOperations() const; protected: /** Holds a dynamically expanding array of frame times in milliseconds (if FApp::IsBenchmarking() is set). */ TArray\u0026lt;float\u0026gt; FrameTimes; /** Holds the total time spent ticking engine. */ double TotalTickTime; /** Holds the maximum number of seconds engine should be ticked. */ double MaxTickTime; /** Holds the maximum number of frames to render in benchmarking mode. */ uint64 MaxFrameCounter; /** Holds the number of cycles in the last frame. */ uint32 LastFrameCycles; #if WITH_ENGINE /** Holds the objects which need to be cleaned up when the rendering thread finishes the previous frame. */ FPendingCleanupObjects* PendingCleanupObjects; #endif //WITH_ENGINE  private: #if WITH_ENGINE /** Holds the engine service. */ FEngineService* EngineService; /** Holds the application session service. */ TSharedPtr\u0026lt;ISessionService\u0026gt; SessionService; #endif // WITH_ENGINE \tFPreInitContext PreInitContext; };    该文件只需#include \u0026quot;CoreMinimal.h\u0026quot;，最多加上#include \u0026quot;UnrealEngine.h\u0026quot;\n 接口类，位于路径Engine\\Source\\Runtime\\Engine\\Public\\UnrealEngine.h：\n1 2 3 4 5 6 7 8 9  /** Public interface to FEngineLoop so we can call it from editor or editor code */ class IEngineLoop { public: virtual int32 Init() = 0; virtual void Tick() = 0; /** Removes references to any objects pending cleanup by deleting them. */ virtual void ClearPendingCleanupObjects() = 0; };   开启Tick函数之前需要初始化，初始化函数在Launch.cpp这个文件中：\n1 2 3 4 5 6  /* Inits the engine loop */ int32 EngineInit() { int32 ErrorLevel = GEngineLoop.Init(); return( ErrorLevel ); }   GEngineLoop.Init()函数：\n其中会判断是进入那种引擎模式，分为Game模式与Editor模式。\n结束引擎的函数为：\n1 2 3 4 5 6 7 8 9 10  /** * Shuts down the engine */ void EngineExit( void ) { // Make sure this is set \tRequestEngineExit(TEXT(\u0026#34;EngineExit() was called\u0026#34;)); GEngineLoop.Exit(); }   也在Launch.cpp\nLaunch.cpp中的函数多次使用GEngine这个外部变量，这个变量在上面的初始化函数会自定设置为相应的引擎，即Game引擎或者Editor引擎：\n 所在文件Engine.h\n 在FEngineLoop::Tick()函数会调用GEngine的Tick函数：\n也就是本文开始的那个Tick函数。\n","description":"","id":13,"section":"posts","tags":["C++","UE4","Game"],"title":"UE游戏、渲染线程","uri":"https://vhope.cf/zh/posts/ue/ue-game-render/"},{"content":"==通常的游戏引擎中游戏线程和渲染线程都是独立的，相互之间会存在一个同步的机制==\nKeyWord: UMG 虚幻示意图形界面设计器（Unreal Motion Graphics UI Designer）(UMG) 是一个可视化的UI创作工具，可以用来创建UI元素，如游戏中的HUD、菜单或您希望呈现给用户的其他界面相关图形。UMG的核心是控件，这些控件是一系列预先制作的函数，可用于构建界面（如按钮、复选框、滑块、进度条等）。这些控件在专门的控件蓝图中编辑，该蓝图使用两个选项卡进行构造：设计器（Designer）选项卡允许界面和基本函数的可视化布局，而图表（Graph）选项卡提供所使用控件背后的功能。\nSlate Slate 是完全自定义、与平台无关的用户界面框架，旨在让工具和应用程序（比如虚幻编辑器）的用户界面或游戏中用户界面的构建过程变得有趣、高效。它将声明性语法与轻松设计、布局和风格组件的功能相结合，允许在UI上轻松实现创建和迭代。\nSlate UI解决方案使得为工具和应用程序组合图形用户界面和快速迭代这些界面变得极其简单。\nRHICmdList 这是一组独特的宏，用于将操作发送到渲染线程进行操作。\n主要是对Texture之类的数据在GPU以及GPU相关的指令进行执行。\n渲染线程的通信 参考链接：\n 《Exploring in UE4》多线程机制详解[原理分析] 纹理和采样器 虚幻4 Task Graph System 介绍  预览 UE4引擎运行时的部分线程，在UE中，许多模块都使用多线程，如渲染模块、物理模块、网络通信、音频系统、IO：\n虽然UE4遵循C++11的标准，但是他并没有使用std::thread，而是自己实现了一套多线程机制（应该是从UE3时代就有了，未考证），用法上很像Java。\n使用线程 在UE4里面，使用线程有三个方法：\n 我们可以自己继承FRunnable接口创建单个线程 直接创建AsyncTask来调用线程池里面空闲的线程 通过TaskGraph系统来异步完成一些自定义任务。  FRunnable 线索：\n   模块 Core     .h /Engine/Source/Runtime/Core/Public/HAL/Runnable.h   include #include \u0026ldquo;HAL/Runnable.h\u0026rdquo;     UE4中最基础的模型就是FRunnable和FRunnableThread，FRunnable抽象出一个可以执行在线程上的对象，而FRunnableThread是平台无关的线程对象的抽象。后面的篇幅会详细讨论这些基础设施。\n 创建一个继承于FRunnable的类，FRunnable声明如下：\n FRunnable就是一个很简单的类，里面只有5，6个函数接口，为了与真正的线程区分，我这里称FRunnable为“线程执行体”；所谓真正的线程其实就是FRunnableThread，不同平台的线程都继承自他，如FRunnableThreadWin，里面会调用Windows平台的创建线程的API接口。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  class CORE_API FRunnable { public: /** * Initializes the runnable object. * * This method is called in the context of the thread object that aggregates this, not the * thread that passes this runnable to a new thread. * * @return True if initialization was successful, false otherwise * @see Run, Stop, Exit */ virtual bool Init() { return true; } /** * Runs the runnable object. * * This is where all per object thread work is done. This is only called if the initialization was successful. * * @return The exit code of the runnable object * @see Init, Stop, Exit */ virtual uint32 Run() = 0; /** * Stops the runnable object. * * This is called if a thread is requested to terminate early. * @see Init, Run, Exit */ virtual void Stop() { } /** * Exits the runnable object. * * Called in the context of the aggregating thread to perform any cleanup. * @see Init, Run, Stop */ virtual void Exit() { } /** * Gets single thread interface pointer used for ticking this runnable when multi-threading is disabled. * If the interface is not implemented, this runnable will not be ticked when FPlatformProcess::SupportsMultithreading() is false. * * @return Pointer to the single thread interface or nullptr if not implemented. */ virtual class FSingleThreadRunnable* GetSingleThreadInterface( ) { return nullptr; } /** Virtual destructor */ virtual ~FRunnable() { } };   FRunnable与线程之间的关系类图：\nUE4中的多线程模型用一句话概括为: A FRunnable runs on a FRunnableThread.\n FQueuedThreadPool线程池    模块 Core      /Engine/Source/Runtime/Core/Public/Misc/QueuedThreadPool.h    #include \u0026ldquo;Misc/QueuedThreadPool.h\u0026rdquo;    FQueuedThreadPool。和一般的线程池实现类似，线程池里面维护了多个线程FQueuedThread与多个任务队列IQueuedWork，线程是按照队列的方式来排列的。\n在线程池里面所有的线程都是FQueuedThread类型，不过更确切的说FQueuedThread是继承自FRunnable的线程执行体，每个FQueuedThread里面包含一个FRunnableThread作为内部成员。\n相比一般的线程，FQueuedThread里面多了一个成员FEvent* DoWorkEvent，也就是说FQueuedThread里面是有一个事件触发机制的。那么这个事件机制的作用是什么？一般情况下来说，就是在没有任务的时候挂起这个线程，在添加并分配给该线程任务的时候激活他，不过你可以灵活运用它，在你需要的时候去动态控制线程任务的执行与暂停。\n AsyncTask系统 AsyncTask系统是一套基于线程池的异步任务处理系统。\nFAsyncTask有几个特点：\n FAsyncTask是一个模板类，真正的AsyncTask需要你自己写。通过DoWork提供你要执行的具体任务，然后把你的类作为模板参数传过去 使用FAsyncTask就默认你要使用UE提供的线程池FQueuedThreadPool，前面代码里说明了在引擎PreInit的时候会初始化线程池并返回一个指针GThreadPool。在执行FAsyncTask任务时，如果你在执行StartBackgroundTask的时候会默认使用GThreadPool线程池，当然你也可以在参数里面指定自己创建的线程池 创建FAsyncTask并不一定要使用新的线程，你可以调用函数StartSynchronousTask直接在当前线程上执行任务 FAsyncTask本身包含一个DoneEvent，任务执行完成的时候会激活该事件。当你想等待一个任务完成时再做其他操作，就可以调用EnsureCompletion函数，他可以从队列里面取出来还没被执行的任务放到当前线程来做，也可以挂起当前线程等待DoneEvent激活后再往下执行  Task Graph 系统 Task Graph 系统是UE4一套抽象的异步任务处理系统，可以创建多个多线程任务，指定各个任务之间的依赖关系，按照该关系来依次处理任务。\nTick函数\n平时调试的时候，我们随便找个Tick断点一下都能看到类似下图这样的函数堆栈。如果你前面的章节都看懂的话，这个堆栈也能大概理解。World在执行Tick的时候，触发了FNamedTaskThread线程去执行任务（FTickFunctionTask），任务FTickFunctionTask具体的工作内容就是执行ACtorComponent的Tick函数。其实，这个堆栈也说明了所有Actor与Component的Tick都是通过TaskGraph系统来执行的（在TG_PrePhysics阶段）。\nCconclusion ==对于消耗大的，复杂的任务不建议使用TaskGraph，一是因为TaskGraph如果被分配到游戏线程，就会阻塞整个游戏线程的执行，二是即使你不在那几个有名字的线程上执行，也可能会影响到游戏的其他逻辑。==\n全家福：\n线程同步 UE4对操作系统提供的线程同步相关接口进行了一定的封装。\nAtomics \u0026hellip;\u0026hellip;\n","description":"","id":14,"section":"posts","tags":["UE","C++"],"title":"UE4多线程","uri":"https://vhope.cf/zh/posts/ue/ue-thread-commuicate/"},{"content":"UE4问题汇总   UE4光照构建失败⚠\nhttps://blog.csdn.net/earlyAutumnOfRain/article/details/80863561\n  UE4导入灰度图\nhttps://www.cnblogs.com/gucheng/p/10116857.html\n  详解UE4静态库与动态库的导入与使用\nhttps://gameinstitute.qq.com/community/detail/121551\n  Ue4_序列化浅析_\nhttps://blog.csdn.net/mohuak/article/details/83027211\n  UE快捷键\nhttps://www.unrealengine.com/zh-CN/tech-blog/designer-s-guide-to-unreal-engine-keyboard-shortcuts\n  UE4资源加载（一）从StaticLoadObject开始\nhttp://suo.im/6v7hUc\n  Unreal Cookbook：创建对象的的几种姿势（C++）\nhttps://blog.csdn.net/Neil3D/article/details/51488401\n  Aery的UE4 C++游戏开发之旅（1）基础对象模型\nhttps://www.cnblogs.com/KillerAery/p/11986316.html\n  目录结构\nhttps://docs.unrealengine.com/zh-CN/Engine/Basics/DirectoryStructure/index.html\n  引擎世界\nhttps://www.engineworld.cn/\n  《InsideUE4》GamePlay架构（一）Actor和Component\nhttps://zhuanlan.zhihu.com/p/22833151\n  实时渲染中的坐标系变换（5）：投影变换-3\nhttps://zhuanlan.zhihu.com/p/115395322\n  UE4 屏幕坐标转换到世界坐标\nhttps://blog.csdn.net/weixin_36412907/article/details/77306212\n  UE4必读文章列表_个人整理\nhttps://zhuanlan.zhihu.com/p/126611976\n  OpenGL 学习系列\u0026mdash;投影矩阵\nhttps://juejin.im/post/5b0ec5fef265da092a2b79b1\n  Alpha Test\nhttp://geekfaner.com/shineengine/blog13_OpenGLESv2_12.html\n  Rendoc使用\nhttps://www.cnblogs.com/kekec/p/11760288.html\n  [多视图几何] - 逆透视变换\nhttps://blog.csdn.net/chishuideyu/article/details/79136903\n  UE4必读文章列表_个人整理\nhttps://zhuanlan.zhihu.com/p/126611976\n  UE4中的Tone Mapping\nhttps://www.dingshukai.com/blog/ue4-tone-mapping.html\n  UE4 渲染流程\nhttps://blog.csdn.net/or_7r_ccl/article/details/81102771\n  [UE4]尝试使用自定义深度 fq\nhttp://monsho.blog63.fc2.com/blog-entry-138.html#comment469\n  [UE4]扩展GBuffer\nhttp://monsho.blog63.fc2.com/blog-entry-191.html\n  https://ue4study-osaka.connpass.com/event/120568/\n  UE4文件系统  模块是UE4的构建块。引擎是以大量模块的集合形式实现的，游戏提供自己的模块来扩充自己。每个模块都封装了一组功能，并且可以提供公共接口和编译环境（包括宏、路径等）供其他模块使用。\n .build.cs文件的典型结构如下。\n1 2 3 4 5 6 7 8 9  using UnrealBuildTool; using System.Collections.Generic; public class MyModule : ModuleRules { public MyModule(ReadOnlyTargetRules Target) : base(Target) { // Settings go here  } }     \\Engine\\Source\\ThirdParty目录\n存放第三方的库\n  F:\\UnrealEngine4.14\\Engine\\Plugins目录(或者F:\\UE4Project\\项目名称\\Plugins目录)\n保存插件的目录\n  UE创世，万物皆UObject，接着有Actor。\nComponent和Actor  UE4让Actor们轻装上阵，只提供一些通用的基本生存能力，而把众多的“技能”抽象成了一个个“Component”并提供组装的接口，让Actor随用随组装，把自己武装成一个个专业能手。\n 相关组件 RootComponent 定义这个演员在世界上的变换(位置、旋转、缩放)的组件，所有其他组件必须以某种方式附加到这个组件\n弹簧臂组件 弹簧臂组件用于自动控制摄像机受阻时的应对方式。\nUE文件存储的方式 UE 中使用统一的格式存储资源 (uasset， umap)，每个 uasset 对应一个包 (package)，存储一个 UPackage 对象时，会将该包下的所有对象都存到 uasset 中。\n 一个资源在文件中对应uasset，在内存中对应为UPackage。\n uasset文件格式  File Summary 文件头信息 Name Table 包中对象的名字表 Import Table 存放被该包中对象引用的其它包中的对象信息(路径名和类型) Export Table 该包中的对象信息(路径名和类型) Export Objects 所有Export Table中对象的实际数据。  FlinkerLoad FLinkerLoad是作为uasset和内存UPackage的中间桥梁。在加载内容生成UPackage的时候，UPackage会根据名字找到uasset文件，由FLinkerLoad来负责加载。\nFLinkerLoad主要内容如下：\n FArchive* Loader;\t//Loader负责读取具体文件 TArray ImportMap; //将uasset的ImportTable加载到ImportMap中，FObjectImport是需要依赖（导入）的UObject TArray ExportMap; //FObjectExport是这个UPackage所拥有的UObject（这些UObject都能提供给其他UPackage作为Import）  StaticLoadObject加载 步骤：\n 根据文件名字创建一个空的包（没有任何文件相关的数据） 建立一个LinkerLoad去加载对应的uasset文件 序列化。 优先加载ImportMap 加载ExportMap（本身的数据）  1、建立一个UPackage\n2、序列化uasset\n3、加载ImportMap\nPawn默认组件 UE相机 http://www.geodesic.games/2019/03/27/projection-matrices-in-unreal-engine/\n Firstly, Unreal inverses the perspective divide, applying 1 instead of -1 for the “W” value.（虚幻处理投影与 Unity 中使用的标准 OpenGL 透视矩阵不同。） Secondly, Unreal applies a matrix transposition to all their perspective matrices.（其次，Unreal 对所有的透视矩阵进行了矩阵移位。  缺省情况下，Unreal 提供了各种方便的透视矩阵构造函数。 有两种变体，一种是普通透视矩阵，另一种是逆向透视矩阵。  右手坐标系： https://zhuanlan.zhihu.com/p/114729671\n透视投影：\n归一化齐次坐标以后的结果是：\n camera space 3D空间中，相同的x，z越大，投影变换以后的x分量越靠近0。\u0026ldquo;近大远小\u0026quot;的透视效果，就是这么算出来的。\n  Unity的投影矩阵，是把视锥内的所有3D坐标，转换到 [-1,1] 范围之内。最后转化为Screen Space，范围为[0,1]\n 深度值是到近平面的距离：\n正交投影：\n 透视投影变换，有\u0026quot;近大远小\u0026quot;的透视效果。3D空间中的两条平行线，在投影变换以后会相交于某个\u0026quot;灭点\u0026rdquo;。\n正交投影变换，没有\u0026quot;近大远小\u0026quot;的透视效果。3D空间中的两条平行线，在投影变换以后，仍旧是平行的。\n Unreal 正交矩阵：\n UE4里的透视投影矩阵的计算方式，参见引擎源代码的OrthoMatrix.h文件。\n 代码1：\n1  UGameplayStatics::DeprojectScreenToWorld(UGameplayStatics::GetPlayerController(GetWorld(), 0), forwardCursorPos, forwardWorldPos, forwardMoveDirection);   代码2：\n1 2 3  FVector forwardMoveDirection; GetWorld()-\u0026gt;GetFirstPlayerController()-\u0026gt;GetMousePosition(forwardCursorPos.X, forwardCursorPos.Y); UGameplayStatics::DeprojectScreenToWorld(UGameplayStatics::GetPlayerController(GetWorld(), 0), forwardCursorPos, forwardWorldPos, forwardMoveDirection);    APlayerController 玩家控制器被人类玩家用来控制棋子。地址 ULocalPlayer 当前客户端上的每个玩家都有一个LocalPlayer。地址 FViewportClient 视窗客户端的抽象接口。地址 ViewportClient 在玩家中包含此玩家视图的主视窗.。 地址 ULocalPlayer::GetProjectionData 用于导出投影所需的各种数据位的辅助函数。 地址  bianxngjing:\nhttps://v.qq.com/x/page/t0770a2b6f6.html\nAPI UGameplayStatics::DeprojectScreenToWorld  Unity 与 NGUI 坐标转换原理   将给定的2D屏幕空间坐标转换为3D世界空间点和方向。\nAPI地址： https://docs.unrealengine.com/en-US/API/Runtime/Engine/Kismet/UGameplayStatics/DeprojectScreenToWorld/index.html\n语法：\n1 2 3 4 5 6 7  static bool DeprojectScreenToWorld ( APlayerController const * Player,\t// 玩家视角  const FVector2D \u0026amp; ScreenPosition,\t// 2D点  FVector \u0026amp; WorldPosition,\t// 世界空间三维坐标 输出  FVector \u0026amp; WorldDirection\t// 在给定的2d点上远离相机的世界空间方向矢量。\t输出 )   源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  bool UGameplayStatics::DeprojectScreenToWorld(APlayerController const* Player, const FVector2D\u0026amp; ScreenPosition, FVector\u0026amp; WorldPosition, FVector\u0026amp; WorldDirection) { // 获取LocalPlayer \tULocalPlayer* const LP = Player ? Player-\u0026gt;GetLocalPlayer() : nullptr; if (LP \u0026amp;\u0026amp; LP-\u0026gt;ViewportClient) {//ViewpoetClient 包含此玩家视图的主视窗。 \t// get the projection data \tFSceneViewProjectionData ProjectionData; //立体渲染通过。FULL表示此过程中未启用立体渲染，eSSP_FULL \tif (LP-\u0026gt;GetProjectionData(LP-\u0026gt;ViewportClient-\u0026gt;Viewport, eSSP_FULL, /*out*/ ProjectionData)) {// 获取投影数据 \tFMatrix const InvViewProjMatrix = ProjectionData.ComputeViewProjectionMatrix().InverseFast(); FSceneView::DeprojectScreenToWorld(ScreenPosition, ProjectionData.GetConstrainedViewRect(), InvViewProjMatrix, /*out*/ WorldPosition, /*out*/ WorldDirection); return true; } } // something went wrong, zero things and return false，错误不管 \tWorldPosition = FVector::ZeroVector; WorldDirection = FVector::ZeroVector; return false; }   逆透视变换 投影矩阵：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // Projection data for a FSceneView struct FSceneViewProjectionData { FVector ViewOrigin;\t//源视图向量 \t/** Rotation matrix transforming from world space to view space. */ FMatrix ViewRotationMatrix;\t// 从世界空间到视图空间的旋转矩阵转换。 \t/** UE4 projection matrix projects such that clip space Z=1 is the near plane, and Z=0 is the infinite far plane. */ FMatrix ProjectionMatrix;\t// UE4投影矩阵投影使得剪辑空间Z=1是近平面，Z=0是无限远平面。 protected: //The unconstrained (no aspect ratio bars applied) view rectangle (also unscaled) \tFIntRect ViewRect;\t// 无约束(未应用宽高比条)视图矩形(也未缩放) \t// The constrained view rectangle (identical to UnconstrainedUnscaledViewRect if aspect ratio is not constrained) \tFIntRect ConstrainedViewRect;\t// 受约束的视图矩形(如果长宽比不受约束，则与UnconstrainedUnscaledViewRect相同) public: void SetViewRectangle(const FIntRect\u0026amp; InViewRect) { ViewRect = InViewRect; ConstrainedViewRect = InViewRect; } void SetConstrainedViewRectangle(const FIntRect\u0026amp; InViewRect) { ConstrainedViewRect = InViewRect; } // 上面两个函数设置Rect窗口  bool IsValidViewRectangle() const {//判断窗口是否有效 \treturn (ConstrainedViewRect.Min.X \u0026gt;= 0) \u0026amp;\u0026amp; (ConstrainedViewRect.Min.Y \u0026gt;= 0) \u0026amp;\u0026amp; (ConstrainedViewRect.Width() \u0026gt; 0) \u0026amp;\u0026amp; (ConstrainedViewRect.Height() \u0026gt; 0); } bool IsPerspectiveProjection() const {// 判断是不是透视投影矩阵 \treturn ProjectionMatrix.M[3][3] \u0026lt; 1.0f; } const FIntRect\u0026amp; GetViewRect() const { return ViewRect; } const FIntRect\u0026amp; GetConstrainedViewRect() const { return ConstrainedViewRect; } FMatrix ComputeViewProjectionMatrix() const {// 计算视图投影矩阵 \treturn FTranslationMatrix(-ViewOrigin) * ViewRotationMatrix * ProjectionMatrix; } };   上面平移矩阵：\n1 2 3 4 5 6 7 8  FORCEINLINE FTranslationMatrix::FTranslationMatrix(const FVector\u0026amp; Delta)\t//基于给定向量的构造函数转换矩阵，//转置矩阵 \t: FMatrix( FPlane(1.0f,\t0.0f,\t0.0f,\t0.0f), FPlane(0.0f,\t1.0f,\t0.0f,\t0.0f), FPlane(0.0f,\t0.0f,\t1.0f,\t0.0f), FPlane(Delta.X,\tDelta.Y,Delta.Z,1.0f) ) { }   难点一：GetProjectionData函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  bool ULocalPlayer::GetProjectionData(FViewport* Viewport, EStereoscopicPass StereoPass, FSceneViewProjectionData\u0026amp; ProjectionData) const { // If the actor  //Size为分配给此玩家的主视口子区域的大小。0-1  // Viewport-\u0026gt;GetSizeXY()获取视端的X与Y \tif ((Viewport == NULL) || (PlayerController == NULL) || (Viewport-\u0026gt;GetSizeXY().X == 0) || (Viewport-\u0026gt;GetSizeXY().Y == 0) || (Size.X == 0) || (Size.Y == 0)) { return false; } // 将浮点数转换为截断值接近零的整数。即向下取整  // Origin为分配给该玩家的主视口子区域左上角的坐标。0-1 \tint32 X = FMath::TruncToInt(Origin.X * Viewport-\u0026gt;GetSizeXY().X); int32 Y = FMath::TruncToInt(Origin.Y * Viewport-\u0026gt;GetSizeXY().Y); // 加上视端初始的坐标值 \tX += Viewport-\u0026gt;GetInitialPositionXY().X; Y += Viewport-\u0026gt;GetInitialPositionXY().Y; //新的窗口大小 \tuint32 SizeX = FMath::TruncToInt(Size.X * Viewport-\u0026gt;GetSizeXY().X); uint32 SizeY = FMath::TruncToInt(Size.Y * Viewport-\u0026gt;GetSizeXY().Y); //X=0,Y = 0 #if !(UE_BUILD_SHIPPING || UE_BUILD_TEST) // We expect some size to avoid problems with the view rect manipulation \t// 我们希望有一定的大小来避免view rect操作的问题 \tif(SizeX \u0026gt; 50 \u0026amp;\u0026amp; SizeY \u0026gt; 50) { int32 Value = CVarViewportTest.GetValueOnGameThread();\t//根据value的值分类各种视端  if(Value) { int InsetX = SizeX / 4; int InsetY = SizeY / 4; // this allows to test various typical view port situations (todo: split screen)  // 这允许测试各种典型的视图端口情况(todo:分割屏幕) \tswitch(Value) { case 1: X += InsetX; Y += InsetY; SizeX -= InsetX * 2; SizeY -= InsetY * 2;break; case 2: Y += InsetY; SizeY -= InsetY * 2; break; case 3: X += InsetX; SizeX -= InsetX * 2; break; case 4: SizeX /= 2; SizeY /= 2; break; case 5: SizeX /= 2; SizeY /= 2; X += SizeX;\tbreak; case 6: SizeX /= 2; SizeY /= 2; Y += SizeY; break; case 7: SizeX /= 2; SizeY /= 2; X += SizeX; Y += SizeY; break; } } } #endif\t// FIntRect为二维空间中整数矩形的结构。新的视端矩阵 \tFIntRect UnconstrainedRectangle = FIntRect(X, Y, X+SizeX, Y+SizeY);//InMin(X,Y),InMax(X+SizeX,Y+SizeY) \t// 设置投影数据的窗口 \tProjectionData.SetViewRectangle(UnconstrainedRectangle); // Get the viewpoint.  // 获得视点 \tFMinimalViewInfo ViewInfo; //结构  /** enum EStereoscopicPass { eSSP_FULL, eSSP_LEFT_EYE, eSSP_RIGHT_EYE, eSSP_LEFT_EYE_SIDE, eSSP_RIGHT_EYE_SIDE, } **/ GetViewPoint(/*out*/ ViewInfo, StereoPass);\t//检索该玩家的视点。  // If stereo rendering is enabled, update the size and offset appropriately for this pass  // 如果启用了立体渲染，请为此过程适当更新大小和偏移 \tconst bool bNeedStereo = IStereoRendering::IsStereoEyePass(StereoPass) \u0026amp;\u0026amp; GEngine-\u0026gt;IsStereoscopic3D(); const bool bIsHeadTrackingAllowed = GEngine-\u0026gt;XRSystem.IsValid() \u0026amp;\u0026amp; GEngine-\u0026gt;XRSystem-\u0026gt;IsHeadTrackingAllowed(); if (bNeedStereo) { GEngine-\u0026gt;StereoRenderingDevice-\u0026gt;AdjustViewRect(StereoPass, X, Y, SizeX, SizeY); } // scale distances for cull distance purposes by the ratio of our current FOV to the default FOV  // 根据我们当前的FOV与默认FOV的比率，为选择距离的目的缩放距离 \tPlayerController-\u0026gt;LocalPlayerCachedLODDistanceFactor = ViewInfo.FOV / FMath::Max\u0026lt;float\u0026gt;(0.01f, (PlayerController-\u0026gt;PlayerCameraManager != NULL) ? PlayerController-\u0026gt;PlayerCameraManager-\u0026gt;DefaultFOV : 90.f); FVector StereoViewLocation = ViewInfo.Location; // 加入立体渲染或者  if (bNeedStereo || bIsHeadTrackingAllowed) {// 假如启用了立体渲染和头部追踪 \tauto XRCamera = GEngine-\u0026gt;XRSystem.IsValid() ? GEngine-\u0026gt;XRSystem-\u0026gt;GetXRCamera() : nullptr;\t//虚拟现实相机 \tif (XRCamera.IsValid()) { AActor* ViewTarget = PlayerController-\u0026gt;GetViewTarget(); const bool bHasActiveCamera = ViewTarget \u0026amp;\u0026amp; ViewTarget-\u0026gt;HasActiveCameraComponent(); XRCamera-\u0026gt;UseImplicitHMDPosition(bHasActiveCamera); } if (GEngine-\u0026gt;StereoRenderingDevice.IsValid()) { GEngine-\u0026gt;StereoRenderingDevice-\u0026gt;CalculateStereoViewOffset(StereoPass, ViewInfo.Rotation, GetWorld()-\u0026gt;GetWorldSettings()-\u0026gt;WorldToMeters, StereoViewLocation); } } // Create the view matrix  // 创建视图矩阵  // FPlane 三维平面的结构。(X,Y,Z,W)  // FMatrix 浮点值的4x4矩阵。 \tProjectionData.ViewOrigin = StereoViewLocation; ProjectionData.ViewRotationMatrix = FInverseRotationMatrix(ViewInfo.Rotation) * FMatrix( FPlane(0,\t0,\t1,\t0), FPlane(1,\t0,\t0,\t0), FPlane(0,\t1,\t0,\t0), FPlane(0,\t0,\t0,\t1)); // @todo viewext this use case needs to be revisited  // 重新考虑viewext \tif (!bNeedStereo)\t//假如没有立体渲染 \t{ // Create the projection matrix (and possibly constrain the view rectangle)  // 创建投影矩阵(并可能约束视图矩形)  // ViewInfo视点 \tFMinimalViewInfo::CalculateProjectionMatrixGivenView(ViewInfo, AspectRatioAxisConstraint, Viewport, /*inout*/ ProjectionData);//计算给定视图投影矩阵 \t// 视图扩展对象可以在没有运动控制器组件的情况下保留在渲染线程上，大概是设置相关试图拓展的投影矩阵 \tfor (auto\u0026amp; ViewExt : GEngine-\u0026gt;ViewExtensions-\u0026gt;GatherActiveExtensions()) { ViewExt-\u0026gt;SetupViewProjectionMatrix(ProjectionData); }; } else {\t// 有三维渲染 \t// Let the stereoscopic rendering device handle creating its own projection matrix, as needed  // 让立体渲染设备根据需要处理创建自己的投影矩阵，调用一系列函数GetProjectMatrix \tProjectionData.ProjectionMatrix = GEngine-\u0026gt;StereoRenderingDevice-\u0026gt;GetStereoProjectionMatrix(StereoPass); // calculate the out rect \tProjectionData.SetViewRectangle(FIntRect(X, Y, X + SizeX, Y + SizeY)); } return true; }   难点：计算给定视图投影矩阵\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  void FMinimalViewInfo::CalculateProjectionMatrixGivenView(const FMinimalViewInfo\u0026amp; ViewInfo, TEnumAsByte\u0026lt;enum EAspectRatioAxisConstraint\u0026gt; AspectRatioAxisConstraint, FViewport* Viewport, FSceneViewProjectionData\u0026amp; InOutProjectionData) { // Create the projection matrix (and possibly constrain the view rectangle)  // 创建投影矩阵(并可能约束视图矩形) \tif (ViewInfo.bConstrainAspectRatio) { // Enforce a particular aspect ratio for the render of the scene. \t// Results in black bars at top/bottom etc. \tInOutProjectionData.SetConstrainedViewRectangle(Viewport-\u0026gt;CalculateViewExtents(ViewInfo.AspectRatio, InOutProjectionData.GetViewRect())); InOutProjectionData.ProjectionMatrix = ViewInfo.CalculateProjectionMatrix(); } else { // Avoid divide by zero in the projection matrix calculation by clamping FOV \tfloat MatrixFOV = FMath::Max(0.001f, ViewInfo.FOV) * (float)PI / 360.0f; float XAxisMultiplier; float YAxisMultiplier; const FIntRect\u0026amp; ViewRect = InOutProjectionData.GetViewRect(); const int32 SizeX = ViewRect.Width(); const int32 SizeY = ViewRect.Height(); // if x is bigger, and we\u0026#39;re respecting x or major axis, AND mobile isn\u0026#39;t forcing us to be Y axis aligned \tif (((SizeX \u0026gt; SizeY) \u0026amp;\u0026amp; (AspectRatioAxisConstraint == AspectRatio_MajorAxisFOV)) || (AspectRatioAxisConstraint == AspectRatio_MaintainXFOV) || (ViewInfo.ProjectionMode == ECameraProjectionMode::Orthographic)) { //if the viewport is wider than it is tall \tXAxisMultiplier = 1.0f; YAxisMultiplier = SizeX / (float)SizeY; } else { //if the viewport is taller than it is wide \tXAxisMultiplier = SizeY / (float)SizeX; YAxisMultiplier = 1.0f; } if (ViewInfo.ProjectionMode == ECameraProjectionMode::Orthographic) {\t//判断投影模式 \tconst float OrthoWidth = ViewInfo.OrthoWidth / 2.0f * XAxisMultiplier; const float OrthoHeight = (ViewInfo.OrthoWidth / 2.0f) / YAxisMultiplier; const float NearPlane = ViewInfo.OrthoNearClipPlane; const float FarPlane = ViewInfo.OrthoFarClipPlane; const float ZScale = 1.0f / (FarPlane - NearPlane); const float ZOffset = -NearPlane; InOutProjectionData.ProjectionMatrix = FReversedZOrthoMatrix( // 计算反向Z正交矩阵 \tOrthoWidth, OrthoHeight, ZScale, ZOffset );\t} else { InOutProjectionData.ProjectionMatrix = FReversedZPerspectiveMatrix(\t// 反转Z透视矩阵 \tMatrixFOV, MatrixFOV, XAxisMultiplier, YAxisMultiplier, GNearClippingPlane, GNearClippingPlane ); } } if (!ViewInfo.OffCenterProjectionOffset.IsZero()) { const float Left = -1.0f + ViewInfo.OffCenterProjectionOffset.X; const float Right = Left + 2.0f; const float Bottom = -1.0f + ViewInfo.OffCenterProjectionOffset.Y; const float Top = Bottom + 2.0f; InOutProjectionData.ProjectionMatrix.M[2][0] = (Left + Right) / (Left - Right); InOutProjectionData.ProjectionMatrix.M[2][1] = (Bottom + Top) / (Bottom - Top); } }   反向Z正交：\n1 2 3 4 5 6 7 8  FORCEINLINE FReversedZOrthoMatrix::FReversedZOrthoMatrix(float Width,float Height,float ZScale,float ZOffset) : FMatrix( FPlane((Width != 0.0f) ? (1.0f / Width) : 1.0f, 0.0f, 0.0f, 0.0f), FPlane(0.0f, (Height != 0.0f) ? (1.0f / Height) : 1.f, 0.0f, 0.0f), FPlane(0.0f, 0.0f, -ZScale, 0.0f), FPlane(0.0f, 0.0f, 1.0f - ZOffset * ZScale, 1.0f) ) { }   难点2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  void FSceneView::DeprojectScreenToWorld(const FVector2D\u0026amp; ScreenPos, const FIntRect\u0026amp; ViewRect, const FMatrix\u0026amp; InvViewProjMatrix, FVector\u0026amp; out_WorldOrigin, FVector\u0026amp; out_WorldDirection) { float PixelX = FMath::TruncToFloat(ScreenPos.X); float PixelY = FMath::TruncToFloat(ScreenPos.Y); // Get the eye position and direction of the mouse cursor in two stages (inverse transform projection, then inverse transform view).  // //分两个阶段获取鼠标光标的眼睛位置和方向(逆变换投影，然后逆变换视图)。  // This avoids the numerical instability that occurs when a view matrix with large translation is composed with a projection matrix \t// //这避免了当具有大平移的视图矩阵由投影矩阵组成时出现的数值不稳定性  // Get the pixel coordinates into 0..1 normalized coordinates within the constrained view rectangle  // 将像素坐标转换为0..1约束视图矩形内的标准化坐标 \tconst float NormalizedX = (PixelX - ViewRect.Min.X) / ((float)ViewRect.Width()); const float NormalizedY = (PixelY - ViewRect.Min.Y) / ((float)ViewRect.Height()); // Get the pixel coordinates into -1..1 projection space  // 将像素坐标转换为-1..1投影空间 \tconst float ScreenSpaceX = (NormalizedX - 0.5f) * 2.0f; const float ScreenSpaceY = ((1.0f - NormalizedY) - 0.5f) * 2.0f; // The start of the ray trace is defined to be at mousex,mousey,1 in projection space (z=1 is near, z=0 is far - this gives us better precision)  // //光线跟踪的开始被定义为在投影空间中mousex，mousey，1处(z = 1是近的，z=0是远的-这给了我们更好的精度) \t// To get the direction of the ray trace we need to use any z between the near and the far plane, so let\u0026#39;s use (mousex, mousey, 0.5)  // //为了得到光线轨迹的方向，我们需要使用近平面和远平面之间的任何z，所以让我们使用(mousex，mousey，0.5) \tconst FVector4 RayStartProjectionSpace = FVector4(ScreenSpaceX, ScreenSpaceY, 1.0f, 1.0f); const FVector4 RayEndProjectionSpace = FVector4(ScreenSpaceX, ScreenSpaceY, 0.5f, 1.0f); // Projection (changing the W coordinate) is not handled by the FMatrix transforms that work with vectors, so multiplications  // //投影(改变w坐标)不是由处理向量的矩阵变换来处理的，所以乘法  // by the projection matrix should use homogeneous coordinates (i.e. FPlane).  // 由投影矩阵应使用齐次坐标(即平面)。 \tconst FVector4 HGRayStartWorldSpace = InvViewProjMatrix.TransformFVector4(RayStartProjectionSpace); const FVector4 HGRayEndWorldSpace = InvViewProjMatrix.TransformFVector4(RayEndProjectionSpace); FVector RayStartWorldSpace(HGRayStartWorldSpace.X, HGRayStartWorldSpace.Y, HGRayStartWorldSpace.Z); FVector RayEndWorldSpace(HGRayEndWorldSpace.X, HGRayEndWorldSpace.Y, HGRayEndWorldSpace.Z); // divide vectors by W to undo any projection and get the 3-space coordinate  // //将向量除以w以撤销任何投影并获得3-空间坐标 \tif (HGRayStartWorldSpace.W != 0.0f) { RayStartWorldSpace /= HGRayStartWorldSpace.W; } if (HGRayEndWorldSpace.W != 0.0f) { RayEndWorldSpace /= HGRayEndWorldSpace.W; } const FVector RayDirWorldSpace = (RayEndWorldSpace - RayStartWorldSpace).GetSafeNormal(); // Finally, store the results in the outputs \tout_WorldOrigin = RayStartWorldSpace; out_WorldDirection = RayDirWorldSpace; }   FPlane:\nFMatrix:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  FORCEINLINE FMatrix::FMatrix(const FPlane\u0026amp; InX,const FPlane\u0026amp; InY,const FPlane\u0026amp; InZ,const FPlane\u0026amp; InW) { M[0][0] = InX.X; M[0][1] = InX.Y; M[0][2] = InX.Z; M[0][3] = InX.W; M[1][0] = InY.X; M[1][1] = InY.Y; M[1][2] = InY.Z; M[1][3] = InY.W; M[2][0] = InZ.X; M[2][1] = InZ.Y; M[2][2] = InZ.Z; M[2][3] = InZ.W; M[3][0] = InW.X; M[3][1] = InW.Y; M[3][2] = InW.Z; M[3][3] = InW.W; } FORCEINLINE FMatrix::FMatrix(const FVector\u0026amp; InX,const FVector\u0026amp; InY,const FVector\u0026amp; InZ,const FVector\u0026amp; InW) { M[0][0] = InX.X; M[0][1] = InX.Y; M[0][2] = InX.Z; M[0][3] = 0.0f; M[1][0] = InY.X; M[1][1] = InY.Y; M[1][2] = InY.Z; M[1][3] = 0.0f; M[2][0] = InZ.X; M[2][1] = InZ.Y; M[2][2] = InZ.Z; M[2][3] = 0.0f; M[3][0] = InW.X; M[3][1] = InW.Y; M[3][2] = InW.Z; M[3][3] = 1.0f; }   step1:\nAPI UGameplayStatics::ProjectWorldToScreen 将给定的3D世界空间点转换为其2D屏幕空间坐标。\nAPI地址： https://docs.unrealengine.com/en-US/API/Runtime/Engine/Kismet/UGameplayStatics/ProjectWorldToScreen/index.html\n语法：\n1 2 3 4 5 6 7  static bool ProjectWorldToScreen ( APlayerController const * Player, const FVector \u0026amp; WorldPosition, FVector2D \u0026amp; ScreenPosition, bool bPlayerViewportRelative\t//这是否应该与玩家视窗子区域相关(在分割屏幕中使用玩家附加的小部件时很有用) )   Z-Buffer 用Renderdoc对UE4(PC，DX11）截帧，UE4的版本为4.18. 可以看到UE4一帧画面的渲染过程如下\n获取GBuffer的一种方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ENQUEUE_UNIQUE_RENDER_COMMAND_ONEPARAMETER( DZRenderSutioBP_InterceptSceneBaseColor, UTexture2D*, vTextureAsset, TextureAsset, { /*if (!IsInRenderingThread()) return;*/ FRHICommandListImmediate\u0026amp; RHICmdList = GRHICommandList.GetImmediateCommandList(); //计数加一避免Render完成后直接清空了GBuffer,但会慢一帧，你猜 FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, 1); static const FString ScrollingMessage(TEXT(\u0026#34;Hello World: \u0026#34;)); GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 0.2f, FColor::Red, ScrollingMessage); FSceneRenderTargets\u0026amp; SceneContext = FSceneRenderTargets::Get(RHICmdList); if (SceneContext.GBufferA) { FTexture2DRHIRef vTextTarget = SceneContext.GetGBufferATexture(); FString vSiceStr = FString::Printf(TEXT(\u0026#34;FSceneRenderTargets GBufferA Size = %d*%d\u0026#34;), vTextTarget-\u0026gt;GetSizeX(), vTextTarget-\u0026gt;GetSizeY()); GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 0.2f, FColor::Red, vSiceStr); } //移除 FSceneRenderTargets::Get(RHICmdList).AdjustGBufferRefCount(RHICmdList, -1); } );   How to export FTexture2DRHIRef to png?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class SceneDepthCapture { public: TArray\u0026lt;FLinearColor\u0026gt; sceneDepthData; FIntPoint bufferSize; void SceneDepthCaptureSync() { ENQUEUE_RENDER_COMMAND(ReadSurfaceFloatCommand)( [this](FRHICommandListImmediate\u0026amp; RHICmdList) { FSceneRenderTargets\u0026amp; context = FSceneRenderTargets::Get(RHICmdList); bufferSize = context.GetBufferSizeXY(); FIntRect Rect(0, 0, bufferSize.X, bufferSize.Y); RHICmdList.ReadSurfaceData( context.GetSceneDepthTexture(), Rect, sceneDepthData, FReadSurfaceDataFlags()); }); FlushRenderingCommands(); } };   使用模块的方式 使用模块\n添加自定义Pass的方法  添加Shader  了解了一个Pass要完成的工作，我们就可以动手实现一个自己的 Pass 了。首先要确定的问题是 Shader。既然要把同一个模型画两次，那必然要用到不同的Shader。关于如何在UE4中添加 Shader，可以参考 DepthPass 的 VS/PS(在DepthRendering.h中) 和 UE4 的官方文档：https://docs.unrealengine.com/en-US/Programming/Rendering/ShaderDevelopment/index.html。MobileBasePass的Shader因为涉及环境光，点光源数等可开关的Defination，所以对应的 C++ 类是以 template 的形式实现的。一般来说自定义 Pass 的 Shader 会继承 FMaterialShader 并用 IMPLEMENT_MATERIAL_SHADER_TYPE 宏来绑定对应的 usf 文件。 可以完全自己写新的 usf 文件，也可以在 FMaterialShader::ModifyCompilationEnvironment() 中应用不同的 SetDefine() 来实现不同的 Shader。需要注意的是 UE4 的 Shader 编译是一个比较漫长的过程，所以最好在 FMaterialShader::ShouldCompilePremutation() 中对材质进行筛选，只编译必要的Shader。否则所有的 Material 都会编译对应的 Shader，效率很低。还有注意 Shader 要在构造函数中绑定需要的 Uniform Buffer，在 GetShaderBinding 中绑定对应的UniformBuffer，否则会出现 ResourceMiss。\n2. 添加 MeshProcessor\n根据对UE4的渲染流程分析我们可以看出，Pass 生成 DrawCall 的主要逻辑是在 MeshProcessor 中完成的。MeshProcessor 是 4.22 中新加入的类名，之前对应的是 DrawingPolicy。添加 MeshProcessor 很简单，只需要继承 FMeshPassProcessor 并复写其 AddMeshBatch() 方法即可。一般我们会在 AddMeshBatch 方法中获取 Material Resource 的信息并对 MeshBatch 做进一步筛选，最后调用 Process 方法绑定 Shader，Mesh 和 Material，计算 Mesh 的 CullMode，ZTest，Zwrite，BlendOP 和 SortKey等等并用 BuildMeshCommands 生成 DrawCall。\n3. 添加 Pass\n所有的 Pass 都可以在 Enum EMeshPass中找到，所以第一步就是在 MeshProcessor.h 的 EMeshPass 中添加对应的 Enum。然后我们要为 Pass 创建对应的 MeshProcessor，我们可以在对应 .cpp 文件中实现对应 MeshProcessor 的 Creator 方法，并定义对应的 FRegisterPassProcessorCreatFunction 在其构造函数中传入对应的 Creator 方法指针和 Pass Enum。这一部分可以参考 MobileBasePass.cpp 最后的 CreateMobileBasePassProcessor 和 RegisterMobileBasePass 部分。之后我们就要在 MobileSceneRenderer 的 Render 方法中插入自定义 Pass 的渲染流程，这一部分主要是一些 Profile 标签和 RHICmdList 的Setup 和 Flush，还有生成 Pass 的多线程 DrawTask。这一部分逻辑可以参考 MobileBasePassRendering.cpp 中的 RenderMobileBasePass 方法。\n","description":"虚幻引擎相关问题","id":15,"section":"talks","tags":[""],"title":"UE4 Problems","uri":"https://vhope.cf/zh/talks/ue4-talks/"},{"content":"大概介绍以下UE4的主要渲染过程。\nUE4渲染过程 延迟渲染 所谓延迟渲染，是指将一个场景的几何体（3D模型、多边形）的光照、阴影、质感搁置到一旁，先着手于绘画，然后在后半段再对光照、阴影、质感进行处理的处理方式。即给人一种把原本的多边形先绘制出来的印象，实际上不仅要绘制多边形，前者的参数还需要配合后面光照和阴影的处理。其输出目标，在成为复数缓冲时具有普遍性，但是这里的缓冲我们称之为\u0026quot;物理缓冲\u0026rdquo;。物体缓冲是指使用后照明和后处理特效的中间过渡环节\n相关术语 RHI\n渲染硬件接口，是为不同平台抽象出不同图形API的一层。所有渲染命令均通过RHI层传递，以转换为适用的渲染器。\n延迟渲染\n虚幻引擎4中的默认渲染器。它因将照明/阴影计算推迟到全屏过程而不是绘制每个网格时而得名。\n顶点工厂\n顶点工厂是封装顶点数据源并链接到顶点着色器上的输入的类。静态网格物体，骨架网格物体和过程网格组件均使用不同的顶点工厂。\n着色器\n在虚幻引擎中，着色器是HLSL代码（以.ush / .usf文件的形式）和材质图的内容的组合。在Unreal中创建材质时，它会根据设置（如着色模式）和用法来编译多个着色器排列。\n渲染数据 相关的渲染的数据包括深度值及一些Gbuffer，如下图：\n几个Pass Z Pre Pass UE4的渲染管道，是在Bass Pass的物体缓冲写出来之前，在仅预处理深度值（Z值）之后，运行Z预阶段。\n事先预处理深度值的目的，是将最终影像和同一深度缓冲的内容结果，在透视前获得。Z预阶段之后的Base Pass则是，参考预先得出的深度值缓冲进行Z预测试，因此通过在最终的画面里不留下像素痕迹（即编写后又被消去的像素），以回避像素着色器的运行。\nBase Pass\n使用Base Pass输出物体缓冲需要注意的两点：\n  不绘制没进入视线的对象\n这种\u0026quot;投影剔除\u0026rdquo;（Frustum Culling），一般是通过CPU端来处理；为了整体覆盖被称为\u0026quot;包围球\u0026rdquo;（Bounding sphere）的各个3D对象，对象是否在视野内的判定标准，是通过预先设定的包围球来实行的。\n 什么程度的剔除会成功，可以通过Stat初始视图（Stat InitViews）指令的\u0026quot;视锥体裁剪基元（Frustum Culled Primitives）\u0026ldquo;进行确认。\n   不计算多余的像素\n在图像处理的流程中，使用像素着色器实际处理前，会有运行深度测试（Z 测试）的\u0026quot;Pre Z 测试\u0026quot;这一步骤。从这里着手处理的像素，会因为被某个东西所遮挡而无法绘制出来，这时可以进行撤销处理。\n 但是，像半透明对象这种会伴随α测试的绘制、视差遮蔽映射这种像素着色器处理后会重新编写深度值的情况，就不进行Pre Z测试，而通过处理实行分路迂回。\n    UE4 绘制策略DrawingPolicy\n绘制策略在UE4渲染中使用很多， 中文也不好翻译。 其实就是根据策略 使用了哪些 着色器 。\n \u0026hellip;\u0026hellip;\u0026hellip;.\nUE4渲染一帧 渲染管道 首先，虚幻的渲染由三个线程共同完成。分别是CPU线程，DRAW线程，和GPU线程。\n知乎：https://zhuanlan.zhihu.com/p/57158725\nRender模块 调用Render()函数在Render模块RendererModule.h中，以下函数：\n1 2 3 4 5  class FRendererModule : public IRendererModule { // 开始渲染视图族  virtual void BeginRenderingViewFamily(FCanvas* Canvas,FSceneViewFamily* ViewFamily) override; }   ==谁最终调用了Render？==\n实时渲染流程图： part1:https://i.loli.net/2020/05/30/qU8vN2WZVbt9hkF.jpg\npart2:https://i.loli.net/2020/05/30/3trKVpOMU5sTQfB.jpg\n渲染函数Render 路径：Engine \\ Source \\ Runtime \\ Renderer \\ Private \\ DeferredShadingRenderer.cpp（660）\n函数：FDeferredShadingSceneRenderer :: Render（）渲染路径\n   全局系统纹理初始化 DeferredShadingRenderer.cpp（677） GSystemTextures.InitializeTextures（）     保护 必要的渲染目标您是否已确保可以保护的最大目标数目？ DeferredShadingRenderer.cpp（680） GSceneRenderTargets.Allocate（）   初始化每个视口 设置视口显示的对象，选择使用动态阴影时显示的对象，对半透明对象进行排序 DeferredShadingRenderer.cpp（683） InitViews()（）   FXSystem预处理 GPU粒子正在被仿真 DeferredShadingRenderer.cpp（758） FXSystem-\u0026gt; PreRender（）   启用Z Pre-Pass时执行的早期Z绘制 不绘制Tile渲染的硬件（移动设备，Android或iOS）对于 PC或PS4，将生成深度缓冲区和HiZ，因此后续绘制速度很快成为？ DeferredShadingRenderer.cpp（768） RenderPrePass（）   安全GBuffer DeferredShadingRenderer.cpp（774） GSceneRenderTargets.AllocGBufferTargets（）   透明光传播量 DeferredShadingRenderer.cpp（779） ClearLPVs（）   使用DBuffer时绘制延期贴图单击此处获取 DBuffer和延期贴图 DeferredShadingRenderer.cpp（796） GCompositionLighting.ProcessBeforeBasePass（）   如有必要，请 在绘制线框图时清除GBuffer透明颜色缓冲区， 有些游戏在发行游戏时无法清除GBuffer或屏幕。 DeferredShadingRenderer.cpp（805） SetAndClearViewGBuffer（） DeferredShadingRenderer.cpp（816） RHICmdList.Clear（）   渲染不透明的对象渲染 项目，这些项目根据它们是Masked还是Default，是否有LightMap等按每种排序顺序进行了精细分类 DeferredShadingRenderer.cpp（828） RenderBasePass（）   清除 GBuffer 的未绘制部分如果事先清除GBuffer，则不必要。 DeferredShadingRenderer.cpp（851） ClearGBufferAtMaxZ（）   绘制 自定义深度请参见此处以获取自定义深度 DeferredShadingRenderer.cpp（860） RenderCustomDepthPass（）   在这里再次模拟GPU粒子除了在这里 处理使用深度缓冲区执行碰撞检测的 粒子外，还对GPU粒子进行排序 DeferredShadingRenderer.cpp（865） 场景-\u0026gt; FXSystem-\u0026gt; PostRenderOpaque（）   为SceneDepthTexture创建一个半分辨率（每个方面为1/4分辨率）的缓冲区 DeferredShadingRenderer.cpp（875） UpdateDownsampledDepthSurface（）   执行阻塞测试 HZB的构建，执行提交 的HZB Attotempkinder的这篇文章指 DeferredShadingRenderer.cpp（881） BeginOcclusionTests（）   开始写 因为有点复杂，所以要写一些细节 DeferredShadingRenderer.cpp（890）   不使用DBuffer绘制延迟的贴图 CompositionLighting.cpp（293） AddDeferredDecalsBeforeLighting（）   在屏幕空间中绘制环境光遮挡 CompositionLighting.cpp（300） AddPostProcessingAmbientOcclusion（）   后期处理环境立方体贴图 CompositionLighting.cpp（305） AddPostProcessingAmbientCubemap（）   到这里为止的一系列处理 DeferredShadingRenderer.cpp（904） GCompositionLighting.ProcessAfterBasePass（）   透明的体积光缓冲液可提高透明度 DeferredShadingRenderer.cpp（908） ClearTranslucentVolumeLighting（）   从此处开始的主要照明设备 收集要绘制的灯光并将其排序 不要投影，不使用灯光功能的灯光将使用“ 基于图块” 绘制（如果可能）如果不能使用“ 基于图块”关于延迟渲染，这是味o，但请参见此处 LightRendering.cpp（312-348） LightRendering.cpp（423） RenderTiledDeferredLighting（） LightRendering.cpp（429） RenderSimpleLightsStandardDeferred（）   它不会阴影，也不会使用灯光功能，但是似乎无法使用TBDR绘制的灯光 被称为标准延迟灯光。 LightRendering.cpp（445） RenderLight（）   如果用于半透明的体积光是有效的，则将每个光注入到体积光中 ，从而在3D纹理上绘制光效果。 LightRendering.cpp（455） InjectTranslucentVolumeLightingArray（） LightRendering.cpp（461） InjectSimpleTranslucentVolumeLightingArray（）   使用灯光功能投射阴影的灯光将单独处理 LightRendering.cpp（468-552）   首先，我在投射阴影时 绘制了一个阴影贴图；在这里我还绘制了一个 半透明的阴影贴图；我记得半透明的当然是傅立叶不透明度贴图。 LightRendering.cpp（495） RenderTranslucentProjectedShadows（） LightRendering.cpp（497） RenderProjectedShadows（）   使用LPV时绘制反射阴影贴图 LightRendering.cpp（508） RenderReflectiveShadowMaps（）   灯光功能图 阴影指示器图 LightRendering.cpp（515） RenderLightFunction（） LightRendering.cpp（522） RenderPreviewShadowsIndicator（）   衰减缓冲器中的分辨 光的衰减信息是否曾经被吸入另一个缓冲器中？ LightRendering.cpp（534） GSceneRenderTargets.FinishRenderingLightAttenuation（）   注入体积光以获得半透明 LightRendering.cpp（541） InjectTranslucentVolumeLighting（）   这 是使用光功能投射阴影的光处理的结束。 LightRendering.cpp（550） RenderLight（）   这 是每个光的LPV 的主要注入照明过程的结尾 LightRendering.cpp（561-593） Lpv-\u0026gt; InjectLightDirect（）   注入体积光以实现环境立方体贴图的半透明 DeferredShadingRenderer.cpp（916） InjectAmbientCubemapTranslucentVolumeLighting（）   过滤体积光以获得半透明 DeferredShadingRenderer.cpp（919） FilterTranslucentVolumeLighting（）   LPV传输过程 此外，第921行的注释上写有“ copypimis”，例如“ Clear LPV buffer”。 DeferredShadingRenderer.cpp（924） PropagateLPVs（）   动态天光绘图 DeferredShadingRenderer.cpp（928） RenderDynamicSkyLighting（）   延迟的反射图形 捕获的反射图形而不是屏幕空间 DeferredShadingRenderer.cpp（931） RenderDeferredReflections（）   LPV的GI绘图 CompositionLighting.cpp（344） AddPostProcessingLpvIndirect（）   屏幕空间次表面散射（SSSSS）的后处理 CompositionLighting.cpp（347-376）   如果启用了“光轴”，则绘制“光轴遮挡” DeferredShadingRenderer.cpp（953） RenderLightShaftOcclusion（）   大气雾图 DeferredShadingRenderer.cpp（977） RenderAtmosphere（）   绘图雾 这是高度雾吗？ DeferredShadingRenderer.cpp（986） RenderFog（）   画一个半透明的物体 在这里也画一个单独的半透明的东西 DeferredShadingRenderer.cpp（1000） RenderTranslucency（）   折射变形处理 DeferredShadingRenderer.cpp（1008） RenderDistortion（）   光轴的起霜处理 DeferredShadingRenderer.cpp（1013） RenderLightShaftBloom（）   距离场AO处理不能在 当前不支持多个视口 的分屏游戏中使用吗？ DeferredShadingRenderer.cpp（1019） RenderDistanceFieldAOSurfaceCache（）   它只是在查看网格的“距离场”的可视化处理结果吗？ DeferredShadingRenderer.cpp（1024） RenderMeshDistanceFieldVisualization（）   由于速度模糊而绘制运动对象的速度 DeferredShadingRenderer.cpp（1034） RenderVelocities（）   从这里到最后的发布过程， 这也很复杂而且很长 DeferredShadingRenderer.cpp（1047） GPostProcessing.Process（）   使用BeforeTranslucency设置绘制后处理材料 PostProcessing.cpp（878） AddPostProcessMaterial（）   景深处理 通过高斯模糊进行DOF 处理之后，正在执行散焦处理（使用指定的光圈形状的纹理进行绘制）， 在此阶段似乎合并了单独的半透明缓冲区 PostProcessing.cpp（888） AddPostProcessDepthOfFieldGaussian（） PostProcessing.cpp（898） AddPostProcessDepthOfFieldBokeh（） PostProcessing.cpp（905） FRCPassPostProcessBokehDOFRecombine （如果未启用模糊）   使用BeforeTonemapping设置绘制后处理材料 PostProcessing.cpp（913） AddPostProcessMaterial（）   如果要使用TemporalAA ，请在此处绘制，如果使用FXAA，请稍后再绘制 PostProcessing.cpp（921） AddTemporalAA（） PostProcessing.cpp（928） AddTemporalAA（） （如果不使用速度缓冲区，请单击此处）   运动模糊处理 设置，分辨率下采样，高斯模糊，运动模糊绘制，组合处理 PostProcessing.cpp（932-994） FRCPassPostProcessMotionBlurSetup FRCPassPostProcessDownsample RenderGaussianBlur（） FRCPassPostProcessMotionBlur FRCPassPostProcessMotionBlurRecombine   SceneColor下采样 PostProcessing.cpp（1000） FRCPassPostProcessDownsample   直方图 PostProcessing.cpp（1006-1040） FRCPassPostProcessHistogram FRCPassPostProcessHistogramReduce   此处需要眼睛适应图直方图 PostProcessing.cpp（1046） AddPostProcessEyeAdaptation（）   布卢姆绘图 PostProcessing.cpp（1057） AddBloom（） PostProcessing.cpp（1060-1148） （对于移动设备，请单击此处）   色调映射 仅替换ReplacecingTonemapper设置工程图的一种后处理材料，但是 如果存在该材料，则执行默认色调映射 PostProcessing.cpp（1155） AddSinglePostProcessMaterial（） PostProcessing.cpp（1171） AddTonemapper（） （默认色调映射）   如果启用了FXAA，请在此处处理 PostProcessing.cpp（1177） AddPostProcessAA（）   绘制一些编辑器（如选定的轮廓）， 然后使用AfterTonemapping设置绘制后期处理材料 PostProcessing.cpp（1244） AddPostProcessMaterial（）   用于地下和GBuffer的可视化 调试 PostProcessing.cpp（1246-1254）   用于HMD的后处理 Oculus或Morpheus PostProcessing.cpp（1256-1277） FRCPassPostProcessHMD FRCPassPostProcessMorpheus   之后，调试和高分辨率屏幕截图功能等。 之后，进行后处理并结束！ 谢谢！ PostProcessing.cpp（1279-）    哦，很长。\n参考链接：\n  如何在C ++中从UTexture2D读取数据\n  https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1422920-casting-converting-frhitexture-to-utexture\n  Unreal渲染相关的缓冲区\n  https://qiita.com/mechamogera/items/a0c369a3b853a3042cae\n  https://answers.unrealengine.com/questions/17862/access-color-and-depth-buffer-of-each-frame.html\n  https://segmentfault.com/a/1190000012737548\n  Gbuff数据\n  渲染系统概述 图片\n  ","description":"","id":16,"section":"posts","tags":["C++","UE4","Game"],"title":"UE4渲染过程","uri":"https://vhope.cf/zh/posts/ue/ue4-render/"},{"content":"RSA算法 RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。\n 对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到当前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。\n 公钥/双密钥/非对称 加密 涉及到两个密钥的使用:\n 一个公钥, 可以被任何人知道，用于加密消息和验证签名 一个私钥, 只有接收方才知道，用于解密消息和创造签名  RSA实现过程 1. 公钥与私钥的产生 生成公钥e和私钥d的步骤如下：\n 随意选择两个大的质数$p$和$q$，$p$不等于$q$，计算$n=pq$。 根据欧拉函数，求$r = \\varphi (N) = \\varphi (p)\\varphi (q) = (p - 1)(q - 1)$ 选择一个小于$r$的整数$e$，使$e$与$r$互质。并求得$e$关于$r$的模反元素，命名为$d$(求$d$令$ed \\equiv 1(\\bmod ;r)$)。(模反元素存在，当且仅当$e$与$r$互质) 将$p$和$q$的记录销毁  经过上面四个步骤最终可以得到公钥$(n,e)$和私钥$(n,d)$。\n接收消息的人将自己的公钥$(n,e)$发送给发送消息的人,发送的人使用这个公钥加密信息发送给接收方，而接收方将私钥$(n,d)$保存起来用于解密。\n下面实现RSA类\n 参考资料：\n 米勒-拉宾素性检验 RSA加密算法 C++实现   实验步骤与结果 1.实现大整数类 因为该加密算法涉及的数可能很大，而C++中并没有像Java一样，内置大整数类BigInteger，故需自己实现，这里我参考了网上的一些资料设计了BigInteger类，实现了加减乘除以及模幂等运算，也实现了运算符重载，具体参考实现的方法如下：\n2. 设计RSA类 编写rsa.h头文件，定义RSA类，其中包含的成员以及成员函数如下：\n下面分别实现上述的各个方法\n首先要生成密钥对，即生成公钥和私钥，那么，我们首先需要生成两个大素数p和q,显然，素数是不可能是偶数的，故定义一个生成随机奇数的函数BigInteger createOddNum(unsigned len)参数为奇数的长度。\n使用16进制的随机字母，然后随机选取其中的len/4个得到一个随机的大奇数，只需要末尾那个数为奇数即可，最后返回BigInteger类型的奇数大整数，关键代码如下：\n然后定义一个生成素数的函数，其中用到米勒-拉宾素性检验算法判断生成的素数是否为素数素数：\n米勒-拉宾素性检测算法 基于以下定理：\n 费马小定理  要测试$N$是否为素数，首先将$N−1$分解为$2^{s}d$。在每次测试开始时，先随机选一个介于$[1,N−1]$的整数$a$，之后如果对所有的$r∈[0,s−1]$，若${a^d}\\bmod N \\ne 1$且${a^{{2^r}d}}\\bmod N \\ne - 1$，则$N$是合数。否则，$N$有$3/4$的概率为素数。\n关键代码如下：\n生成素数的逻辑就是首先使用函数createOddNum生成一个大奇数，然后调用isPrime判断是否为一个素数，是的话就可以return，不然继续寻找，知道生成一个素数。\n接下来计算n值，n值的计算很简单，直接使用$n = p * q$ 这个式子就能够计算出来；计算欧拉值也一样，可以使用$\\varphi(n) = (p-1) * (q-1)$得出。其中比较难的是生成的私钥d。\n下面定义一个RSA类的初始化函数init()​，生成p、q以及密钥对，如下：\n在创建公钥e和私钥d的函数createExponent(eul)中，首先创建一个比欧拉值小的公钥e，其中e为一个素数，直接调用函数createPrime()生成，然后使用大整数类中的求模逆元，即求出私钥d。\n扩展欧几里得算法  逆元\n逆元是模运算中的一个概念，我们通常说 A 是 B 模 C 的逆元，实际上是指 A * B = 1 mod C，也就是说 A 与 B 的乘积模 C 的余数为 1。可表示为 A = B^(-1) mod C。\n打个比方，7 模 11 的逆元，即：7^(-1) mod 11 = 8，这是因为 7 × 8 = 5 × 11 + 1，所以说 7 模 11 的逆元是 8。\n 扩展欧几里得算法是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式\n$$\nax{\\rm{ }} + {\\rm{ }}by{\\rm{ }} = {\\rm{ }}gcd\\left( {a,b} \\right).\n$$\n在RSA算法中求私钥中的整数d时，需要使得 (e * d ) % n = 1，该方程等价于 e * d = 1 + y * n （y为整数），也等价于 e * d - y * n = 1。\n因此求解d的过程就是求解该二元一次方程组（e和n已知，求解d），即求e模n的逆元。\n关键代码如下：\n我们知道，RSA的加密与解密其实就是一个模幂的运算，而这个模幂的运算已经在大整数类中实现了，如下：\n使用RSA类进行加密解密的函数只需要调用这个模幂运算即可，例如私钥加密可以这样调用：\n以上就设计完了RSA类的相关操作，主要是包括密钥的生成。下面将RSA加密解密的操作封装在一个类中。\n3. 设计加密解密类EncryptDecrypt 主要的方法及成员如下：\n实现RSA加密解密字符串 加密字符串的逻辑是，先将字符串以每两个字符 一组，转化为一个16进制数据序列，使用vector容器保存，之后调用rsa的公钥加密函数进行加密，如下是关键代码：\n解密函数其实是接受一个加密后的16进制序列，然后对这个序列调用RSA的私钥解密函数进行解密，然后得到解密后的16进制数据序列，最后还有一步就是需要将这个16进制序列最终转化为原来的字符串，只需要根据ascii码的数值即可得到，这里编写了一个hex2string函数，关键代码如下：\n实现效果\n首先显示密钥：\n加密字符串\n解密字符串\n实现RSA加密解密文件 实现RSA加密解密文件时基于RSA加密解密字符串实现的，其中主要的加密逻辑就是将一个文件看作是一行一行的字符串文本，没每读取一行，就调用加密字符串的函数进行加密，然后将加密得到的16进制序列写入到另外一个文件中，而这个文件也就是加密后的文件，主要关键代码如下：\n解密文件的函数稍微有点不一样，是从打开的待解密文件中循环读取每一个16进制数据，然后对每一个16进制数据调用解密函数得到解密后的16进制数据，将16进制数据转为字符串后再相继的写到另外一个文件中，即解密后的文件，关键代码如下：\n实现效果\n加密文件\n解密文件\n加密文件解密文件对比\n实现RSA数字签名及验证 实现数字签名方案，按照以下的流程图进行操作。\n首先需要对文件进行信息的摘要，得到Hash值，这里选择的Hash算法是SHA512算法，可以直接对文件进行信息摘要。\n可以直接include C++ 实现的\u0026quot;sha512.h\u0026quot;文件头，然后使用以下的语句就能够生成一个长度为512的Hash值，如下：\n可以在命令行输出文件的Hash摘要值如下:\n数字签名的实现类似字符串加密，对文件的hash值进行加密得到后面的16进制序列，然后将16进制序列伴随文件发送出去，签名的关键代码就是对hash值进行加密，如下：\n验证函数直接将16进制序列进行解密，然后还原成字符串再与收到的文件的hash值进行比较，如果相等，那么验证成功；否则验证失败，关键代码如下：\n实现效果\n数字签名\n验证数字签名\n","description":"","id":17,"section":"posts","tags":["rsa"],"title":"RSA加密算法","uri":"https://vhope.cf/zh/posts/rsa/"},{"content":"费马大定理在数学里有一个特殊的现象，即在于它是错误证明数量最多的数学题。\n费马小定理 费马小定理是数论中的一个定理：假如$a$是一个整数，$p$是一个质数，那么$a^{p}-a$是$p$的倍数，可以表示为\n$$\na^{p} \\equiv a \\pmod p\n$$\n当a不是p的倍数时也可以表示为\n$$\na^{p-1} \\equiv 1 \\pmod p\n$$\n 同余符号\n两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余\n记作$a \\equiv b\\pmod {m}$\n读作a同余于b模m，或读作a与b关于模m同余。\n比如$26 \\equiv 14 \\pmod{12}$\n 一种证明：\n考虑一根有 [公式] 颗珠子的项链，其每颗珠子有 [公式] 种染色选择，然后由下图蕴含的精神可得原命题成立。\n费马大定理 当整数$n\u0026gt;2$时，关于$x, y, z$的不定方程\n$$\nx^{n} + y^{n} = z^{n}\n$$\n没有整数解\n","description":"费马大定理、费马小定理","id":18,"section":"posts","tags":["费马"],"title":"费马🦓定理","uri":"https://vhope.cf/zh/posts/math/feima/"},{"content":"费马大定理在数学里有一个特殊的现象，即在于它是错误证明数量最多的数学题。\n费马小定理 费马小定理是数论中的一个定理：假如$a$是一个整数，$p$是一个质数，那么$a^{p}-a$是$p$的倍数，可以表示为\n$$\na^{p} \\equiv a \\pmod p\n$$\n当a不是p的倍数时也可以表示为\n$$\na^{p-1} \\equiv 1 \\pmod p\n$$\n 同余符号\n两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余\n记作$a \\equiv b\\pmod {m}$\n读作a同余于b模m，或读作a与b关于模m同余。\n比如$26 \\equiv 14 \\pmod{12}$\n 一种证明：\n考虑一根有 [公式] 颗珠子的项链，其每颗珠子有 [公式] 种染色选择，然后由下图蕴含的精神可得原命题成立。\n费马大定理 当整数$n\u0026gt;2$时，关于$x, y, z$的不定方程\n$$\nx^{n} + y^{n} = z^{n}\n$$\n没有整数解\n","description":"费马大定理、费马小定理","id":19,"section":"posts","tags":["费马"],"title":"费马🦓定理","uri":"https://vhope.cf/zh/posts/network/feima/"},{"content":"操作流程 用到的云产品及服务            序号 云产品 功能及用途 备注   1 容器镜像仓库 用于存放示例demo镜像    2 云编译 编译和打包实例demo代码，同时将镜像推送至容器镜像仓库    3 私有网络 创建用于Kubernetes集群，工作节点所需的VPC    4 Access Key 授权K8S集群访问京东智联云各个服务API的授权凭证。 例如：集群向京东智联云监控中心，推送业务监控数据就需要用到AK/SK。   5 Kubernetes集群 创建K8S集群，部署应用服务 规格：通用型1核4GB，公网IP 5Mpbs   6 云监控 查询业务监控数据，配置告警服务。     实操 第一步：准备Docker镜像 创建容器镜像仓库 新建注册表\n  登录京东智联云控制台，选择云服务-\u0026gt;弹性计算-\u0026gt;容器镜像仓库。\n  进入注册表页面，选择“华北-北京”地域，点击“新建”按钮，进入新建注册表页面。\n  在新建注册表页面，设置名称，勾选同意服务条款。点击“保存”按钮即可。\n  新建镜像仓库\n  切换至“镜像仓库”列表页面，选择地域“华北-北京”，点击“创建”按钮。\n  在新建镜像仓库页面， 选择刚新建的注册表，配置注册表名称信息\n  创建成功后，在镜像仓库里列表可以看到到仓库名称。以及镜像仓库的URI\n  编译构建Docker镜像 新建编译任务\n  选择云服务-\u0026gt;开发者工具-\u0026gt;云编译，进入云编译服务页面。\n  在任务列表页面，选择华北-北京地域， 点击“创建”按钮，选择中“创建任务”\n  在创建任务页面做如下配置：\n任务配置与源码配置如下，其中代码库地址为:https://code.jdcloud.com/jdcloud-monitor/prometheus-demo.git\n构建存放的配置如下：\n其他选项保持默认配置\n  点击“保存”按钮，完成任务的创建。\n  构建任务\n  选中刚创建的任务，点击操作了下的执行构建按钮。\n  在弹出的构建页面，配置如下信息,其中CommitID为ece523fc68cce1cd3d48b38fc07252f81ba2c44c\n  点击“确定”按钮，执行编译构建操作。当产物归档状态变为完成状态时，完成构建。\n  第二步：用K8S部署应用服务 前提准备 创建kubernetes进群时，需要用到VPC 和 密钥信息， 只需创建VPC即可，无需创建子网，工作节点组用到的子网会自己创建。\n创建VPC\n  选择云服务-\u0026gt;网络-\u0026gt;私有网络，进入私有网络VPC列表页面。\n  在私有网络页面，选中华北-北京地域，点击“创建”按钮。\n  配置网络名称，IPv4CIRD选择 192.168.0.0/16。\n  创建AK/SK密钥\n  点击顶部导航的账户名称，在弹出的下拉框中点击“Access Key管理”\n  在进入的Access Key管理页面中，点击“创建Access Key”，会提示输入短信验证码，输入完就可以创建了\n  创建Kubernetes集群   选择云服务-\u0026gt;弹性计算-\u0026gt; Kubernetes集群，进入集群列表页面。\n  选择“华北-北京”地域，点击“创建”按钮，在新建Kubernetes集群，进行如下配置\n集群信息配置\n网络与工作节点配置\n密码配置\n  部署服务 注册镜像仓库\n 本操作是将容器镜像仓库的注册表在K8S服务中进行注册，便于后续pod上部署应用服务。\n   选择云服务-\u0026gt;弹性计算-\u0026gt; 云主机，进入云主机列表页面。在云主机列表可以看到新创建了2台云主机实例。\n  找到k8s-***-nat-vm-***命名的云主机，其为K8S集群的管理节点云主机， 可以公网SSH远程登录进去。\n  获取集群凭据， 选择云服务-\u0026gt;弹性计算-\u0026gt; Kubernetes集群, 进入集群列表页面。选中刚创建的集群信息，点击名称，进入详情页面。切换至kubectl客户端配置页。\n  管理节点登录成功后，ssh 登录至 k8s-node-*** 节点的云主机（**命令： ssh root@your_node_ip, 需要将 your_node_ip 替换为你的node云主机的内网ip。点击回车后输入密码即可** ）。\n  配置kubectl客户端\n执行如下的命令\n1 2 3 4 5  mkdir -p $HOME/.kube cd $HOME/.kube vi config   将kubectl客户端配置的凭据，拷贝至config中，保存后退出。执行 sudo chown $(id -u):$(id -g) $HOME/.kube/config 命令。\n  执行以下操作命名，注册镜像仓库。\nkubectl create secret -n default docker-registry my-secret --docker-server=k8s-monitor-demo01-cn-north-1.jcr.service.jdcloud.com --docker-username=jdcloud --docker-password=Eoj3Ja4mSeXasAbX --docker-email=1427298682@qq.com 输入指令如下：\n  创建Pod\n  在kubernetes集群页面，菜单切换至Workloads-\u0026gt;Pod，进入Pod列表页面。点击创建pod\n  配置如下信息\na. 集群：请确认刚创建的集群，例如：monitor-demo\nb. Yaml 文件：将如下内容拷贝至黑色输入框，注意黄色标注内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:prometheus-demolabels:app:prometheus-demospec:imagePullSecrets:- name:my-secretcontainers:- name:flaskapp-demoimage:k8s-monitor-demo01-cn-north-1.jcr.service.jdcloud.com/k8s-monitor-demo-repo:job-ANbzZdjyyYKEBRX-1587872493ports:- containerPort:5000- containerPort:7777   注意：\n  name：为您注册镜像仓库创建的secret名称，示例用的my-secret。\n  image 标注为黄色的内容包含2个部分，URI:镜像版本，请一定要替换为自己镜像仓库的内容。可通过如下截图位置获取。\n     创建Pod  可以看到创建的pod，进入pod详情，切换至Container可以查看其运行状态，等待3分钟左右，其状态变为运行，服务部署成功。\n  配置访问策略 创建Service\n 注：基于K8S部署的应用服务，若需要外网访问，则需要创建一个负载均衡，同时绑定公网IP，以下步骤就是通过创建Service为服务配置一个负载均衡。\n   切换至service列表页面，选择“华北-北京”，点击“创建”按钮。\n  进入创建Service页面\n配置如下信息\na. 集群：确认选中的集群。\nb. Yaml：将如下信息拷贝至输入框中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  kind:ServiceapiVersion:v1metadata:name:prometheus-demoannotations:prometheus.io/path:/metricsprometheus.io/port:\u0026#39;7777\u0026#39;prometheus.io/scrape:\u0026#39;true\u0026#39;spec:ports:- protocol:TCPport:5000targetPort:5000selector:app:prometheus-demotype:LoadBalancer    点击“确定”按钮，完成service创建。点击名称，进入详情页面，可查看到pod状态为running。\n  点击顶部导航云服务-\u0026gt;网络-\u0026gt;负载均衡，进入应用负载均衡页面。可以看到刚新建的的LoadBalancer。\n  访问服务\n  在新建的负载均衡服务页面，获取到公网IP， 在浏览器端输入http://公网IP:5000，可看到如下界面。\n  第三步：业务监控告警 查看监控图   选择云服务-\u0026gt;监控与运维-\u0026gt; 云监控，进入云监控控制台。\n  在左侧菜单选中“自定义监控”，进入自定义监控页面。\n   输入以下查询条件，可以看到Demo示例内置采集的一些业务数据。查询条件如下：\n  配置告警   在上述查看的的监控图中，点击“配置报警”按钮，进入设置告警页面，进行如下配置：\n基本信息配置\n触发条件配置\n通知策略配置\n  上面配置完之后当访问页面次数超过10此的时候就会有邮件和短信的通知\n邮件\n短信\n","description":"","id":20,"section":"posts","tags":["云计算","京东云"],"title":"使用云监控管理k8s-京东云实践","uri":"https://vhope.cf/zh/posts/cloud/cloud-kubernetes/"},{"content":"[toc]\n1. 鲲鹏云服务 鲲鹏处理器与服务器 鲲鹏处理器 华为鲲鹏处理器是华为自主研发的基于ARM架构的企业级系列处理器产品，包含“算、存、传、管、智”五个产品系统体系。\n架构介绍： 华为鲲鹏处理器基于ARM架构。ARM是一种CPU架构，有别于Intel、AMD CPU采用的CISC复杂指令集，ARM CPU采用RISC精简指令集（reduced instruction set computer，精简指令集计算机）。\n处理器对比：\n优点：  采用ARM架构，同样功能性能占用的芯片面积小、功耗低、集成度更高，更多的硬件CPU核具备更好的并发性能。 支持16位、32位、64位多种指令集，能很好的兼容从IOT、终端到云端的各类应用场景。 大量使用寄存器，大多数数据操作都在寄存器中完成，指令执行速度更快。 采用RISC指令集，指令长度固定，寻址方式灵活简单，执行效率高。  规格发展 华为鲲鹏920处理器规格 技术创新 内置多种加速引擎 Taishan服务器 系列 TaiShan 200机架服务器全景图 TaiShan 200高密服务器 云服务 云计算 美国国家标准与技术研究院（NIST）定义：\n云计算是一种模型，它可以实现随时随地，便捷地，随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用、及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。\n云计算的特点:\n 快捷的网络访问 自服务和随需分配 资源池 灵活有弹性 服务可度量  云计算的本质就是自动化和规模化在IT行业的服务化体现！  云服务实例 而云服务正是由于云计算的发展而孕育而生,主要依靠云计算的虚拟化技术.将所有的硬件资源进行计算虚拟化和存储虚拟化,最后得到我们的云服务.\n一个简单的网站例子可以是下面这张图:\n计算类云服务 计算类云服务有如下这么多种:\nECS-(弹性云主机) 弹性云服务器（ Elastic Cloud Server ）是一种可随时自助获取、可弹性伸缩的云服务器，帮助用户打造可靠、安全、灵活、高效的应用环境，确保服务持久稳定运行，提升运营效率。\n需要注意的是,ECS一般要配合硬盘系统盘、数据盘以及VPC等组件进行使用.  如下是一个简单的多态ECS服务器的拓扑图:\nBMS裸金属服务器 弹性裸金属服务器(Bare Metal Server)服务, 为用户提供专属的物理服务器，提供卓越的计算性能，满足核心应用场景对高性能及稳定性的需求，结合了传统托管服务器带来的稳定性能与云中资源高度弹性的优势。\n这个云服务的应用场景主要针对部署在物理机上的场景.\n规格和场景：\n 自带SDI卡，实现无系统盘挂载的技术。\n IMS镜像服务 镜像是由基础操作系统、预装的公共应用以及用户私有应用组成的模板，便于用户批量发放弹性云主机或裸金属服务器。\n有了镜像之后,就相当于有了一个当前系统的备份,可以复制到其他云服务器上,减少配置的时耗.  镜像服务提供镜像生命周期管理能力。用户可以通过服务器或外部文件创建系统盘镜像或数据盘镜像，也可以使用弹性云服务器或云服务器备份创建带数据盘的整机镜像。并对镜像进行修改，共享，加密，复制，导出，标签管理，企业多项目管理，发布市场镜像等操作。\nAS弹性伸缩服务 弹性伸缩（Auto Scaling）可根据用户的业务需求和预设策略，自动调整计算资源或弹性IP资源，使云服务器数量或弹性IP带宽自动随业务负载增长而增加，随业务负载降低而减少，节省云上业务资费，保证业务平稳健康运行.\n应用场景主要有:\n 企业网站、电商、移动应用等，业务特点：业务请求有突发式暴增或者访问量起伏不定 视频网站、媒体编解码应用、媒体内容回传应用、高流量内容管理系统、分布式高速缓存系统,业务特点:需要根据计算量动态调整计算、网络等资源  AS服务一般配合负载均衡(ELB)一起使用,例如:\n AS系统架构如下:\n云容器服务 CCE(云容器引擎)\n云容器引擎（Cloud Container Engine，简称CCE）提供高度可扩展的、高性能的企业级Kubernetes集群，支持运行Docker容器。借助云容器引擎，您可以在云上轻松部署、管理和扩展容器化应用程序。\n实用实例：\n优点：\n 多平台混合部署 跨云管理 一键式交付 高性能  CCI(云容器实例)\n云容器实例（Cloud Container Instance， CCI）服务提供 Serverless Container（无服务器容器）引擎，让您无需创建和管理服务器集群即可直接运行容器。\n使用云容器实例\n优点\n 免运维 高安全 极致性能 秒级付费 开放生态 极速弹性  云容器特性\n服务总览\n存储类云服务 存储类云服务主要分为如下三种:\n云硬盘EVS 云硬盘（Elastic Volume Service）是一种为ECS、BMS等计算服务提供持久性块存储的服务，通过数据冗余和缓存加速等多项技术，提供高可用性和持久性，以及稳定的低时延性能。您可以对云硬盘做格式化、创建文件系统等操作，并对数据做持久化存储。云硬盘提供多种性能规格，用户可以根据不同业务场景按需、灵活配置。\n使用图解:\n相当于在云上的硬盘.\n对象存储服务OBS 对象存储服务（OBS）是一个基于对象的海量存储服务，为您提供海量、低成本、高可靠、安全的数据存储能力。\n图解如下:\n弹性文件服务SFS和SFS 弹性文件服务（Scalable File Service）为用户的弹性云服务器（ECS）提供一个完全托管的共享文件存储，符合标准文件协议（NFS），能够弹性伸缩至PB规模（SFS Turbo最大320TB），具备可扩展的性能，为海量数据、高带宽型应用提供有力支持。\n云备份服务 最简单的备份服务，可将云服务器数据恢复到任意备份点,例如:\nSDRS 存储容灾服务 存储容灾服务（Storage Disaster Recovery Service，简称SDRS）是一种服务化容灾方案，可大幅降低企业容灾TCO。通过简单三步操作（创建保护组、创建保护实例、开启保护）即可为云上虚拟机提供跨可用区级别的容灾保护，确保数据零丢失（RPO=0），并可在灾难发生时迅速恢复业务，减少损失。\n简单例子:\n网络类云服务 主要有如下几种:\nVPC虚拟私有云服务 虚拟私有云（Virtual Private Cloud): 用户在华为云上申请的隔离的、私密的虚拟网络环境。用户可以自由配置VPC内的IP地址段、子网、安全组等子服务，也可以申请弹性公网IP和带宽搭建面向Internet的业务系统。\n主要包括如下四个方向内容:\n弹性公网IP 弹性公网IP（Elastic IP）提供独立的公网IP资源，包括公网IP地址与公网出口带宽服务。可以与弹性云服务器、裸金属服务器、虚拟IP、弹性负载均衡、NAT网关等资源灵活地绑定及解绑。\n 简单来说,就是外界可以访问的ip地址.并且是其他功能的依赖.\n 使用模型：\nNAT网关服务 NAT网关（NAT Gateway）能够为VPC内的弹性云服务器提供SNAT和DNAT功能，通过灵活简易的配置，即可轻松构建VPC的公网出入口\n SNAT和DNAT分别为源地址转换和目的地址转换。\nSNAT架构：\nDNAT架构：\n 使用NAT这个功能主要是为了节省弹性公网IP资源并且避免云主机IP直接暴露在公网上。\n虚拟专用网络 VPN 虚拟专用网络（Virtual Private Network）用于搭建用户本地数据中心与华为云VPC之间便捷、灵活，即开即用的IPsec加密连接通道，实现灵活一体，可伸缩的混合云计算环境\n 主要面向的是企业用户。\n 满足需求：\n 混合云部署 跨地域VPC 互联  云专线 DC 云专线（Direct Connect）用于搭建用户本地数据中心与华为云VPC之间高速、低时延、稳定安全的专属连接通道，充分利用华为云服务优势的同时，继续使用现有的IT设施，实现灵活一体，可伸缩的混合云计算环境\n应用场景：\n 混合云部署 异地容灾  弹性负载均衡服务ELB 弹性负载均衡（Elastic Load Balance，简称ELB）是将访问流量根据转发策略分发到后端多台弹性云服务器的流量分发控制服务。弹性负载均衡可以通过流量分发扩展应用系统对外的服务能力，提高应用程序的容错能力。\n简单来说，ELB就是用来处理多用户连接时候的资源缺乏的，临时制造多个副本来缓解压力。应用场景有：大型门户网站、跨可用区同城容灾、电商抢购。\nPPT  2. 鲲鹏应用移植 两种语言 1. 编译型语言 2. 解释型语言 策略 迁移过程 迁移工具 华为鲲鹏代码迁移工具主要面向鲲鹏平台的开发者、用户和第三方待移植软件提供方开发工程师，用来分析待移植软件源码文件，并给出代码移植指导报告，同时能够自动分析出需修改的代码内容，并指导如何修改，帮助用户顺利完成应用从x86平台向鲲鹏平台的移植。\n逻辑架构 容器迁移 容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。\n容器与虚拟机的不同 前提 跨平台的容器无法运行，会出现格式错误\n x86平台获取的镜像是适用于x86平台，当迁移到鲲鹏平台，容器无法执行。 在基于ARM的平台中，docker pull方式或者Dockerfile方式获取或者构建的镜像均为基于ARM平台的，同样也无法在x86上运行。  容器迁移的原理 迁移容器同时涉及到两个操作，备份和恢复。我们可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，首先我们将把容器备份为Docker镜像快照。然后，该Docker镜像或者是被推送到了Docker注册中心，或者被作为tar包文件保存到了本地。如果我们将镜像推送到了Docker注册中心，我们简单地从任何我们想要的机器上使用 docker run 命令来恢复并运行该容器，或者通过docker pull命令拉取我们想要的镜像。\n迁移策略 Docker容器迁移有两种策略：使用Docker pull获取镜像或使用Dockerfile构建镜像。\n主要流程  Docker安装 Docker构建基础镜像 Dockerfile创建应用镜像 验证应用镜像  性能调优 性能调优就是对计算机硬件、操作系统和应用程序有相当深入的了解，调节三者之间的关系，实现整个系统（包括硬件、操作系统、应用程序）的性能最大化，并能不断地满足现有的业务需求。\n华为鲲鹏性能优化工具 为解决客户软件运行遇到性能问题时凭人工经验定位困难、调优能力弱的痛点，华为推出了Kunpeng Tuning Kit鲲鹏性能优化工具。\n华为鲲鹏性能优化工具主要面向华为FAE、开放实验室能力建设工程师或客户工程师，针对应用程序部署在TaiShan服务器的场景下，通过收集服务器的处理器硬件、操作系统、进程/线程、函数等各层次的性能数据，分析出系统性能指标，定位到瓶颈点及热点函数。\n华为鲲鹏性能优化工具功能特性  支持采集整个系统或指定进程的CPU Cycles性能事件，能够快速定位热点函数。 支持热点函数按照CPU核/线程/模块进行分组，支持查看热点函数调用栈。 支持通过火焰图查看热点函数及其调用栈。 支持代码映射功能，即查看函数内的热点指令及该指令对应的高级语言文件及行号。 支持显示汇编代码的控制流图。 支持分析Java代码的热点函数及热点指令。  华为鲲鹏性能优化工具逻辑架构 主要分为Analysis和Agent两个模块。\n子模块 Analysis子模块\nAgent子模块\n部署方式 当前版本只支持单机部署，即将华为鲲鹏性能优化工具所有组件部署在一台服务器上，完成对该台服务器软件的性能数据采集和分析。\n如以下示例图：\n 部署环境要求如下表所示：\n 部署后访问方式  华为鲲鹏性能优化工具部署在TaiShan服务器上，该服务器上同时运行客户的应用软件。 华为鲲鹏性能优化工具提供Web界面访问方式，用户只需要在浏览器地址栏中输入：https:// 部署服务器的IP:端口号 即可。  访问Web界面时，对本地浏览器的要求如下表所示。\n优化工具业务流程 C/C++程序性能分析和优化 Java Mixed-Mode程序性能分析和优化 3. 容灾备份安全 云架构 基础架构：\n安全架构：\n企业主机安全（HSS） 企业主机安全（Host Security Service）是提升主机整体安全性的服务，包括账户破解防护、弱口令检测、恶意程序检测、双因子认证、漏洞管理，网页防篡改等功能，帮助企业构建服务器安全防护体系，降低当前服务器面临的主要安全风险\nWAF：最常用最有效的防护方案 Web应用防火墙（Web Application Firewall）对网站业务流量进行多维度检测和防护，结合深度机器学习智能识别恶意请求特征和防御未知威胁，阻挡诸如SQL注入或跨站脚本等常见攻击，避免这些攻击影响Web应用程序的可用性、安全性或过度消耗资源，降低数据被篡改、失窃的风险\nDBSS-数据库安全服务 数据库安全服务（Database Security Service）是一个智能的数据库安全防护服务，基于反向代理及机器学习机制，提供敏感数据发现、数据脱敏、数据库审计和防注入攻击等功能，保障云上数据库的安全\nCBH-云堡垒机：云运维审计的瑞士军刀 云堡垒机（Cloud Bastion Host）开箱即用，包含主机管理、权限控制、运维审计、安全合规等功能，支持Chrome等主流浏览器随时随地远程运维，开启高效运维新时代。\n案例 容灾备份 系统可靠性设计之高可用、双活、容灾、备份 容灾指标 RTO： RTO (Recovery Time Objectives)，关键业务功能（CBF）从中断点恢复到其最低业务连续目标（MBCO）所能承受的最大时间，从而使中断对业务所带领的冲击最小化。\nRPO： RPO (Recovery Point Objectives)，灾难恢复中的恢复时间点目标，指业务可接受的、灾难发生后，系统和数据从灾难发生时间点到可恢复至灾难前的时间点的目标。\nMBCO MBCO（Minimum Business Continuity Objectives），在突发事件、紧急状态、或灾难发生期间，企业为完成其业务目标所能接受的最低服务及生产水平。\n  标准 容灾方案 混合云容灾整体方案 4. GaussDB 5. 大数据 算存分离 解决方案 6. 解决方案 全览\n华为鲲鹏通用解决方案 华为鲲鹏行业解决方案 性能调优分析工具 Kunpeng Tuning Kit鲲鹏性能优化工具\n华为鲲鹏性能优化工具主要面向华为FAE、开放实验室能力建设工程师或客户工程师，针对应用程序部署在TaiShan服务器的场景下，通过收集服务器的处理器硬件、操作系统、进程/线程、函数等各层次的性能数据，分析出系统性能指标，定位到瓶颈点及热点函数。\n高性能计算 项目:个人同步网盘\n","description":"","id":21,"section":"talks","tags":["云计算"],"title":"鲲鹏Learning🏸","uri":"https://vhope.cf/zh/talks/kubpeng_exercise/"},{"content":"C++学习路线🌱 hode on!💠\n","description":"","id":22,"section":"talks","tags":["C++"],"title":"C++学习路线","uri":"https://vhope.cf/zh/talks/cpp_router/"},{"content":"| 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。\ngrep Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。\n语法 grep [选项] 查找内容 源文件 选项参数   -a --text #不要忽略二进制的数据。\n  -A\u0026lt;显示行数\u0026gt; --after-context=\u0026lt;显示行数\u0026gt; #除了显示符合范本样式的那一列之外，并显示该行之后的内容。\n  -b  --byte-offset  #在显示符合样式的那一行之前，标示出该行第一个字符的编号。⭐\n  -B\u0026lt;显示行数\u0026gt; --before-context=\u0026lt;显示行数\u0026gt; #除了显示符合样式的那一行之外，并显示该行之前的内容。\n  -c --count #计算符合样式的列数。⭐\n  -C\u0026lt;显示行数\u0026gt; --context=\u0026lt;显示行数\u0026gt;或-\u0026lt;显示行数\u0026gt; #除了显示符合样式的那一行之外，并显示该行之前后的内容。\n  -d \u0026lt;动作\u0026gt; --directories=\u0026lt;动作\u0026gt; #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。⭐\n  -e\u0026lt;范本样式\u0026gt; --regexp=\u0026lt;范本样式\u0026gt; #指定字符串做为查找文件内容的样式。\n  -E --extended-regexp #将样式为延伸的普通表示法来使用。\n  -f\u0026lt;规则文件\u0026gt; --file=\u0026lt;规则文件\u0026gt; #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。\n  -F --fixed-regexp #将样式视为固定字符串的列表。\n  -G --basic-regexp #将样式视为普通的表示法来使用。\n  -h --no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称。\n  -H --with-filename  #在显示符合样式的那一行之前，表示该行所属的文件名称。\n  -i --ignore-case  #忽略字符大小写的差别。⭐\n  -l --file-with-matches #列出文件内容符合指定的样式的文件名称。\n  -L --files-without-match #列出文件内容不符合指定的样式的文件名称。\n  -n --line-number #在显示符合样式的那一行之前，标示出该行的列数编号。\n  -q --quiet或--silent #不显示任何信息。\n  -r --recursive #此参数的效果和指定“-d recurse”参数相同。\n  -s --no-messages #不显示错误信息。\n  -v --revert-match #显示不包含匹配文本的所有行。\n  -V --version #显示版本信息。\n  -w --word-regexp #只显示全字符合的列。\n  -x --line-regexp #只显示全列符合的列。\n  -y #此参数的效果和指定“-i”参数相同。\n   其中标⭐号的为比较常实用的\n 查找内容规则 查找内容的规则与正则表达式大同小异。\n  ^ #锚定行的开始 如：\u0026lsquo;^grep'匹配所有以grep开头的行。\n  $ #锚定行的结束 如：\u0026lsquo;grep$'匹配所有以grep结尾的行。\n  . #匹配一个非换行符的字符 如：\u0026lsquo;gr.p'匹配gr后接一个任意字符，然后是p。\n  *#匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。\n  .* #一起用代表任意字符。\n  [] #匹配一个指定范围内的字符，如\u0026rsquo;[Gg]rep'匹配Grep和grep。\n  [^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。\n  \\(..\\) #标记匹配字符，如\u0026rsquo;(love)'，love被标记为1。\n  \\\u0026lt; #锚定单词的开始，如:'\u0026lt;grep'匹配包含以grep开头的单词的行。\n  \\\u0026gt; #锚定单词的结束，如\u0026rsquo;grep\u0026gt;'匹配包含以grep结尾的单词的行。\n  x\\{m\\} #重复字符x，m次，如：\u0026lsquo;0{5}\u0026lsquo;匹配包含5个o的行。\n  x\\{m,\\}  #重复字符x,至少m次，如：\u0026lsquo;o{5,}\u0026lsquo;匹配至少有5个o的行。\n  x\\{m,n\\} #重复字符x，至少m次，不多于n次，如：\u0026lsquo;o{5,10}\u0026lsquo;匹配5\u0026ndash;10个o的行。\n  \\w  #匹配文字和数字字符，也就是[A-Za-z0-9]，如：\u0026lsquo;G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。\n  \\W  #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。\n  \\b  #单词锁定符，如: \u0026lsquo;\\bgrep\\b'只匹配grep。\n  在/etc/profile文件中查找关键字CLASS_PATH所在位置\n查询ssh相关进程\n压缩解压类命令 gzip/gunzip gzip用于压缩文件，gunzip用于解压\n语法：\ngzip文件名（功能描述：压缩文件，只能将文件压缩为*.gz文件）\ngunzip 文件名(.gz结尾)：(功能描述：解压缩文件命令）\n压缩b.txt文件\n解压b.txt.gz压缩文件\nzip/unzip zip用于压缩文件，unzip用于解压的，这个在项目打包发布中很有用的.\n语法：\nzip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）\nunzip [选项] XXX.zip (功能描述：解压缩文件）\n加密a.txt文件\n解密a.zip文件\ntar tar指令是打包指令，最后打包后的文件可以是.tar.gz的文件。\n语法：\ntar [选项] XXX.tar.gz 打包的内容（功能描述：打包目录，压缩后的文件格式tar.gz)\n选项参数：\n  -A 新增压缩文件到已存在的压缩\n  -B 设置区块大小\n  -c 建立新的压缩文件\n  -d 记录文件的差别\n  -r 添加文件到已经压缩的文件\n  -u 添加改变了和现有的文件到已经存在的压缩文件\n  -x 从压缩的文件中提取文件\n  -t 显示压缩文件的内容\n  -z 支持gzip解压文件\n  -j 支持bzip2解压文件\n  -Z 支持compress解压文件\n  -v 显示操作过程\n  -l 文件系统边界设置\n  -k 保留原有文件不覆盖\n  -m 保留文件不被覆盖\n  -W 确认压缩文件的正确性\n  可选参数如下：\n  -b 设置区块数目\n  -C 切换到指定目录\n  -f 指定压缩文件\n  --help 显示帮助信息\n  --version 显示版本信息\n  实例：\n打包/victor文件夹下所有内容，打包后的文件名为victor.tar\n解压victor.tar文件\n打包文件夹/victor并且压缩成data.tar.gz\n将多个文件压缩成a.tar.gz\n将a.tar.gz解压到当前目录\n解压到文件夹/a(文件夹必须存在，不然报错)\n![](https://i.loli.net/2020/04/16/xALa9JldzXuBjRi.png\n https://www.cnblogs.com/peida/archive/2012/12/17/2821195.html https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html https://www.cnblogs.com/peida/archive/2012/12/06/2804323.html ","description":"","id":23,"section":"posts","tags":["Linux","grep","tar","gzip"],"title":"Linux实用指令","uri":"https://vhope.cf/zh/posts/linux-grep/"},{"content":"每一个用户都是一个个体，每一个个体都属于一个群组，而每一个群组又有区别!\n——Users\n Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n 添加用户 基本语法 useradd [选项] 用户名 实操 输入以下命令之后创建一个用户victor\n这里我们选项参数什么也没有写，此时会默认在/home目录下创建一个/victor的文件夹用于保存用户victor用户的数据信息。\n当然我们可以指定参数：\n用参数 -d 目录指定用户信息存储的目录，使用命令useradd -d /home/test tom创建用户tom。\n使用-g 用户组指定将当前创建的用户添加到指定的用户组，使用命令useradd -g root wjh将新建用户wjh添加到root用户组。\n给用户设置密码 基本语法 passwd 用户名 实操 给用户victor设置密码(默认密码是不会显示出来的)\n下面可以使用victor这个用户登陆\n默认是不能访问root用户的文件的，因为不在同一个组\n切换用户 基本语法 su - 切换用户名 实操 切换到root。其中低权限用户切换到高权限用户需要输入密码。\n退出切换使用exit删除用户 基本语法 userdel [选项] 用户名 其中选项参数可以添加-r，表示删除用户时同时删除保存用户的文件夹。\n实操 删除用户tom\n可以看到之前tom致电给创建的文件夹test并没有删除。\n 注意，删除用户必须要root权限，不然删除不了。\n 删除用户victor，同时删除其文件夹，victor文件夹消失了\n其他操作 查询用户信息 语法\nid 用户名 如下查询用户root的信息\nroot用户的用户id为0，组id为0，组为0\n查询当前用户 语法\nwhoami 用户组  类似于角色，系统可以对有共性的多个用户进行统一的管理。\n 用户组关系图：\n增加组 语法\ngroupadd 组名 增加用户组test\n删除组 语法\ngroupdel 组名 删除用户组test\n修改用户的组 语法\nusermod -g 用户组 用户名 相关配置文件  用户信息文件：/etc/passwd 密码文件： /etc/shadow 用户组文件：/etc/group 用户组密码文件： /etc/gshadow 用户配置文件：\n/etc/login.defs\n/etc/default/useradd 新用户信息文件：/etc/skel 登录信息：/etc/motd  /etc/passwd 每一行内容存放一个用户的信息，每个用户信息有7部分组成\nroot​：x:0:0:root:/root:/bin/bash\nroot 用户名 用户登录系统时使用的用户名\nx 密码 密码位\n2 UID 用户标识号\n2 GID 缺省组标识\nroot 注释性描述 例如存放用户全名等信息\n/root 宿主目录 用户登录系统后的缺省目录\n/bin/bash 命令解释器 用户使用的Shell ,默认为bash\n UID分类\n超级用户：（root UID=0）\n普通用户： （UID 500~60000）\n伪用户： （UID 1~499）\n什么是伪用户?\n 伪用户与系统和程序服务相关  bin、daemon、shutdown、halt等，任何Linux系统默认都有这些伪用户。\nmail、news、games、apache、ftp、mysql及sshd等，与linux系统的进程相关。\n 伪用户通常不需要或无法登录系统\n  可以没有宿主目录\n   /etc/shadow 每行的含义： 登录名: 加密口令: 最后一次修改时间: 最小时间间隔: 最大时间间隔:警告时间: 不活动时间: 失效时间:标志\n/etc/group 每行含义： 组名: 口令: 组标识号: 组内用户列表\n https://www.cnblogs.com/qmfsun/p/3674024.html linux用户管理命令 ","description":"","id":24,"section":"posts","tags":["Linux","用户管理"],"title":"Linux用户管理","uri":"https://vhope.cf/zh/posts/linux-users/"},{"content":"在大学时代，Vim 的大名就已如雷贯耳，但由于它陡峭的学习曲线，一直望而却步。等真正开始学习之后，发现并没有想象中的复杂，也没有所谓的瓶颈，只要在实际写代码中强迫自己使用就可以了，无形中就会形成习惯。\n​\t——GeekPlux\n三种模式 正常模式 以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。正常模式可以使用快捷键。\n编辑模式 按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可.\n命令行模式 在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的。\n vi 和vim模式的相互切换\n 常用快捷键  使用快捷键在正常模式下输入！\n 复制粘贴 拷贝当前行输入yy，然后再按下p键的时候就可以粘贴了。\n复制多行可以输入nyy，其中n为一个数字，例如5yy，即复制当前行向下的5行，同样粘贴也是按p键。\n删除 删除当前行输入dd\n删除多行输入ndd，表示删除当前行向下的n行。\n查找单词 再正常模式下输入/关键字即可查找关键字所在的位置，例如/hello为查找hello这个单词所有的所在位置，输入 n 就是查找下一个。\n设置文件行号 有时候为了看文档更清楚，想要知道每一行的行数，可以先进入命令模式，在输入set nu，即再正常模式下输入:set nu,然后回车。\n取消行号可以输入:set nonu\n移动到底部到首部 有时候需要直接看文档的末尾，可以输入G移动到文件末行。\n而移动到首行则是输入gg，然后回车即可。\n撤销 取消上一次做的操作，输入u。表示undo。\n移动到某行 假如我们要移动到第20行，我们可以这样输入：20 + shift + g\n更多快捷键可以参考：https://zhuanlan.zhihu.com/p/77283813\nVim键盘图\n思维导图：\n","description":"","id":25,"section":"posts","tags":["Linux","Vim"],"title":"Linux编辑利器-Vim","uri":"https://vhope.cf/zh/posts/linux/vim-use/"},{"content":"问题描述 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n输入: \u0026quot;babad\u0026quot; 输出: \u0026quot;bab\u0026quot; 注意: \u0026quot;aba\u0026quot; 也是一个有效答案。 示例 2：\n输入: \u0026quot;cbbd\u0026quot; 输出: \u0026quot;bb\u0026quot; 解答 使用动态规划，把原来的字符串倒置，然后找最长的公共子串就可以了。例如 S = \u0026ldquo;caba\u0026rdquo; ，S = \u0026ldquo;abac\u0026rdquo;，最长公共子串是 \u0026ldquo;aba\u0026rdquo;，所以原字符串的最长回文串就是 \u0026ldquo;aba\u0026rdquo;。其中求最大公共子串就是使用动态规划的方法。\n示意图：\n 当S[i]==S[j]时，矩阵arr[i][j]=arr[i-1][j-1]+1；特殊情况i、j为0时arr[i][j]=1 其他情况跳过。   另外，还需要考虑最长公共子串不是回文的情况，只需要判断翻转前后的末尾字符下标是否一样即可，比如 S=\u0026quot;caba\u0026rdquo;，S'=\u0026quot;abac\u0026rdquo; ，S’ 中 aba 的下标是 0 1 2 ，倒置前是 3 2 1，和 S 中 aba 的下标符合，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。\n 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;class Solution { public: string longestPalindrome(string s) { //暴力法  int len = s.length(); if (len \u0026lt;= 1) return s; std::string r; std::string real = s; reverse(s.begin(), s.end()); std::string reverse = s; int arr[len][len]; for (int i = 0; i \u0026lt; len; ++i) for (int j = 0; j \u0026lt; len; ++j) arr[i][j] = 0; int maxLen(0), maxEnd(0); for (int i = 0; i \u0026lt; len; ++i) { for (int j = 0; j \u0026lt; len; ++j) { if (real[i] == reverse[j]) { if (i == 0 || j == 0) arr[i][j] = 1; else { arr[i][j] = arr[i - 1][j - 1] + 1; } } if (arr[i][j] \u0026gt; maxLen) { int beforeindex = len - 1 - j; if ((beforeindex + arr[i][j] - 1) == i) { maxLen = arr[i][j]; maxEnd = i; } } } } return real.substr(maxEnd - maxLen + 1, maxLen); } };   结果： ","description":"","id":26,"section":"posts","tags":["C++","leetcode"],"title":"Leetcode-最长回文子串","uri":"https://vhope.cf/zh/posts/leetcode-0/"},{"content":"Linux基本操作。🤠\nLinux 目录结构及解释 查看命令行执行完位置：\n1  echo $BASH   命令记录 mkdir mkdir命令 用来创建目录。\n语法：mkdir (选项)(参数)\n 主要选项：\n-m\u0026lt;目标属性\u0026gt;或\u0026ndash;mode\u0026lt;目标属性\u0026gt;建立目录的同时设置目录的权限；\n-p或\u0026ndash;parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；\n参数：\n指定要创建的目录列表，多个目录之间用空格隔开。\n 创建多层目录：\n1  mkdir a/b/c/d   chmod chmod命令用来变更文件或目录的权限。\n语法：chmod(选项)(参数)\n权限范围的表示法如下：\nu User，即文件或目录的拥有者；\ng Group，即文件或目录的所属群组；\no Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；\na All，即全部的用户，包含拥有者，所属群组以及其他用户；\nr 读取权限，数字代号为“4”;\nw 写入权限，数字代号为“2”；\nx 执行或切换权限，数字代号为“1”；\n- 不具任何权限，数字代号为“0”；\ns 特殊功能说明：变更文件或目录的权限。\n例子：\n1 2 3 4  chmod u+x,g+w f01　//为文件f01设置自己可以执行，组员可以写入的权限 chmod u=rwx,g=rw,o=r f01 chmod 764 f01 chmod a+x f01　//对文件f01的u,g,o都设置可执行属性   可以输入命令ll -d 文件名查看文件的权限：\nlinux文件的用户权限的分析图\n例：rwx　rw-　r\u0026ndash;\nr=读取属性　//值＝4\nw=写入属性　//值＝2\nx=执行属性　//值＝1\n对demo.sh执行chmod a+x demo.sh之后，查看其权限，三个组都含x，表示所有用户都能执行：\nShell脚本 shell脚本一般以.sh结尾。如demo.sh：\n1 2 3  #!/bin/bash #This is my First shell echo \u0026#34;Hello World!\u0026#34;    第一行表示脚本的位置\n第二行为注释\n第三行为脚本的命令\n 如何执行？在Linux下需要先赋予权限\n1  chmod o+x demo.sh   执行\n1  ./demo.sh   常见的变量\n$0当前程序的名称\n$n当前程序的第 n 个参数,n=1,2,…9\n$* 当前程序的所有参数(不包括程序本身)\n$# 当前程序的参数个数(不包括程序本身)\n$? 命令或程序执行完后的状态，一般返回 0 表示执行成功。\n$UID 当前用户的 ID\n$PWD 当前所在的目录\nIf 条件判断语句 格式：\n1 2 3 4 5  if (表达式) #if ( Variable in Array ) 语句 1 else 语句 2 fi   例：\n1 2 3 4 5  #!/bin/sh NUM=100 if (( $NUM \u0026gt; 4 )) ;then echo “this num is $NUM greater 4 !” fi   参考：\n https://wangchujiang.com/linux-command/ ","description":"","id":27,"section":"posts","tags":["Linux","Shell","bash"],"title":"Linux命令与Shell","uri":"https://vhope.cf/zh/posts/linux/linux-shell/"},{"content":"Docker是基于内核的容器,可以运行在宿主机上,看作是一个容器.\nDocker🐋 安装配置 略,可以百度搜索.如下:\nhttps://juejin.im/post/5dc241ce6fb9a04aa333c1bd\n基本使用 安装完成之后,可以使用以下命令查看版本\n1  docker version   拉取并且运行hello-world镜像进行测试\ndocker run hello-world 查看本地镜像:\ndocker image ls 本地有一个hello-world镜像\nImage的获取 1. 从Dockerfile制作 2. 从Register拉取(Pull from Register) 例如:\n1  docker pull ubuntu:14.04   可以在DockerHub里面搜索相关的镜像\n添加Docker用户权限，创建docker组\n1  sudo groupadd docker   1  sudo gpasswd -a vagrant docker   1  sudo service docker restart   最后重新登陆服务器即可\n自定义image 构建一个输出信息的C语言编译的可执行文件镜像\n首先编写C文件,如下:\n1 2 3 4 5 6  #include \u0026lt;stdio.h\u0026gt;int main(){ printf(\u0026#34;Hello,Docker!\\n\u0026#34;); return 0; }   安装gcc及相关库:\n1 2  sudo yum install gcc sudo yum install glibc-static   编译:\n1  gcc -static hello.c -o hello   在当前文件夹下创建Dockerfile\n1  vim Dockerfile   编写下面的内容\n1 2 3  FROM scratch ADD hello / CMD [\u0026#34;/hello\u0026#34;]   使用docker构建:\n1  docker build -t victorhong/hello .   其中victorhong是用户名,hello是镜像名,.表示当前文件夹下的内容\n构建完可以查看到镜像:\n查看构建的历史\n运行容器\ndocker run victorhong/hello Container 什么是container?\n查看container\n1  docker container ls   查看所有cpntainer,包括结束的\n1  docker container ls -a   运行ubuntu:16.04是马上就会结束的,要想交互式的执行容器,使用以下的mingl\n1  docker run -it ubuntu:16.04   另外开一个窗口,查看container\n1  docker container ls   可以看到有一个ubuntu容器正在运行\n构建自己的Docker镜像   docker container commit\n1  docker commit clever_franklin victorhong/centos-vim   在对容器进行修改了之后,clever_franklin为容器名,victorhong/centos-vim为提交的镜像名\n  Dockerfile build\n1 2  FROMcentosRUN yum install -y vim  然后执行\n1  docker build -t victorhong/centos-vim-new .     Dockerfile语法 FROM 定义base image\nLabel 定义数据信息,类似注释\n Metadata不可少\n RUN 每执行一次run,都会新建一层,尽量少用多次run\nWORKDIR 设定当前工作目录,类似cd\n 注意:\n ADD and COPY ADD还有解压功能\nENV 设置环境变量或者常量变量\n尽量使用ENV增加可维护性\nVOLUME ADN EXPOSE VOLUME用于挂载数据卷，EXPOSE用于暴露端口\nCMD and ENTRYPOINT 区别:\n执行命令格式:\nGitHub上的官方Dockerfile\n镜像的发布 使用DockerHub去push\n登陆docker\n1  docker login   push\n1  docker push victorhongdream/hello:latest   查看DockerHub\n","description":"","id":28,"section":"posts","tags":["docker"],"title":"入门Docker","uri":"https://vhope.cf/zh/posts/docker-begin/"},{"content":"C++特性之多态🍄\n静态类型 是指不需要考虑表达式的执行期语义，仅分析程序文本而决定的表达式类型。\n动态类型 是指由一个左值表达式表示的左值所引用的最终派生对象的类型。\n动态绑定与静态绑定 **静态绑定：**编译时绑定，通过对象调用\n**动态绑定：**运行时绑定，通过地址实现\n何时使用动态绑定?\n 只有采用“指针-\u0026gt;函数()”或“引用变量.函数()”的方式调用C++类中的虚函数才会执行动态绑定。 对于C++中的非虚函数，因为其不具备动态绑定的特征，所以不管采用什么样的方式调用，都不会执行动态绑定。   总的来所,动态绑定执行的函数只针对虚函数,执行虚函数会动态执行,而非虚函数就直接执行基类类型的函数,也就是说指针类型是什么，就会调用该类型相应的函数。\n 例如下面的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include \u0026lt;iostream\u0026gt;using namespace std; class Base { public: void func() { cout \u0026lt;\u0026lt; \u0026#34;func() in Base.\u0026#34; \u0026lt;\u0026lt; endl; } virtual void test() { cout \u0026lt;\u0026lt; \u0026#34;test() in Base.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { void func() { cout \u0026lt;\u0026lt; \u0026#34;func() in Derived.\u0026#34; \u0026lt;\u0026lt; endl; } virtual void test() { cout \u0026lt;\u0026lt; \u0026#34;test() in Derived.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base *b; b = new Derived(); b-\u0026gt;func(); b-\u0026gt;test(); }   输出为:\nfunc() in Base. test() in Derived. 再例如下面的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class A { public: virtual void func(int val = 1) { std::cout\u0026lt;\u0026lt;\u0026#34;A-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} virtual void test() { func();} }; class B : public A { public: void func(int val=0) {std::cout\u0026lt;\u0026lt;\u0026#34;B-\u0026gt;\u0026#34;\u0026lt;\u0026lt;val \u0026lt;\u0026lt;std::endl;} }; int main(int argc ,char* argv[]) { B*p = new B; p-\u0026gt;test(); return 0; }   输出为: B-\u0026gt;1\n test()是虚函数,p-\u0026gt;test()会动态调用B类中的test()函数,并且,还需要记住一个结论:virtual 函数是动态绑定，而缺省参数值却是静态绑定,绝不重新定义继承而来的缺省参数值！\n 虚函数、动态绑定、运行时多态之间的关系 要触发动态绑定，需满足两个条件：\n  只有虚函数才能进行动态绑定，非虚函数不进行动态绑定。\n  必须通过基类类型的引用或指针进行函数调用。\n  简单地说，虚函数是动态绑定的基础；动态绑定是实现运行时多态的基础。\n https://blog.csdn.net/iicy266/article/details/11906509 C++中的动态类型与动态绑定、虚函数、运行时多态的实现 ","description":"","id":29,"section":"posts","tags":["C++","多态"],"title":"C++动态与静态","uri":"https://vhope.cf/zh/posts/cpp-duotai/"},{"content":"c文件读写🗃\nFILE对象结构体 1 2 3 4 5 6 7 8  typedef struct { int _fd; // 文件号  int _cleft; // 缓冲区中剩下的字节数  int _mode; // 文件操作模式  char * _nextc; // 下一个字节的位置  char * _buff; // 文件缓冲区位置 }FILE;   打开文件 可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：\n1  FILE *fopen( const char * filename, const char * mode );   mode 的值可以是r,w,a,,r+,w+,a+:\n   r 打开一个已有的文本文件，允许读取文件。     w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。   a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。   r+ 打开一个文本文件，允许读写文件。   w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。   a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。    如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：\n1  \u0026#34;rb\u0026#34;, \u0026#34;wb\u0026#34;, \u0026#34;ab\u0026#34;, \u0026#34;rb+\u0026#34;, \u0026#34;r+b\u0026#34;, \u0026#34;wb+\u0026#34;, \u0026#34;w+b\u0026#34;, \u0026#34;ab+\u0026#34;, \u0026#34;a+b\u0026#34;     关闭文件 关闭文件非常简单,只需要调用**fclose()**函数即可,其中参数就是指向文件对象的指针.\n1  int fclose( FILE *fp );   如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。  demo 1 2 3 4 5 6 7 8 9 10 11 12 13  void open_close_file(){ char fname[10]; printf(\u0026#34;pease input file name: \u0026#34;); scanf(\u0026#34;%s\u0026#34;,fname); FILE *p = fopen(fname,\u0026#34;r+\u0026#34;); if(p == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return ; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;,fname); fclose(p); printf(\u0026#34;file %s had be closed!\\n\u0026#34;,fname); }   读取文件 读取单个字符的最简单的函数:\n1  int fgetc( FILE * fp );   读取多个字符的函数(也可以读取单个字符):\n1  char *fgets( char *buf, int n, FILE *fp );   fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。\n函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。\n 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void read_file_demo() { char fname[10] = \u0026#34;basic.sql\u0026#34;; FILE *fp = fopen(fname, \u0026#34;r+\u0026#34;); if (fp == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;, fname); char ch; int n = 5; printf(\u0026#34;\\nusing fgetc()......\\n\u0026#34;); while (n--) { ch = fgetc(fp); if(ch != EOF) printf(\u0026#34;char = %c\\n\u0026#34;, ch); } char str[20]; printf(\u0026#34;\\nusing fgets()......\\n\u0026#34;); fgets(str,20,fp); printf(\u0026#34;str[20] = %s\\n\u0026#34;,str); fclose(fp); printf(\u0026#34;file %s had be closed!\\n\u0026#34;, fname); }   读取二进制输入:\n1  size_t fread(void *buffer, size_t size, size_t count, FILE * stream);    buffer为接收数据的地址，size为一个单元的大小，count为单元个数，stream为文件流。\n返回实际读取的单元个数。如果小于count，则可能文件结束或读取出错；可以用ferror()检测是否读取出错，用feof()函数检测是否到达文件结尾。如果size或count为0，则返回0。\n 写入文件 写入单个字符的最简单的函数:\n1  int fputc( int c, FILE *fp );   写入多个字符的函数(也可以写入单个字符):\n1  int fputs( const char *s, FILE *fp );   函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。\n函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。\n 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void write_file_demo() { char fname[10] = \u0026#34;test.txt\u0026#34;; FILE *fp = fopen(fname, \u0026#34;w+\u0026#34;); if (fp == NULL) { printf(\u0026#34;file open fail!\\n\u0026#34;); return; } printf(\u0026#34;file %s open sucessful!\\n\u0026#34;, fname); char ch; int n = 5; printf(\u0026#34;\\nusing fputc()......\\n\u0026#34;); while (n--) { ch = (char)(100+n); if((ch = fputc(ch,fp)) != EOF) printf(\u0026#34;char %c write successful!\\n\u0026#34;,ch); } char str[30] = \u0026#34;\\nIt`s a test for write!\u0026#34;; printf(\u0026#34;\\nusing fputs()......\\n\u0026#34;); int r = fputs(str,fp); if(r \u0026gt;= 0) printf(\u0026#34;str[30] = %s write successful!\\n\u0026#34;,str); fclose(fp); printf(\u0026#34;file %s had be closed!\\n\u0026#34;, fname); }   二进制输出:\n1  size_t fwrite(void * buffer, size_t size, size_t count, FILE * stream);    buffer为数据源地址，size为每个单元的字节数，count为单元个数，stream为文件流指针。\n返回成功写入的单元个数。如果小于count，则说明发生了错误，文件流错误标志位将被设置，随后可以通过ferror()函数判断。\n 参考:\n https://www.runoob.com/cprogramming/c-file-io.html ","description":"","id":30,"section":"posts","tags":["C","文件读写"],"title":"C文件读写","uri":"https://vhope.cf/zh/posts/c-read-write/"},{"content":"在markdown文件中嵌入html代码.🛶\n使用自定义文字样式 输入代码:\n1  \u0026lt;span style=\u0026#34;font-size:2rem; background:yellow;\u0026#34;\u0026gt;**Bigger**\u0026lt;/span\u0026gt;   Bigger\n设置键盘按键 输入代码:\n1  \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;F9\u0026lt;/kbd\u0026gt;   Ctrl+F9\n其他网站摘录的html 1  \u0026lt;blockquote class=\u0026#34;twitter-tweet\u0026#34;\u0026gt;\u0026lt;p lang=\u0026#34;en\u0026#34; dir=\u0026#34;ltr\u0026#34;\u0026gt;Sunsets don\u0026amp;#39;t get much better than this one over \u0026lt;a href=\u0026#34;https://twitter.com/GrandTetonNPS?ref_src=twsrc%5Etfw\u0026#34;\u0026gt;@GrandTetonNPS\u0026lt;/a\u0026gt;. \u0026lt;a href=\u0026#34;https://twitter.com/hashtag/nature?src=hash\u0026amp;amp;ref_src=twsrc%5Etfw\u0026#34;\u0026gt;#nature\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://twitter.com/hashtag/sunset?src=hash\u0026amp;amp;ref_src=twsrc%5Etfw\u0026#34;\u0026gt;#sunset\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;http://t.co/YuKy2rcjyU\u0026#34;\u0026gt;pic.twitter.com/YuKy2rcjyU\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026amp;mdash; US Department of the Interior (@Interior) \u0026lt;a href=\u0026#34;https://twitter.com/Interior/status/463440424141459456?ref_src=twsrc%5Etfw\u0026#34;\u0026gt;May 5, 2014\u0026lt;/a\u0026gt;\u0026lt;/blockquote\u0026gt; \u0026lt;script async src=\u0026#34;https://platform.twitter.com/widgets.js\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   Sunsets don\u0026#39;t get much better than this one over @GrandTetonNPS. #nature #sunset pic.twitter.com/YuKy2rcjyU\n\u0026mdash; US Department of the Interior (@Interior) May 5, 2014 ","description":"","id":31,"section":"posts","tags":["markdown","html"],"title":"在markdown使用html","uri":"https://vhope.cf/zh/posts/markdown-html/"},{"content":"TCP/IP编程\n  目标:  能进行网络编程\n1.如果你说你会select,epoll,iocp模型,那会让对方觉得更靠谱\n2.如果你说出你做过im,下载之类那会让对方来兴趣.\n3.如果你说设计了通讯协议,会让对方觉得更贴切\n4.如果你说做过,熟悉, ftp http snmp smtp 这些简单的老古董协议,会加分,但不大.\n5.如果你说熟悉bt,emule,udt等协议,那会对你很有好感.\n6.如果你说你破解过某大牌 qq,360内某通讯协议,那会对你加分很大.\n阶段:\n1)熟悉TCP/IP协议族的基本原理\nIP地址的分类，定义，获得，大概的管理方法\nTCP、UDP等主要协议的特点，主要格式，以及重要字段在协议交互中起到的作用。\n2）对于简单的TCP/IP协议导致的问题，有基本的判断\n熟悉网络问题的解决方法，一个问题，应该是由上而下（top-button），还是由下而上（button-top）来分析？\n3）基本的编程知识。\n在系统内，构建简单通信。\n在系统间，构建简单的通信。\n熟悉系统内的API，知道在什么时候，改使用哪些API协调工作。\n能够熟练使用这些API，在系统间传递信息，文件。\n能够熟练使用这些API，实现自己的简单的私有协议。\n4）进阶编程知识\n知道一两个已经封装好的框架（framwork），它们之间的差别。\n使用一个框架，写过能正常工作的程序。\n知道网络协议处理也是要讲究性能的，知道性能的瓶颈会在什么地方产生。\n能有较好的设计技巧，将私有协议设计得更加具有弹性，优雅。\n熟悉系统间协议处理的细微的差异，以及将会对业务造成的影响，时延、状态不一致、自定义字段、、、、、\n5）熟练阶段的知识\n针对业务的需求，快速选型，定框架。\n不再认为多线程是万能的。\n知道稳定性比性能更加重要。\n数据包去了哪儿，不用看代码，也能预估出来。\n6）源代码是最好的老师，永远都是。\n以上，差不多或者已经达到4）的时候，就是“熟悉”了。\n  网络模型 OSI模型 TCP/IP模型 示例 协议对应 数据封装 C++UDP/TCP实例 套接字 为了区分不同应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP交互提供了称为**嵌套字(Socket)**的接口。\n常用的TCP/IP有以下三种类型的嵌套字：\n  流式嵌套字（SOCK_STREAM）\n用于提供面向连接的、可靠的数据传输服务，即使用TCP进行传输。\n  数据报嵌套字（SOCK_DGRAM）\n用于提供无连接的服务，即使用UDP进行传输。\n  原始嵌套字（SOCK_RAW\n可以读写内核没有处理的IP数据报，而流式嵌套字只能读取TCP的数据，数据报嵌套字只能读取UDP的数据.\n   如果要访问其它协议发送的数据必须使用原始嵌套字，它允许对底层协议(如IP或ICMP)直接访问\n 端口对应进程 单单之后ip地址还不足以辨识通信的两个进程,因为操作系统是并发的,使用端口来辨认某个进程.所以套接字必须的两个信息为: ip地址 + 端口,例如: 192.168.1.4 1500\n参考:\n https://www.jianshu.com/p/c1015f5ffa74 进程间通信 https://segmentfault.com/a/1190000003063859 Linux IO模式及 select、poll、epoll详解 https://cloud.tencent.com/developer/article/1373483 各种IO复用模式之select，poll，epoll，kqueue，iocp分析 ","description":"","id":32,"section":"posts","tags":["tcp","udp","网络"],"title":"Udp-Tcp编程","uri":"https://vhope.cf/zh/posts/udp-tcp/"},{"content":"每次push都需要输入用户名和密码,其实可以免去这些操作.🚛\n1. 使用.git-credentials文件 在git项目目录下新建.git-credentials这个文件,然后在里面填写下面内容(大括号不用填写):\nhttps://{username}:{password}@github.com 然后在git项目目录执行:\n1  git config --global credential.helper store   执行此命令后，用户主目录下的.gitconfig文件会多了一项：[credential]\nhelper = store  注意: Linux用户主目录一般在~/下,而Windows下一般为C:\\users\\Administrator\n 这样以后push就不需要用户名和密码了\n2. 使用ssh协议 首先生成密钥对,执行\n1  ssh-keygen -t rsa -C \u0026#34;youremail\u0026#34;   接下来按照提示操作，默认可以一路往下。\n然后将生成的位于~/.ssh/的id_rsa.pub的内容复制到你github setting里的ssh key中。\n复制之后，如果你还没有克隆你的仓库，那你直接使用ssh协议用法：git@github.com:yourusername/yourrepositoryname克隆就行了。\n如果已经使用https协议克隆了，那么按照如下方法更改协议：\ngit remote set-url origin git@github.com:yourusername/yourrepositoryname.git\nDone!\n3. 管理多git账号 参考:\n https://www.jianshu.com/p/f7f4142a1556 简书 https://segmentfault.com/a/1190000012432367 https://juejin.im/post/5d6a23d45188252bd90f601a 掘金 https://www.cnblogs.com/popfisher/p/5731232.html ","description":"","id":33,"section":"posts","tags":["git","github"],"title":"Git免密push","uri":"https://vhope.cf/zh/posts/git-push-no-pw/"},{"content":"AES算法是继DES之后比较快且比较简单的加密算法.⚖\nAES算法 算法原理： AES密码与分组密码Rijndael基本上完全一致，Rijndael分组大小和密钥大小都可以为128位、192位和256位。然而AES只要求分组大小为128位，因此只有分组长度为128Bit的Rijndael才称为AES算法。\n下面是分组长度为128位的AES算法,而key位数可以是128/192/256,本次实验选择key的大小位128位.\n特点  明文分组被描述为一个字节方阵并复制到状态数组，在每轮替换和移位时都并行处理整个状态分组。 矩阵中字节的顺序是按列排序的，例如128比特的明文分组的前4个字节占输入矩阵的第一列，接下来的4个字节占第二列，依次类推。扩展子密钥数组也类似操作。 假设AES使用128比特的密钥，其密钥被描述为一个字节方阵并将扩展成为一个子密钥数组w[i]（具有44个32比特字），4个不同的字（共128比特）用作每轮的轮密钥。 AES在每轮运算中将进行4个不同的步骤，1个是移位，3个是替换。  数学知识 在AES算法中的MixColumn层中会用到伽罗瓦域中的乘法运算，而伽罗瓦域的运算涉及一些数学知识。\n素域 有限域有时也称伽罗瓦域，它指的是由有限个元素组成的集合，在这个集合内可以执行加、减、乘和逆运算。而在密码编码学中，我们只研究拥有有限个元素的域，也就是有限域。域中包含元素的个数称为域的阶。只有当m是一个素数幂时，即$m=p^n$(其中n为正整数是p的次数，p为素数)，阶为m的域才存在。p称为这个有限域的特征。\n例如，有限域中元素的个数可以是11(p=11是一个素数,n=1)、可以是81(p=3是一个素数，n=4)、也可以是256(p=2是一个素数，n=8)\u0026hellip;..但有限域的中不可能拥有12个元素，因为12=2·2·3，因此12也不是一个素数幂。因此满足p是一个素数且满足$m = p^n$这个公式，m才是一个素数幂。\n有限域中最直观的例子就是阶为素数的域，即n=1的域。域GF(p)的元素可以用整数0、1、\u0026hellip;、p-1l来表示。域的两种操作就是模整数加法和整数乘法模p。加上p是一个素数，整数环Z表示为GF(p)，也成为拥有素数个元素的素数域或者伽罗瓦域。GF(p)中所有的非零元素都存在逆元，GF(p)内所有的运算都是模p实现的。\n素域内的算数运算规则如下  加法和乘法都是通过模p实现的； 任何一个元素a的加法逆元都是由a+(a的逆元)=0 mod p得到的； 任何一个非零元素a的乘法逆元定义为a·a的逆元=1。  举个例子，在素域GF(5)={0、1、2、3、4}中，2的加法逆元为3，这是因为2+(3)=5，5mod5=0,所以2+3=5mod5=0。2的乘法逆元为3，这是因为2·3=6，6mod5=1，所以2·3=6mod5=1。(在很多地方a的加法逆元1用$-a$表示，a的乘法逆元2用$1/a$表示)\n 注：GF(2)是一个非常重要的素域，也是存在的最小的有限域，由于GF(2)的加法，即模2加法与异或(XOR)门等价，GF(2)的乘法与逻辑与(AND)门等价，所以GF(2)对AES非常重要。\n模2加法与异或(XOR)门等价:\n$$\n(1 + 0) \\mod 2 = 1\\\\\n(0 + 1) \\mod 2 = 1\\\\\n(0 + 0) \\mod 2 = 0\\\\\n(1 + 1) \\mod 2 = 0\\\\\n$$\n乘法与逻辑与(AND)门等价:\n$$\n(1 \\times 0) \\mod 2 = 0\\\\\n(0 \\times 1) \\mod 2 = 0\\\\\n(0 \\times 0) \\mod 2 = 0\\\\\n(1 \\times 1) \\mod 2 = 1\\\\\n$$\n 扩展域 如果有限域的阶不是素数，则这样的有限域内的加法和乘法运算就不能用模整数加法和整数乘法模p表示。而且m\u0026gt;1的域被称为扩展域，为了处理扩展域，我们就要使用不同的符号表示扩展域内的元素，使用不同的规则执行扩展域内元素的算术运算。\n在扩展域$GF(2^m)$中，元素并不是用整数表示的，而是用系数为域$GF(2)$中元素的多项式表示。这个多项式最大的度(幂)为m-1​，所以每个元素共有m个系数，在AES算法使用的域$GF(2^8)$中，每个元素$A∈GF(2^8)$都可以表示为：\n$$\nA(x) = a_7x^7 + a_6x^6 + a_5x^5 + a_4x^4 + a_3x^3 + a_2x^2+a_1x + a_0,x_i \\in GF(2) = 0,1\n$$\n注意：在域GF(2^8)中这样的多项式共有256个，这256个多项式组成的集合就是扩展域GF(2^8)。每个多项式都可以按一个8位项链的数值形式存储：\n$$\nA = (a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0)\n$$\n像$x^7$、$x^6$等因子都无需存储，因为从位的位置就可以清楚地判断出每个系数对应的幂。\n扩展域$GF(2^m)$内的加减法 在AES算法中的密钥加法层中就使用了这部分的知识，但是不是很明显，因为我们通常把扩展域中的加法当作异或运算进行处理了，因为在扩展域中的加减法处理都是在底层域GF(2)内完成的，与按位异或运算等价。假设$A(x)$、$B(x)∈GF(2^m)$，计算两个元素之和的方法就是：\n$$\nC(x) = A(x) + B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i + b_i) \\mod 2\n$$\n而两个元素之差的计算公式就是：\n$$\nC(x) = A(x) - B(x) = \\sum_{i=0}^{m-1}C_ix^i , c_i = (a_i - b_i) \\mod 2 = (a_i + b_i) \\mod 2\n$$\n 注：在减法运算中减号之所以变成加号，这就和二进制减法的性质有关了，大家可以试着验算下。从上述两个公式中我们发现在扩展域中加法和减法等价，并且与XOR等价(异或运算也被称作二进制加法)。\n 扩展域GF(2^m)内的乘法 扩展域的乘法主要运用在AES算法的列混淆层(Mix Column)中，也是列混淆层中最重要的操作。我们项要将扩展域中的两个元素用多项式形式展开，然后使用标准的多项式乘法规则将两个多项式相乘：\nAES步骤详解 AES算法主要有四种操作处理，分别是密钥加法层(也叫轮密钥加，英文Add Round Key)、字节代换层(SubByte)、行位移层(Shift Rows)、列混淆层(Mix Column)。而明文x和密钥k都是由16个字节组成的数据(当然密钥还支持192位和256位的长度)，它是按照字节的先后顺序从上到下、从左到右进行排列的。而加密出的密文读取顺序也是按照这个顺序读取的，相当于将数组还原成字符串的模样了，然后再解密的时候又是按照4·4数组处理的。AES算法在处理的轮数上只有最后一轮操作与前面的轮处理上有些许不同(最后一轮只是少了列混淆处理)，在轮处理开始前还单独进行了一次轮密钥加的处理。在处理轮数上，只考虑128位密钥的10轮处理。\n其中字节排列方式需要按照如下转换:\nAES算法流程图如下:\n实现步骤及代码 按照AES流程图,对每一层的代码进行实现.\n密钥加法层 在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。在扩展域中加减法操作和异或运算等价，所以这里的处理也就异常的简单了，只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n如下图：\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4 * 4], word k[4]) { for (int i = 0; i \u0026lt; 4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i + 4] = mtx[i + 4] ^ byte(k2.to_ulong()); mtx[i + 8] = mtx[i + 8] ^ byte(k3.to_ulong()); mtx[i + 12] = mtx[i + 12] ^ byte(k4.to_ulong()); } }   AES密钥生成 首先定义位置变换函数RotWord(),作用是接受一个字 $[a0, a1, a2, a3] $作为输入，循环左移一个字节后输出$ [a1, a2, a3, a0]$,代码如下:\n1 2 3 4 5 6  word RotWord(const word \u0026amp;w) { word result(0x0); result = (w \u0026lt;\u0026lt; 8) | (w \u0026gt;\u0026gt; 24); return result; }   定义S盒变换函数SubWord()，接受一个字 $[a0, a1, a2, a3]$ 作为输入，然后每一个byte，例如a0，前四个字节为行，后四个字节为列，从S_Box中查找并且返回四个元素。，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  word SubWord(const word\u0026amp; sw) { word temp; for(int i=0; i\u0026lt;32; i+=8) { int row = sw[i+7]*8 + sw[i+6]*4 + sw[i+5]*2 + sw[i+4]; int col = sw[i+3]*8 + sw[i+2]*4 + sw[i+1]*2 + sw[i]; byte val = S_Box[row][col]; for(int j=0; j\u0026lt;8; ++j) temp[i+j] = val[j]; } return temp; }   轮常数Rcon[]作为一个常量数组，每一轮生成密钥的时候需要作为参数异或\n1 2 3  // 轮常数，密钥扩展中用到。（AES-128只需要10轮） word Rcon[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};   密钥拓展函数KeyExpansion(),接受一个参数为外部密钥，另外一个为需要拓展的轮密钥数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //密钥扩展函数 - 对128位密钥进行扩展得到 w[4*(Nr+1),Nr为轮数 void KeyExpansion(byte key[4 * N_key], word w[4 * (N_round + 1)]) { word temp; int i = 0; while (i \u0026lt; N_key)\t//前四个word就是输入的key  { w[i] = ToWord(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); ++i; } i = N_key; while (i \u0026lt; 4 * (N_round + 1)) { temp = w[i - 1]; //记录前一个word  if (i % N_key == 0) { //temp先位置表换RotWord，再S盒变换，然后与轮常数异或，最后w[i-N_key] 异或  w[i] = w[i - N_key] ^ SubWord(RotWord(temp)) ^ Rcon[i / N_key - 1]; } else { w[i] = w[i - N_key] ^ temp; } i++; } }   字节替换层 S盒字节替换，主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，读取S_box数据的方法就是要将输入数据的每个字节的高四位作为第一个下标，第四位作为第二个下标。然后返回数据，字节替换主要是为了扰乱数据。\nS盒：\n逆S盒：\n图解如下：\n正向S盒变换代码如下：\n1 2 3 4 5 6 7 8 9 10  //S盒变换 - 前4位为行号，后4位为列号 void SubBytes(byte mtx[4 * 4]) { for (int i = 0; i \u0026lt; 16; ++i) { int row = mtx[i][7] * 8 + mtx[i][6] * 4 + mtx[i][5] * 2 + mtx[i][4]; int col = mtx[i][3] * 8 + mtx[i][2] * 4 + mtx[i][1] * 2 + mtx[i][0]; mtx[i] = S_Box[row][col]; } }   反向S盒变换代码如下:\n1 2 3 4 5 6 7 8 9 10  // 逆S盒变换 void InvSubBytes(byte mtx[4*4]) { for(int i=0; i\u0026lt;16; ++i) { int row = mtx[i][7]*8 + mtx[i][6]*4 + mtx[i][5]*2 + mtx[i][4]; int col = mtx[i][3]*8 + mtx[i][2]*4 + mtx[i][1]*2 + mtx[i][0]; mtx[i] = Inv_S_Box[row][col]; } }   行移位层 将输入数据作为一个$4·4$的字节矩阵进行处理，然后将这个矩阵的字节进行位置上的置换。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在$4·4$矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。最终结束。\n正向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //正向行变换 - 按字节循环移位 void ShiftRows(byte mtx[4 * 4]) { // 第二行循环左移一位  byte temp = mtx[4]; for (int i = 0; i \u0026lt; 3; ++i) mtx[i + 4] = mtx[i + 5]; mtx[7] = temp; // 第三行循环左移两位  for (int i = 0; i \u0026lt; 2; ++i) { temp = mtx[i + 8]; mtx[i + 8] = mtx[i + 10]; mtx[i + 10] = temp; } // 第四行循环左移三位  temp = mtx[15]; for (int i = 3; i \u0026gt; 0; --i) mtx[i + 12] = mtx[i + 11]; mtx[12] = temp; }   反向行移位图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 逆行变换 - 以字节为单位循环右移 void InvShiftRows(byte mtx[4*4]) { // 第二行循环右移一位 \tbyte temp = mtx[7]; for(int i=3; i\u0026gt;0; --i) mtx[i+4] = mtx[i+3]; mtx[4] = temp; // 第三行循环右移两位 \tfor(int i=0; i\u0026lt;2; ++i) { temp = mtx[i+8]; mtx[i+8] = mtx[i+10]; mtx[i+10] = temp; } // 第四行循环右移三位 \ttemp = mtx[12]; for(int i=0; i\u0026lt;3; ++i) mtx[i+12] = mtx[i+13]; mtx[15] = temp; }   列混淆层 列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。\n在加密的正向列混淆中，我们要将输入的$4·4$矩阵左乘一个给定的$4·4$矩阵。而它们之间的加法、乘法都在扩展域$GF(2^8)$中进行，,在矩阵相乘计算中，出现了加法和乘法，而前面提到了在拓展域中加法等同于异或运算，而对于乘法，需要特殊的方式进行处理，于是将+号换成^号，然后将伽罗瓦域的乘法定义成一个有两个参数的函数，并让他返回最后计算结果，最后列混淆代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //正向列变换 void MixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x02, arr[0]) ^ GFMul(0x03, arr[1]) ^ arr[2] ^ arr[3]; mtx[i+4] = arr[0] ^ GFMul(0x02, arr[1]) ^ GFMul(0x03, arr[2]) ^ arr[3]; mtx[i+8] = arr[0] ^ arr[1] ^ GFMul(0x02, arr[2]) ^ GFMul(0x03, arr[3]); mtx[i+12] = GFMul(0x03, arr[0]) ^ arr[1] ^ arr[2] ^ GFMul(0x02, arr[3]); } }   在解密的逆向列混淆中与正向列混淆的不同之处在于使用的左乘矩阵不同，它与正向列混淆的左乘矩阵互为逆矩阵，也就是说，数据矩阵同时左乘这两个矩阵后，数据矩阵不会发生任何变化。下面是图解：\n正向混淆处理：\n逆向混淆处理：\n反向列变换代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //反向列混淆 void InvMixColumns(byte mtx[4*4]) { byte arr[4]; for(int i=0; i\u0026lt;4; ++i) { for(int j=0; j\u0026lt;4; ++j) arr[j] = mtx[i+j*4]; mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]); mtx[i+4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]); mtx[i+8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]); mtx[i+12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]); } }   密钥加法层 这一层主要是明文矩阵盒子密钥矩阵进行异或操作,在密钥加法层中有两个输入的参数，分别是明文和子密钥，而且这两个输入都是128位的。只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n图解：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //轮密钥加变换 - 将每一列与扩展密钥进行异或 void AddRoundKey(byte mtx[4*4], word k[4]) { for(int i=0; i\u0026lt;4; ++i) { word k1 = k[i] \u0026gt;\u0026gt; 24; word k2 = (k[i] \u0026lt;\u0026lt; 8) \u0026gt;\u0026gt; 24; word k3 = (k[i] \u0026lt;\u0026lt; 16) \u0026gt;\u0026gt; 24; word k4 = (k[i] \u0026lt;\u0026lt; 24) \u0026gt;\u0026gt; 24; mtx[i] = mtx[i] ^ byte(k1.to_ulong()); mtx[i+4] = mtx[i+4] ^ byte(k2.to_ulong()); mtx[i+8] = mtx[i+8] ^ byte(k3.to_ulong()); mtx[i+12] = mtx[i+12] ^ byte(k4.to_ulong()); } }   实现加密函数 加密函数按照流程图,首先开始是先进行一次轮密钥加,然后开始9轮的字节替换+行移位+列混淆+轮密钥加的操作,循环之后再做一次字节替换+行移位+轮密钥加就完成加密操作了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void encrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); for(int round=1; round\u0026lt;N_round; ++round) { SubBytes(in); ShiftRows(in); MixColumns(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); } SubBytes(in); ShiftRows(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); }   实现解密函数 解密函数与加密差不多,只不过将行移位变成反向行移位,列混淆变成反向列混淆,字节替换变成逆字节替换即可.\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void decrypt(byte in[4*4], word w[4*(N_round+1)]) { word key[4]; for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*N_round+i]; AddRoundKey(in, key); for(int round=N_round-1; round\u0026gt;0; --round) { InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[4*round+i]; AddRoundKey(in, key); InvMixColumns(in); } InvShiftRows(in); InvSubBytes(in); for(int i=0; i\u0026lt;4; ++i) key[i] = w[i]; AddRoundKey(in, key); }   测试加密解密函数 可以发现上面面的测试中明文与解密之后的明文是完全正确的,说明加密函数与解密函数正确!\n测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  void Aes_test() { byte key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}; byte plain[16] = {0x32, 0x88, 0x31, 0xe0, 0x43, 0x5a, 0x31, 0x37, 0xf6, 0x30, 0x98, 0x07, 0xa8, 0x8d, 0xa2, 0x34}; // 输出密钥  cout \u0026lt;\u0026lt; \u0026#34;Key is : \u0026#34;; for (int i = 0; i \u0026lt; 16; ++i) cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; key[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; cout \u0026lt;\u0026lt; endl; word w[4 * (N_round + 1)]; KeyExpansion(key, w); // 输出待加密的明文  cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;the plaintext to encrypy:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 加密，输出密文  encrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;cipher : \u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; // 解密，输出明文  decrypt(plain, w); cout \u0026lt;\u0026lt; \u0026#34;plain arter decrypt:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 16; ++i) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; plain[i].to_ulong() \u0026lt;\u0026lt; \u0026#34;\u0026#34;; if ((i + 1) % 4 == 0) cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; }   实现加解密文件 加密文件函数,返回加密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  string encryptFile(string oname, string suffix, word w[4 * (N_round + 1)]) { string outputfilename = oname + \u0026#34;_cipher.bin\u0026#34;; bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining encrypy...........\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); // 将文件加密到 oname + cipher.bin 中  ifstream in; ofstream out; in.open(oname + suffix, ios::binary); //输入文件  out.open(outputfilename, ios::binary); //输出加密文件  while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); encrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0  } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;encrypy finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;encrypy cost time : \u0026#34; \u0026lt;\u0026lt; (end - start) \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; //返回加密之后的文件 }   解密文件函数,返回解密后的文件名:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  string decryptFile(string filename, string oname, string suffix, word w[4 * (N_round + 1)]) { ifstream in; ofstream out; in.open(filename, ios::binary); string outputfilename = oname + \u0026#34;_decrypt\u0026#34; + suffix; out.open(outputfilename, ios::binary); bitset\u0026lt;128\u0026gt; data; byte plain[16]; cout \u0026lt;\u0026lt; \u0026#34;begining decrypt............\u0026#34; \u0026lt;\u0026lt; endl; clock_t start = clock(); while (in.read((char *)\u0026amp;data, sizeof(data))) { divideToByte(plain, data); decrypt(plain, w); data = mergeByte(plain); out.write((char *)\u0026amp;data, sizeof(data)); data.reset(); // 置0  } in.close(); out.close(); clock_t end = clock(); cout \u0026lt;\u0026lt; \u0026#34;decrypt finish!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;decrypt cost time : \u0026#34; \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return outputfilename; }   实现效果:\n加密txt文件:\n加密jpg文件:\n加密mp3文件:\n加密doc文件:\nAES五种加密模式 实现五种加密方式的密钥是一个置换表unsigned char Table[4] = {0x12, 0xb1, 0x53, 0x28};,加密函数是原文与密钥的异或.\nECB模式(电子密码本模式) 加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。\nECB模式由于每块数据的加密是独立的因此加密和解密都可以并行计算，ECB模式最大的缺点是相同的明文块会被加密成相同的密文块，这种方法在某些环境下不能提供严格的数据保密性。\n流程图如下:\n实现代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //电子密码本模式,分组大小为4 unsigned char* ECB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for(int j = 0;j \u0026lt; groupSize;++j) temp[j] = plain[count++]; //加密  encrypt(temp,groupSize); for(int j = i*4;j \u0026lt; i*4 + 4;++j) cipher[j] = temp[j - i * 4]; } return cipher;//返回密文 }   解密方法也是让密文与密钥进行异或即可,实现效果如下:\nCBC模式(分组链接模式) CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。\n可用公式总结为:\n$$\nC_i = E_K(P_i XOR C_{i-1}) \\\nC_{-1} = IV\n$$\n流程图如下:\nCBC模式相比ECB有更高的保密性，但由于对每个数据块的加密依赖与前一个数据块的加密所以加密无法并行。与ECB一样在加密前需要对数据进行填充，不是很适合对流数据进行加密。\n代码如下:\n加密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //CCB加密函数 unsigned char *CCB(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = plain[count++]; //加密  for (int j = 0; j \u0026lt; groupSize; ++j) //先与初始向量异或  temp[i] ^= C[i]; encrypt(temp, groupSize); //加密  for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { cipher[j] = temp[j - i * 4]; C[j - i * 4] = temp[j - i * 4];//设置新向量  } } return cipher; }   解密函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //CCB解密函数 unsigned char *dCCB(unsigned char *cipher, int N) { int gNum = N / groupSize; //分组数量  //明文  unsigned char *plain = new unsigned char[N]; //设置初始向量  unsigned char C[groupSize] = {0xe4, 0xa9, 0x5d, 0x99}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; for (int j = 0; j \u0026lt; groupSize; ++j) temp[j] = cipher[count++]; //解密  encrypt(temp, groupSize); //先解密  for (int j = 0; j \u0026lt; groupSize; ++j) //然后与初始向量异或  temp[i] ^= C[i]; for (int j = i * 4; j \u0026lt; i * 4 + 4; ++j) { plain[j] = temp[j - i * 4]; C[j - i * 4] = cipher[j];//设置新向量  } } return plain; }   实现效果:\nCFB模式(密文反馈模式) 与前面的模式不同,CFB模式可以将消息被当成是比特流.可以总结为如下的公式:\n$$\nC_i = P_i XOR E_K(C_{i-1})\\\nC_{-1} = IV\n$$\n流程图如下:\n加密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  //密文反馈模式,加密函数 unsigned char *CFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文,大小为2  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; gsize;++j){ temp[j] ^= C[j]; S[j] = temp[j]; //获取密文的2bit  } //设置密文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; }   解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  //密文反馈解密 unsigned char *dCFB(unsigned char *cipher, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //明文  unsigned char *plain = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xe4, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组密文  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = cipher[count++]; //解密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; 2;++j){ S[j] = temp[j]; temp[j] = C[j] ^ temp[j]; } //设置明文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { plain[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j+gsize] = S[j]; } } return plain; }   实现效果:\nOFB模式(输出反馈模式) OFB是先用块加密器生成密钥流（Keystream），然后再将密钥流与明文流异或得到密文流，解密是先用块加密器生成密钥流，再将密钥流与密文流异或得到明文，由于异或操作的对称性所以加密和解密的流程是完全一样的。\nOFB与CFB一样都非常适合对流数据的加密，OFB由于加密和解密都依赖与前一段数据，所以加密和解密都不能并行。\n流程图如下:\n加密解密代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  //输出反馈模式,加密解密函数相同 unsigned char *OFB(unsigned char *plain, int N) { int gsize = 2; int gNum = N / gsize; //分组数量,分成8组,每组大小为2  //密文  unsigned char *cipher = new unsigned char[N]; //设置初始向量  unsigned char C[4] = {0xee, 0xa9, 0x5d, 0x99}; unsigned char S[2]; //前2个字节  int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[gsize]; //分组明文  for (int j = 0; j \u0026lt; gsize; ++j) temp[j] = plain[count++]; //加密  //先对初始向量进行加密  encrypt(C,4); //获取结果C的前两个bit,然后前2个bit S与明文进行异或  for(int j = 0;j \u0026lt; 2;++j){ S[j] = C[j]; //取向量加密后的前两位  temp[j] ^= C[j]; } //设置密文  for (int j = i * gsize; j \u0026lt; i * gsize + gsize; ++j) { cipher[j] = temp[j - i * gsize]; } //设置新向量,新向量左移  for(int j = 0;j \u0026lt; gsize;++j) { C[j] = C[j + gsize]; C[j + gsize] = S[j]; } } return cipher; }   实现效果:\nCTR模式(计数器模式) 类型于CFB，但是加密每个计数值，而不是任何反馈值,对每个明文分组，必须有不同的密钥和计数值 (从不重复使用),,可以用如下公式表示:\n$$\nO_i = E_K(i)\\\nC_i = P_i XOR O_i\n$$\n计数器模式流程图如下:\n计数器模式加密函数与解密函数一样,代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  //计数器模式,加密函数 unsigned char *CTR(unsigned char *plain, int N) { int gNum = N / groupSize; //分组数量  //密文  unsigned char *cipher = new unsigned char[N]; //设置随机值  unsigned char Counter[groupSize*groupSize] = {0x44, 0xa9, 0x5d, 0x99, 0xe5, 0xf1, 0x3d, 0x91, 0x16, 0xa6, 0xe1, 0x33, 0x22, 0xdd, 0xab, 0x1f}; int count = 0; for (int i = 0; i \u0026lt; gNum; ++i) { unsigned char temp[groupSize]; //明文分组  unsigned char C[groupSize]; //分组随机值  for (int j = 0; j \u0026lt; groupSize; ++j) { temp[j] = plain[count++]; C[j] = Counter[i*4+j]; } //加迷  //首先加密随机值C  encrypt(C, groupSize); //然后与明文进行异或  for(int j = 0;j \u0026lt; groupSize;++j) temp[j] ^= C[j]; //设置密文  for(int j = i*groupSize;j \u0026lt; i*groupSize+groupSize;j++) cipher[j] = temp[j-i*groupSize]; } return cipher; }   实现效果如下:\n参考:\n https://www.cnblogs.com/RabbitHu/p/bitset.html bitset用法 https://blog.csdn.net/liushu1231/article/details/8844631 bitset的空间大小 http://c.biancheng.net/cpp/html/2834.html 文件处理 https://bbs.pediy.com/thread-253884.htm AES算法带图解 https://blog.csdn.net/lisonglisonglisong/article/details/41909813 AES算法 CSDN https://blog.csdn.net/sinat_23338865/article/details/72869841 AES五种加密模式   设“+”为一个交换性的二元运算，即对于所有x,y，x+y=y+x。若该集内存在一个元素0，使得对于所有x，x+0=0+x=x，则此元素是唯一的。如果对于一个给定的x，存在一个x'使得x+x'=x'+x=0，则称x'是x的加法逆元。 \u0026#x21a9;\u0026#xfe0e;\n 乘法逆元，是指数学领域群G中任意一个元素a，都在G中有唯一的逆元a‘，具有性质a×a'=a'×a=e，其中e为该群的单位元。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":34,"section":"posts","tags":["AES","密码学","加密"],"title":"Aes-高级加密标准","uri":"https://vhope.cf/zh/posts/aes/"},{"content":"简单地说，云计算就是计算服务的提供（包括服务器、存储、数据库、网络、软件、分析和智能）- 通过 Internet（云）提供快速创新、弹性资源和规模经济。对于云服务，通常你只需使用多少支付多少，从而帮助降低运营成本，使基础设施更有效地运行，并能根据业务需求的变化调整对服务的使用。\n行云趣码记录 行云趣码官网：http://mart.cloudtogo.cn/\nLinux服务器 生成自己的服务器 进入应用商店，选择需要的Linux服务器，这里选择CentOS\n点击部署，等待生成自己的服务器\n发布成功\n参数解释 点击访问，会跳出访问地址，部署区域以及提示信息，一步一步看。\n访问地址\n部署区域\n部署区域没什么好说的，就是这个服务器部署的区域。\n详情\n从上面给的信息，可以归为如下：\n  ssh远程访问的地址为2c56369b3c95a919.c.cloudtogo.cn，端口为34920(注意：端口不是22)。远程登陆的用户名为：root，密码为：123456.\n  有五个映射端口，他们的对应关系如下：\n   Linux内部 外部访问     8001 34921(预留a端口)   8002 34916(预留b端口)   8003 34917(预留c端口)   8004 34918(预留d端口)   8005 34924(预留e端口)    也就是说，当我们在Linux内部启用8001-8005这五个端口运行相应的应用时，我们可以访问对应的外部预留端口以及子域名进行访问测试。\n例如在Linux内运行了一个web应用在8001端口，我们可以在浏览器访问61823a63ab19b300.c.cloudtogo.cn:34921\n  ssh远程连接：\n查看配置 查看CPU型号: Intel(R) Xeon(R) CPU E5-2680 v3\n1  cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c   查看物理CPU个数: 2\n1  cat /proc/cpuinfo | grep \u0026#34;physical id\u0026#34; | sort | uniq|wc -l   查看逻辑CPU的个数: 8个\n1  cat /proc/cpuinfo | grep \u0026#34;processor\u0026#34; |wc -l   查看CPU是几核: 4核\n1  cat /proc/cpuinfo | grep \u0026#34;cores\u0026#34;|uniq   设置远程访问jupyter 安装完jupyter之后，输入以下命令生成配置文件：\n1  jupyter notebook --generate-config   参考：\nhttps://www.jianshu.com/p/960f011f712e\nhttps://zhuanlan.zhihu.com/p/64524822\n结果：\n添加虚拟环境：https://ofooo.github.io/wiki/python/%E5%B7%A5%E5%85%B7/jupyter-notebook/\n更换pip源：https://www.linuxidc.com/Linux/2019-04/158178.htm\n部署nodejs：https://blog.csdn.net/xerysherryx/article/details/78920978\nnpm镜像：https://www.cnblogs.com/alps/p/12439387.html\nCentOS基本命令 查看服务进程\n1 2 3  [victor@mylove ~]$ ps -aux|grep mysql victor 23477 0.0 0.0 110656 2688 pts/3 S+ 12:26 0:00 grep --color=auto mysql   查看进程端口\n1  netstat -anp |grep 1506   查看端口进程\n1  netstat -lnp|grep 3306   关闭进程\n1  kill –9 1506   生产应用 使用docker生产自己的应用 开发网页App 进入应用工厂,打开一个Blank的模板继续,然后再设计页面拖入一个代码组件,如下:\n输入名字为webpy,应为使用的是web.py框架进行编写,然后点击下一步.\n然后输入存放代码的地址,代码需要编写完成之后存到GitHub上,程序默认的运行入口时main.py,在运行main.py之前,还会执行pip install -r requirements.txt这个代码,所以我们可以将所需要的依赖包都写在requirements.txt这个文件中.\n我的代码地址: https://github.com/redisread/webpy.git\n编写组件向导,有许多参数\n其他的参数作用:\n 环境变量: 存储系统的相关需要运行的程序的位置 多副本: 多副本设置支持可以使用弹性伸缩功能,可开启可不开启 会话保持: 维持客户端与一台服务器的连接,即对于某个客户端,,不会更换与他进行连接的服务器 执行命令: 可以执行Linux的相关命令 存储路径: 可以设置存储到数据卷中,填写的Linux的位置就是数据卷存放的位置 root权限: 是否开启root权限 服务名称: 就是服务的名称 读取指定文件: **0 日志文件: 填写日志文件存放的的地方 映射配置文件: 可以映射(相当于替换)配置文件,例如nginx的nginx.conf文件. 健康检查: 特权模式: 资源限制: 限制CPUy以及内存的设置  最后点击完成就可以发发布应用了\n发布一般不需要配置什么,需要的话可以自行设置.\n发布成功!\n访问该地址就能够访问我们写的应用了.\n运维管理 在发布页的侧边栏有一个运维按钮,点击进入运维界面\n如下就是可以进行查看的相关信息\n","description":"","id":35,"section":"posts","tags":["云计算","行云趣码"],"title":"行云开发","uri":"https://vhope.cf/zh/posts/xingyun-begin/"},{"content":"。。集万滴雨水，成一条江河🌊🌊\nRedis  REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。\nRedis是一个开源的使用ANSI C语言编写、遵守BSD协议1、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n  开源界的 5 大许可协议：五大开源许可协议分别是GPL,LGPL,BSD,MIT,Apache。\n 存储类型：\n String: 字符串 Hash: 散列 List: 列表 Set: 集合 Sorted Set: 有序集合  三个特点：\n Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式2的数据备份。  Redis与其他key-value存储有什么不同？\n Redis有着更为复杂的数据结构并且提供对他们的原子性操作3，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。  安装 github链接：https://github.com/microsoftarchive/redis/releases\nRedis是C语言开发，安装Redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc。\n安装GCC 步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  ## 先安装 gcc 编译环境,如果已经安装, 请忽略 yum -y install gcc automake autoconf libtool make ## 下载 redis 源代码 wget http://download.redis.io/releases/redis-4.0.1.tar.gz ## 下载完成后,解压 tar zxvf redis-4.0.1.tar.gz ## 跳转到 redis 目录 cd redis-4.0.1 ## 编译 make ## 安装编译后的软件到 /usr/local/redis ## PREFIX必须大写,自动为我们创建redis目录，并将结果安装此目录 make PREFIX=/usr/local/redis install ## 查看安装的结果 cd /usr/local/redis/bin ls -l -rwxr-xr-x 1 root root 2451864 Mar 12 13:28 redis-benchmark -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-check-aof -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-check-rdb -rwxr-xr-x 1 root root 2606088 Mar 12 13:28 redis-cli lrwxrwxrwx 1 root root 12 Mar 12 13:28 redis-sentinel -\u0026gt; redis-server -rwxr-xr-x 1 root root 5741096 Mar 12 13:28 redis-server   配置  Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。\n redis.conf配置文件详解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  ## 指定包含其它的配置文件，可以多个Redis实例使用同一份配置文件，而各个实例又拥有自己的特定配置文件 include /path/to/local.conf ## 绑定的主机地址, 可以监听一个或多个, 如果为 127.0.0.1 只能本机才能访问 bind 127.0.0.1 ## Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no ## Redis以守护进程方式运行时,Redis默认会把 pid 写入 /var/run/redis.pid 文件,可以通过 pidfile 指定 pidfile /var/run/redis_6379.pid ## 指定Redis监听端口，默认端口为6379 port 6379 ## 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 0 ## 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose ## debug 会打印出很多信息，适用于开发和测试阶段 ## verbose 包含很多不太有用的信息，但比debug要清爽一些 ## notice 适用于生产模式 ## warning 警告信息（仅记录非常重要/重要的消息） loglevel verbose ## 日志记录方式，默认为标准输出 ## 如果 Redis 以守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout ## 设置数据库的数量，默认数据库为0，可以使用SELECT \u0026lt;dbid\u0026gt;命令在连接上指定数据库id databases 16 ## 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件(持久化)，可以多个条件配合 ## save \u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt; save 900 1 ## 900秒内有一个更新 save 300 10 ## 300秒内有10个更新 save 60 10000 ## 60秒内有10000个更新 ## 指定存储至本地数据库时是否压缩数据，默认为yes ## Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes ## 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb ## 也就是安装目录下我们看到的那个文件 ## 指定本地数据库存放目录 dir ./ ## 当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt; ## 当master服务设置了密码保护时，slav服务连接master的密码 masterauth \u0026lt;master-password\u0026gt; ## 设置Redis连接密码 ## 如果配置了连接密码，客户端在连接Redis时需要通过AUTH \u0026lt;password\u0026gt;命令提供密码，默认关闭 requirepass foobared ## 设置同一时间最大客户端连接数，默认无限制 ## Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数 ## 如果设置 maxclients 0，表示不作限制 ## 客户端连接数到达限制时,Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 128 ## Redis最大内存限制 ## Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key ## 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。 ## Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory \u0026lt;bytes\u0026gt; ## 指定是否在每次更新操作后进行日志记录, 默认为 no ## Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失 ## 因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中 appendonly no ## 指定更新日志文件名，默认为 appendonly.aof appendfilename appendonly.aof ## 指定更新日志条件 ## no : 表示等操作系统进行数据缓存同步到磁盘（快） ## always : 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） ## everysec : 表示每秒同步一次（折中，默认值） appendfsync everysec ## 指定是否启用虚拟内存机制，默认值为no ## VM机制将数据分页存放,将访问量较少的页即冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中 vm-enabled no ## 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap ## 将所有大于vm-max-memory的数据存入虚拟内存 ## 无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys), ## 也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 ## Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享 vm-page-size 32 ## 设置swap文件中的page数量 ## 由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的,在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 ## 设置访问swap文件的线程数,最好不要超过机器的核数, ## 如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 ## 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes ## 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 ## 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes   注意事项 我们查看了配置文件信息, 总结如下\n   如果你想要以加载配置文件的方式启动 Redis, 那么你需要使用 ./redis-server /path/to/redis.conf 命令启动 Redis 服务端.\n  内存设置大小单位\n   1k =\u0026gt; 1000 bytes 1kb =\u0026gt; 1024 bytes 1m =\u0026gt; 1000000 bytes 1mb =\u0026gt; 1024*1024 bytes 1g =\u0026gt; 1000000000 bytes 1gb =\u0026gt; 102410241024 bytes 1GB 1Gb 1gB 表达一样的意思, 单位不区分大小写    121321\n   基本操作 连接远程服务器：redis-cli -h host -p port -a password\n例如：$redis-cli -h 127.0.0.1 -p 6379 -a \u0026quot;mypass\u0026quot;\n键Key 与 Redis 键相关的基本命令：\n   序号 命令及描述     1 DEL key 该命令用于在 key 存在时删除 key。   2 DUMP key 序列化给定 key ，并返回被序列化的值。   3 EXISTS key 检查给定 key 是否存在。   4 EXPIRE key seconds 为给定 key 设置过期时间，以秒计。   5 EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。   6 PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。   7 PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计   8 KEYS pattern 查找所有符合给定模式( pattern)的 key 。   9 MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。   10 PERSIST key 移除 key 的过期时间，key 将持久保持。   11 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。   12 TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。   13 RANDOMKEY 从当前数据库中随机返回一个 key 。   14 RENAME key newkey 修改 key 的名称   15 RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。   16 TYPE key 返回 key 所储存的值的类型。    设置键值对 set key value 与取出键值对 get key\n删除键值使用del key\n字符串存储 Hash存储 之前变量没删除会报错\nRedis hash 是一个键值(key=\u0026gt;value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n每个 hash 可以存储 232 -1 键值对（40多亿）。\n列表存储 Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n展示：\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n集合存储 指令：sadd key member 向集合key添加元素。\n指令：smembers key，展示集合key中的元素：\n有序集合-zset 指令：zadd key score member ，向有序集合添加元素，并且设置相应的score。\n上面设置A且score为0，B且score为2，C且score为1.\n指令：zrangebyscore key l r,展示有序集合按score排序之后且在范围l到r的元素。\n显然元素已经按照score的顺序排列。\n 跟其他条款相比，从GNU通用公共许可证（GPL）到限制重重的著作权（Copyright），BSD许可证比较宽松，甚至跟公有领域更为接近。事实上，BSD许可证被认为是copycenter（中间著作权），介乎标准的copyright与GPL的copyleft之间。\u0026ldquo;Take it down to the copy center and make as many copies as you want\u0026rdquo;[1]。可以说，GPL强迫后续版本必须一样是自由软件，BSD的后续版本可以选择要继续是BSD或其他自由软件条款或封闭软件等等。 \u0026#x21a9;\u0026#xfe0e;\n 主从设备模式也叫做主仆模式英文简称为Master-Slave,核心思想是基于分而治之的思想,将一个原始任务分解为若干个语义等同的子任务,并由专门的工作者线程来并行执行这些任务,原始任务的结果是通过整合各个子任务的处理结果形成的 \u0026#x21a9;\u0026#xfe0e;\n 意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":36,"section":"posts","tags":["redis","分布式计算","云计算","数据库"],"title":"分布式-Redis","uri":"https://vhope.cf/zh/posts/redis/"},{"content":"走得慢的时候，为什么不跑呢？#️⃣\n哈希散列表 两个概念：\n散列表：\n散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。\n散列函数：\n散列函数，顾名思义，它是一个函数。如果把它定义成 hash(key) ，其中 key 表示元素的键值，则 hash(key) 的值表示经过散列函数计算得到的散列值。\n散列函数特点：\n 确定性 散列碰撞（collision） 不可逆性(一个哈希值对应无数个明文，理论上你并不知道哪个是。) 混淆特性  常见的散列函数：\n MD51 SHA-12  为什么哈希算法查找数组元素会更快？\n 原来使用下标进行匹配的画，会一个一个从一整个数组进行元素匹配，知道找到相等的元素才得到数组的信息。例如在Arr[20]查找值为12的,就需要从下标0到19进行查找。\n但是哈希散列表将一个一个按顺序的查找转换为使用计算的方式进行查找，将运算结果的下标映射成一个哈希表，实现了跳跃式的查找，从而效率更高。\n 问题:散列冲突\n 对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的散列冲突。\n 解决散列函数的两个方法：\n  链表法\n就是使用链表来保存冲突下标的数据，例如$12 % 5 = 2$和$7 % 5 = 2$,那么在下标为2的表下用一个链表存储12和7。\n  开放寻址法。\n常见三种方法：线性探测法、二次探测法、双散列\n假设哈希函数为：\n$$\nH(key) = key \\mod10\n$$\n线性探测法：\n还是$12 % 10 = 2 $和$22 % 10 = 2$这两个例子，当22这个数字需要存入哈希表时，发现已经有12这个元素存放在下标为2的哈希表上了，那么对Hash后的数字加一在进行Hash。即对7进行这样的操作：\n$$\nH((H(key)+1)) = ((22 \\mod 10) + 1) \\mod 10 = (2 + 1) \\mod 10 = 3\n$$\n但是这种方式的问题是冲突较多的时候会出现数据聚集在一个区域，这样不利于查询数据。\n二次探测法：\n二次探测法使用下面的函数解决冲突：\n$$\n(H(key) \\pm j^2) \\mod 10,j = 0,1,2\u0026hellip;\n$$\n这种方法较为复杂，而且虽然不会连续的聚集一片，但是会在多个间断的位置聚集。\n双散列：\n双散列，顾名思义就需要增加一个二级散列函数，例如$G(key) = q - (key \\mod q) q为素数且q\u0026lt;N$，发现冲突使用如下操作：\n$$\nH(key) + j * G(key),j = 0,1,2\u0026hellip;\u0026hellip;\n$$\n双散列方法有很多组合的方法，这里只是其中的一种，也有一些例如:$H(key) + G(key)$,没有j这个参数。\n  密码学中的哈希算法  hash（散列、杂凑）函数，是将任意长度的数据映射到有限长度的域上。直观解释起来，就是对一串数据m进行杂糅，输出另一段固定长度的数据h，作为这段数据的特征（指纹）。也就是说，无论数据块m有多大，其输出值h为固定长度。到底是什么原理？将m分成固定长度（如128位），依次进行hash运算，然后用不同的方法迭代即可（如前一块的hash值与后一块的hash值进行异或）。如果不够128位怎么办？用0补全或者用1补全随意，算法中约定好就可以了。\n 一般来说，公司不会直接将用户的密码保存在数据库中，而是保存经过哈希操作的密码得到的哈希值。这样，当哈希值被不法分子窃取，也不能还原出用户的密码；并且，公司只需要将用户输入的密码进行哈希操作，将哈希值与存储在数据库中的哈希值进行对比就能够验证用户了。\n哈希的其他用法 数据校验：\n  Git的- git commit id\n每次git提交后都有一个commit id，比如:\n19d02d2cc358e59b3d04f82677dbf3808ae4fc40\n  版权校验\n判断两个文件是不是一样的，对两个文件都进行哈希操作，得到哈希值，若哈希值相同，则两个文件为同一个文件。\n  大文件分块校验\n例如使用bt下载，在p2p网络中会把一个大文件拆分成很多小的数据各自传输。这样的好处是如果某个小的数据块在传输过程中损坏了，只要重新下载这个块就好。为了确保每一个小的数据块都是发布者自己传输的，我们可以对每一个小的数据块都进行一个hash的计算，维护一个hash List，在收到所有数据以后，我们对于这个hash List里的每一块进行遍历比对。这里有一个优化点是如果文件分块特别多的时候，如果遍历对比就会效率比较低。可以把所有分块的hash值组合成一个大的字符串，对于这个字符串再做一次Hash运算，得到最终的hash（Root hash）。在实际的校验中，我们只需要拿到了正确的Root hash，即可校验Hash List，也就可以校验每一个数据块了。\n  负载均衡：\n一致性hash的基本原理是将输入的值hash后，对结果的hash值进行2^32取模，这里和普通的hash取模算法不一样的点是在一致性hash算法里将取模的结果映射到一个环上。将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一个openid必定会被缓存到固定的服务器上，那么，当下次想要访问这个用户的数据时，只要再次使用相同的算法进行计算，即可算出这个用户的数据被缓存在哪个服务器上，直接去对应的服务器查找对应的数据即可。这里的逻辑其实和直接取模的是一样的。如下图所示：\n这部分不是很深入，之后再补充\u0026hellip;\u0026hellip;🚴\n参考链接：\n https://www.zhihu.com/question/26762707?sort=created-知乎 动画：什么是散列表？-五分钟算法 什么是 hash？-知乎   MD5 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 MD5 实现。 \u0026#x21a9;\u0026#xfe0e;\n SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。 \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":37,"section":"posts","tags":["Hash","Algorithm","md5","sha"],"title":"什么是Hash？","uri":"https://vhope.cf/zh/posts/hash/"},{"content":"排序是最基本的算法，里面包含了最基础的思想。一个简单的优化可以让排序快很多。\n$O(n^2)$的排序算法 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13  //冒泡排序 template \u0026lt;typename T\u0026gt; void bubbleSort(T *arr, int size) { for (int i = 0; i \u0026lt; size; ++i) { for (int j = 0; j \u0026lt; size - i - 1; ++j) { if (arr[j] \u0026gt; arr[j + 1]) swap(arr[j], arr[j + 1]); } } }   插入排序 ​\n1 2 3 4 5 6 7 8 9  template\u0026lt;typename T\u0026gt; void insertSort(T *arr,int size) { for(int i = 0;i \u0026lt; size;++i) { int j; for(j = i;j \u0026gt; 0 \u0026amp;\u0026amp; arr[j] \u0026lt; arr[j-1];--j){swap(arr[j],arr[j-1]);} } }   选择排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14  //选择排序 复杂度O(n^2) template\u0026lt;typename T\u0026gt; void selectionSort(T *arr,int size) { int k; for(int i = 0;i \u0026lt; size-1; ++i) { k = i; for(int j = i+1;j \u0026lt; size;++j) if(arr[j] \u0026lt; arr[k]) k = j; if(k != i) mySwap(arr[k],arr[i]); } }   测试排序使用时间的时候，总是选择排序快于插入排序，按理说，插入排序应该比选择排序要快啊，因为插入排序可以提前终止循环，这是为什么呢？\n 原因是选择排序比较的是下标，而插入排序每一次比较都要交换，而交换所耗费的时间是高于简单的比较的。\n 插入排序优化-将交换变成赋值\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; void insertSort(T *arr,int size) { for(int i = 0;i \u0026lt; size;++i) { T e = arr[i]; int j; for(j = i;j \u0026gt; 0 \u0026amp;\u0026amp; arr[j-1] \u0026gt; e;--j){arr[j] = arr[j-1];} arr[j] = e; } }   运行时间明显变快了\n 对于近乎有序的数据来说，插入排序的速度要快很多，近乎$O (n)$。而插入排序的实际应用有很多，比如日志，日志的时间是近乎有序的，但是生成日志可能会出错，需要进行时间排序处理，这个时候使用插入排序会更好；还有银行的一些流水单等等\n 拓展： C++运算符重载\n 一般在类中实现，有两种可以实现的方法\n  运算符重载例子，使用在一个类中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Student { public: string name; int score; bool operator\u0026lt;(const Student \u0026amp;otherStudent) { return this-\u0026gt;score \u0026lt; otherStudent.score; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const Student \u0026amp;student) { os \u0026lt;\u0026lt; \u0026#34;Student:\u0026#34; \u0026lt;\u0026lt; student.name \u0026lt;\u0026lt; \u0026#34;\u0026#34;\u0026lt;\u0026lt;student.score\u0026lt;\u0026lt;endl; return os; } };      使用友元函数\n1 2 3 4 5 6 7 8  返回值类型 operator 运算符(形参表) { ... } //例Complex是一个复数类 friend Complex operator+(const Complex \u0026amp;c1,const Complex \u0026amp;c2){ return Complex(c1.i + c2.i,c1.j + c2.j); }     使用类里面的函数\n1 2 3 4 5 6 7 8  返回值类型 operator 运算符(形参表) { ... } //例Complex是一个复数类 Complex operator+(const Complex \u0026amp;complex){ return Complex(this-\u0026gt;i + complex.i,this-\u0026gt;j + complex.j); }     它们的区别就是参数的个数不同以及需不需要加上fridend这个关键字\n$O(n\\log (n))$的排序算法 归并排序 代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  template \u0026lt;typename T\u0026gt; void __merge(T *arr, int l, int middle, int r) { T aux[r - l + 1]; for (int i = l; i \u0026lt;= r; ++i) aux[i - l] = arr[i]; int i = l, j = middle + 1; for (int k = l; k \u0026lt;= r; ++k) { if (i \u0026gt; middle) { arr[k] = aux[j - l]; j++; } else if (j \u0026gt; r) { arr[k] = aux[i - l]; i++; } else if (aux[i - l] \u0026lt; aux[j - l]) { arr[k] = aux[i - l]; i++; } else { arr[k] = aux[j - l]; j++; } } } template \u0026lt;typename T\u0026gt; void __mergeSort(T *arr, int l, int r) { if (l \u0026gt;= r) return; int middle = (l + r) / 2; __mergeSort(arr, l, middle); __mergeSort(arr, middle+1, r); if(arr[middle] \u0026gt; arr[middle+1]) __merge(arr, l, middle, r); } //归并排序 template \u0026lt;typename T\u0026gt; void mergeSort(T *arr, int size) { __mergeSort(arr, 0, size - 1); }   下面这段代码的标记部分需要考虑溢出的问题\n 归并排序快是快，但是要耗费多一倍$O(n)$的存储空间，也就是使用空间换时间。\n 希尔排序 动画演示(来自@五分钟算法)：\n代码实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //希尔排序 template \u0026lt;typename T\u0026gt; void shellSort(T *arr, int size) { int dk[] = {5, 3, 1}; for (int index = 0; index \u0026lt; 3; ++index) { for (int i = 0; i \u0026lt; size / dk[index]; ++i) { int j; int e = arr[i]; for (j = i + dk[index]; j \u0026gt; dk[index] \u0026amp;\u0026amp; arr[j] \u0026gt; e; j -= dk[index]) { arr[j] = arr[j - dk[index]]; } arr[j] = e; } } }    希尔排序相当于是插入排序的升级版，增加了一个步长参数，使用希尔排序可以让零散的数据实现跳跃行的交换，最后逐渐将数组转化为有序，这样最后使用步长为1的插入排序就非常快了。\n 快速排序 被称为二十世纪影响最大的算法之一！\n动画演示(来自@五分钟算法)：\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  template\u0026lt;typename T\u0026gt; int __partition(T *arr,int l,int r){ T v = arr[l]; int j = l; for(int i = l+1;i \u0026lt;= r;++i){ if(arr[i] \u0026lt; v){ swap(arr[i],arr[++j]); } } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void __quickSort(T *arr,int l,int r) { if(l \u0026gt;= r) return; int p = __partition(arr,l,r); __quickSort(arr,l,p-1); __quickSort(arr,p+1,r); } //快速排序 template\u0026lt;typename T\u0026gt; void quickSort(T *arr,int size) { __quickSort(arr,0,size-1); }   优化一：\n在数组的元素个数小于15个的时候使用插入排序进行优化:\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; void __quickSort(T *arr,int l,int r) { + if(r - l \u0026lt;= 15) insertionSort(arr,l,r);  int p = __partition(arr,l,r); __quickSort(arr,l,p-1); __quickSort(arr,p+1,r); }   优化二：\n使用随机值作为划分标准\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  template\u0026lt;typename T\u0026gt; int __partition(T *arr,int l,int r){ + swap(arr[l],arr[rand() % (r-l+1) + l]);  T v = arr[l]; int j = l; for(int i = l+1;i \u0026lt;= r;++i){ if(arr[i] \u0026lt; v){ swap(arr[i],arr[++j]); } } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void quickSort(T *arr,int size) { + srand(time(NULL));  __quickSort(arr,0,size-1); }   缺点:\n 在近乎有序的数组排序中，快速排序的性能很差。时间复杂度也近乎$O(n^2 )$ 对于有很多重复元素的数组，快速排序的性能也很差  快速排序版本二：两路快排 使用两个下标分别处理大于v与小于v的部分。(v为基准元素)\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  template\u0026lt;typename T\u0026gt; int __partition2(T *arr,int l,int r){ swap(arr[l],arr[rand() % (r-l+1) + l]); T v = arr[l]; int i = l + 1,j = r; while(true) { while(arr[i] \u0026lt; v \u0026amp;\u0026amp; i \u0026lt;= r) ++i; while(arr[j] \u0026gt; v \u0026amp;\u0026amp; j \u0026gt;= l+1) --j; if(i \u0026gt; j) break; swap(arr[i++],arr[j--]); } swap(arr[l],arr[j]); return j; } template\u0026lt;typename T\u0026gt; void __quickSort2(T *arr,int l,int r) { if(r - l\u0026lt;= 15){ insertSort(arr,l,r); return; } int p = __partition2(arr,l,r); __quickSort2(arr,l,p-1); __quickSort2(arr,p+1,r); } //快速排序版本二，双路快排 template\u0026lt;typename T\u0026gt; void quickSort2(T *arr,int size) { srand(time(NULL)); __quickSort2(arr,0,size-1); }   快速排序版本三：三路快排 使用三个下标分别处理大于v、等于v与小于v的部分。(v为基准元素)\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  template\u0026lt;typename T\u0026gt; void __quickSort3(T *arr,int l,int r) { if(r - l\u0026lt;= 15){ insertSort(arr,l,r); return; } swap(arr[l],arr[rand() % (r-l+1) + l]); T v = arr[l]; int lt = l; //arr[l+1...lt] \u0026lt; v  int gt = r + 1; //arr[gt...r] \u0026gt; v  int i = l+1; //arr[lt+1...i] == v  while(i \u0026lt; gt){ if(arr[i] \u0026lt; v){ swap(arr[i++],arr[++lt]); }else if(arr[i] \u0026gt; v){ swap(arr[i],arr[--gt]); }else{ i++; } } swap(arr[l],arr[lt]); __quickSort3(arr,l,lt-1); __quickSort3(arr,gt,r); } //快速排序版本三，三路快排 template\u0026lt;typename T\u0026gt; void quickSort3(T *arr,int size) { srand(time(NULL)); __quickSort3(arr,0,size-1); }   堆排序 基数排序 桶排序 排序算法总结 图片：\n未完待续\u0026hellip;\u0026hellip;🛴\n参考：\n https://www.cnblogs.com/onepixel/p/7674659.html https://github.com/MisterBooo/Article ","description":"","id":38,"section":"posts","tags":["算法","排序","C++"],"title":"排序算法总结","uri":"https://vhope.cf/zh/posts/algorithmstructure/sort/"},{"content":"机器学习有这些基本的算法组成，要门机器学习，就需要打个地基✒\nK近邻算法-KNN-(k-Nearest-Neighbors) 可以解决的问题:\n 分类问题 回归问题  预测一个人是天才还是白痴 首先先生成模拟数据，,x1和x2分别表示两个特征\nIQ值低的数据\n1 2 3  x1_low = np.random.random(10) + 3 x2_low = np.random.random(10) + 6 x1_low,y2_low   (array([3.72183336, 3.16146551, 3.88914234, 3.85673496, 3.1573191 , 3.4293751 , 3.96033808, 3.78793864, 3.94939642, 3.57378294]), array([6.47227974, 6.49537929, 6.98666118, 6.79440424, 6.99201224, 6.73386195, 6.63275792, 6.65411763, 6.42891099, 6.49695701])) IQ值高的数据\n1 2 3  x1_high = 4 + np.random.random(8) x2_high = 7 + np.random.random(8) x1_high,x2_high   (array([4.39543051, 4.73302502, 4.02667743, 4.46232039, 4.68128181, 4.92115752, 4.45267816, 4.84647668]), array([7.40538131, 7.3356809 , 7.90412483, 7.45237382, 7.15550294, 7.3764611 , 7.52492352, 7.67692014])) 总的数据和标签\n1 2 3 4 5 6  x1 = np.append(x1_low,x1_high) x2 = np.append(x2_low,x2_high) x_train = np.c_[x1.T,x2.T] print(x_train) y_train = np.append(np.zeros_like(x_low),np.ones_like(x_high)) print(y_train)   [[3.72183336 6.47227974] [3.16146551 6.49537929] [3.88914234 6.98666118] [3.85673496 6.79440424] [3.1573191 6.99201224] [3.4293751 6.73386195] [3.96033808 6.63275792] [3.78793864 6.65411763] [3.94939642 6.42891099] [3.57378294 6.49695701] [4.28739637 7.71057536] [4.31513454 7.70173516] [4.10934692 7.38111019] [4.35094666 7.33731866] [4.01739934 7.41472044] [4.98558165 7.72054925] [4.80075428 7.12604512] [4.48912715 7.08753069]] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1.] 绘制散点图\n1 2 3 4 5  plt.scatter(x_train[y_train==0,0],x_train[y_train==0,1]) plt.scatter(x_train[y_train==1,0],x_train[y_train==1,1]) plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;IQ\u0026#39;) plt.show()    上图红色表示天才，蓝色表示白痴\n 假设输入一个样本的数据为 (4.36,7.465)，判断它天才还是白痴\n1 2 3 4 5 6 7 8  example = np.array([4.36,7.456]) # 首先再图上画出来观察 plt.scatter(x_train[y_train==0,0],x_train[y_train==0,1]) plt.scatter(x_train[y_train==1,0],x_train[y_train==1,1]) plt.scatter(example[0],example[1],color=\u0026#39;black\u0026#39;) plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;IQ\u0026#39;) plt.show()    黑点表示输入的样本\n 获取距离列表\n1 2  distance = [sqrt(sum(((x-example)**2))) for x in x_train] distance   [1.172587826601725, 1.5359938425092403, 0.6648201732802982, 0.8312548678718089, 1.2890795094301544, 1.177941448784469, 0.9151268590623418, 0.9850226059672444, 1.1061225623709607, 1.2401212526176475, 0.2647260841097585, 0.24979727210937175, 0.26160170347749107, 0.1190261413334191, 0.3450785650776031, 0.6792191910080055, 0.5505765678982287, 0.39044007348145965] 对于KNN，假设k=3，就是求出与样本最近的三个点的数据\n1 2  result = np.argsort(distance) result[:k]   array([13, 11, 12], dtype=int64)  可以得知，前三个的训练样本的点的下标分别围殴13，11，12\n 接下来根据这三个训练样本的类别来预测输入的样本是天才还是白痴，假如这三个训练样本是天才的数量多于白痴，就认为它是天才；不然，就认为它是白痴\n1 2 3 4 5 6 7  from collections import Counter votes = Counter(r) y_hat = votes.most_common(1)[0][0] if y_hat == 1: print(\u0026#34;预测它为天才\u0026#34;) else: print(\u0026#34;预测它为白痴\u0026#34;)   预测它为天才 主成分分析法-PCA-(Principal Component Analysis)  PAC主要用于数据的降维\n 二维降到一维\n 由上面两个降维的图来看，第二张图片是一个更好的图，因为图二点和点的距离相对比较大，也就是说，点之间的区分度比较高\n 更好的降维方案\n 此时点和点之间的距离最大，区分度更大\n 那么如何定义样本之间的间距呢？\n可以使用方差(Variance),方差可以表示样本整体分布的疏密程度\n$$\nVar(x) = \\frac{1}{m}\\sum_{i = 1}^{m}(x_{i} - \\bar x)^2\n$$\n可以转化成：\n​\t希望找到一条轴，使得样本投影到该轴上的各点之间的方差最大\nPCA操作步骤：\n  将样例的均值归为0(demean)\n这样，就相当于坐标轴变成如下的图：\n  当均值$\\bar x = 0$时，原来的方差公式变为\n$$\nVar(x) = \\frac{1}{m}\\sum_{i = 1}^{m}(x_{i} - \\bar x)^2 \\Rightarrow Var(x) = \\frac{1}{m}\\sum_{i = 1}^{m}x_{i}^2\n$$\n假设两个维度的特征为$w1$,$w2$,那么需要求得的直线的方向为$w =（w_{1},w_{2}）$,映射到$w$后，有:\n$$\nVar(X_{project}) = \\frac{1}{m} \\sum_{1}^{m} (X_{project}^{(i)} - \\bar X{project})^2\n$$\n使得上面的公式最大\n其实最后的结果还是向量，因为$X$每一个点都包含两个元素，即应该是\n由均值为0，得到\n  计算过程\n目标即：\n与线性回归的不同：\n PCA的两个坐标轴表示的是两个特征，而线性回归的横轴是特征，纵轴是输出标记 PCA使得点之间的方差最大，而线性回归则是需要使得输出标记尽量拟合一条直线，是在纵轴上的  决策树 例子：\n数值特征例子：\n特点：\n 非参数学习算法 可以解决分类问题 天然的解决多分类问题 也可以解决回归问题 非常好的可解释性  问题：\n 每个节点在哪个维度作划分 某个维度的哪个值作划分    支持向量机-SVM-(Support Vector Machine) 主要思想：\nSVM分类:\n  Hard Margin SVM\t解决的是线性可分问题\n  Soft Margin SVM 可解决线性不可分问题\n  🤠未完待续\u0026hellip;\u0026hellip;\n","description":"机器学习必须掌握的基础算法，学会这些基础，对后面的理解才会透彻","id":39,"section":"posts","tags":["机器学习","SVM","决策树","kNN","PCA"],"title":"机器学习基本算法","uri":"https://vhope.cf/zh/posts/machine-learning-base/"},{"content":"一些英雄的图案🌿\n","description":"","id":40,"section":"gallery","tags":[""],"title":"Hero","uri":"https://vhope.cf/zh/gallery/hero/"},{"content":"使用Scrapy爬取文章的一个小项目..\nScrapy 框架图：\n抓取小程序社区文章 创建爬虫项目 创建项目（项目名为MyTest）\n1  scrapy startproject MyTest   创建爬虫🐞(先进入到MyTest目录)\n1  scrapy genspider -t crawl wx wxapp-union.com    wx为爬虫的名字，wxapp-union.com为爬取的域名，使用了模板crawl\n 定义爬取的数据结构 爬取的数据结构类继承Item类，在items.py文件中，如下是设置需要爬取的数据结构，其中包括:标题、作者、时间、访问者、前言、正文。\n1 2 3 4 5 6 7 8 9 10  from scrapy import Item,Field # 定义文章数据结构 class ArticleItem(Item): title = Field() author = Field() _time = Field() visitors = Field() pre_talk = Field() article_content = Field()   编写爬虫规则与解析规则  爬虫的爬取网页的链接的规则和解析页面的规则都是在新建的spider文件中的类中，也即在wx.py中\n 编写的spider类如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import scrapy from scrapy.linkextractors import LinkExtractor from scrapy.spiders import CrawlSpider, Rule from MyTest.items import ArticleItem class WxSpider(CrawlSpider): name = \u0026#39;wx\u0026#39; allowed_domains = [\u0026#39;wxapp-union.com\u0026#39;] start_urls = [\u0026#39;http://www.wxapp-union.com/portal.php?mod=list\u0026amp;catid=2\u0026amp;page=255\u0026#39;] rules = ( Rule(LinkExtractor(allow=r\u0026#39;.+mod=list\u0026amp;catid=2\u0026amp;page=\\d\u0026#39;), follow=True), Rule(LinkExtractor(allow=r\u0026#39;.+article-.+\\.html\u0026#39;),callback=\u0026#34;parse_item\u0026#34;,follow=False) ) def parse_item(self, response): title = response.xpath(\u0026#39;//h1[@class=\u0026#34;ph\u0026#34;]/text()\u0026#39;).get() author = response.xpath(\u0026#39;//p[@class=\u0026#34;authors\u0026#34;]//a\u0026#39;).get() _time = response.xpath(\u0026#39;//span[@class=\u0026#34;time\u0026#34;]/text()\u0026#39;).get() visitors = response.xpath(\u0026#39;//div[contains(@class,\u0026#34;focus_num\u0026#34;)]//a/text()\u0026#39;).get() pre_talk = response.xpath(\u0026#39;//div[@class=\u0026#34;blockquote\u0026#34;]//p/text()\u0026#39;).get() article_content = response.xpath(\u0026#39;//td[@id=\u0026#34;article_content\u0026#34;]\u0026#39;).get() item = ArticleItem(title=title,author=author,_time=_time,visitors=visitors,pre_talk=pre_talk,article_content=article_content) print(\u0026#39;*\u0026#39;*40) print(title) print(\u0026#39;*\u0026#39;*40) return item    首先rules定义了爬取链接规则，有两个规则，第一个规则是爬取页面的链接，每一页有多个文章的链接，而第二个规则则是定义爬取的具体文章内容的链接。 第一个规则需要Follow，因为需要根据每一页的内容查找文章的链接；而第二个规则是文章链接，故不需要继续Follow 第一个页面链接规则不需要回调函数，因为不需要解析，只需要获取文章链接；第二个文章链接规则则需要设置回调函数来对返回的文章网页内容进行解析。  parse_item说明：\n parse_item是解析页面返回内容的函数，其返回Item数据结构，使用Xpath分别获取数据结构各个元素的内容并且返回Item\n 保存数据  pipelines是一个最后处理Item的管道\n 在pipelines.py文件中新建pipleline对返回的Item进行处理，可以保存为文件，或者存储到数据库。\n首先文件中需要导入必要的库‘\n1 2 3 4 5  import re\t# 正则处理 from html2text import HTML2Text\t# 将网页转化为Markdown格式 from scrapy.exporters import JsonLinesItemExporter\t# 输出Json文件输出器 from urllib.parse import urljoin\t# 补全URL，因为有些URL只显示相对位置 import pymongo\t# MongoDB操作库   第一个Pipeline：保存到Json文件 程序的构造函数新建一个Json文件输出器，process_item进行数据的存储，关闭的时候close_spider会调用关闭文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 存储到Json文件中 class JsonPipeline(object): def __init__(self): self.f = open(\u0026#39;wxjc.json\u0026#39;,\u0026#39;wb\u0026#39;) self.exporter = JsonLinesItemExporter(self.f, ensure_ascii=False,encoding=\u0026#34;utf-8\u0026#34;) def process_item(self, item, spider): # 将内容转化为MarkDown格式 item[\u0026#39;article_content\u0026#39;] = convert_md(item[\u0026#39;article_content\u0026#39;]) self.exporter.export_item(item) return item def close_spider(self,spider): self.f.close()   第二个Pipeline：保存到Markdown文件 方法与第一发Pipeline类似，只是写文件使用最简单的追加方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 写入Markdown class MDPipeline(object): def __init__(self): self.f = open(\u0026#39;wx_teaches.md\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) def process_item(self,item,spider): if self.f: self.f.write(\u0026#39;\\n\u0026#39;) self.f.write(\u0026#34;# \u0026#34; + item[\u0026#39;title\u0026#39;] + \u0026#39;\\n\u0026#39;) header_info = \u0026#34;作者:{} 发布时间:{} Visitors:{}\\n\u0026#34;.format(item[\u0026#39;author\u0026#39;],item[\u0026#39;_time\u0026#39;],item[\u0026#39;visitors\u0026#39;]) self.f.write(header_info) self.f.write(\u0026#39;\u0026gt; \u0026#39; + item[\u0026#39;pre_talk\u0026#39;] + \u0026#39;\\n\u0026#39;) self.f.write(item[\u0026#39;article_content\u0026#39;]) return item def close_spider(self,spider): self.f.close()   第三个Pileline：保存到MongoDB 其中使用了类方法装饰器@classmethod,意思就是直接用类名调用该函数，就能够直接返回一个MongoPipeline类了，还定义了打开spider与关闭spider的操作，就是连接数据库与关闭数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 存储到MongoDB数据库 class MongoPipeline(object): def __init__(self,mongo_uri,mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls,crawler): return cls(mongo_uri = crawler.settings.get(\u0026#39;MONGO_URI\u0026#39;), mongo_db = crawler.settings.get(\u0026#39;MONGO_DB\u0026#39;)) def open_spider(self,spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db =self.client[self.mongo_db] def process_item(self,item,spider): name = item.__class__.__name__ # \u0026lt;a href=\\\u0026#34;space-uid-17761.html\\\u0026#34;\u0026gt;Rolan\u0026lt;/a\u0026gt;  item[\u0026#39;author\u0026#39;] = re.search(\u0026#39;\u0026lt;a.*?\u0026gt;(.*?)\u0026lt;/a\u0026gt;\u0026#39;,item[\u0026#39;author\u0026#39;]).group(1) self.db[name].insert(dict(item)) return item def close_spider(self,spider): self.client.close()    最后需要在settings.py中添加如下字段:\n1 2  MONGO_URI = \u0026#39;localhost\u0026#39; MONGO_DB = \u0026#39;WX\u0026#39;    最后需要在settings.py中添加如下字段 1 2 3 4 5 6 7 8 9  ITEM_PIPELINES = { \u0026#39;MyTest.pipelines.JsonPipeline\u0026#39;: 300, \u0026#39;MyTest.pipelines.MDPipeline\u0026#39;: 301, \u0026#39;MyTest.pipelines.MongoPipeline\u0026#39;: 400, } # 修改为False ROBOTSTXT_OBEY = False # 设置延迟1s DOWNLOAD_DELAY = 1   开始爬取 可以在项目目录中新建一个脚本start.py，文件内容如下，自动运行脚本\n1 2  from scrapy import cmdline cmdline.execute(\u0026#39;scrapy crawl test\u0026#39;.split(\u0026#39;\u0026#39;))   爬取结果 Json结果 Markdown结果 Markdown文件由于太大了使用Markdown文件打不开，只好使用文本编辑器打开\nMongoDB结果 ","description":"","id":41,"section":"posts","tags":["爬虫","Scrapy"],"title":"Scrapy框架","uri":"https://vhope.cf/zh/posts/spider/scrapy-1/"},{"content":"好的工具🗝 就成功了一半。\n工具🚡 创造与记录 GitBook 使用前提：  安装NodeJS 使用npm安装：npm install gitbook-cli -g(这是命令行工具)  GitNote GitMind GitMind 是一款全新的云端智能思维导图、流程图制作软件，同时支持在电脑、手机浏览器上使用。\n官网：https://gitmind.cn/\n微信版本：\nNotion Typora caliibre 信息聚合 irreader🔖 下载地址:http://irreader.fatecore.com/\n羽雀-云端知识库☁ 如果英语不好，或者看着英文的文档很烦恼，可以试试这个。🍃\n地址:https://www.yuque.com/\n图片   https://xinquji.com/r/d232a93deb8766\n  https://burst.shopify.com/\n ","description":"实用的工具集合","id":42,"section":"talks","tags":[""],"title":"Tools","uri":"https://vhope.cf/zh/talks/tools/"},{"content":"All about Intresting in Github.\nPython好玩的库 html2text  将网页转化为Markdown文件格式\n 使用前提： 1  pip install htmltotext   使用方法： 1 2 3  ## 转化为TEXT h = HTML2Text() text = h.handle(parse_html) # text为markdown文件   pypandoc  对文件进行任意的转换\n 使用前提： 安装pypandoc库：pip install pypandoc.\n使用方法 导入库:import pypandoc\nMarkdown \u0026mdash;\u0026ndash;\u0026gt; docx 1  output = pypandoc.convert_file(\u0026#39;somefile.md\u0026#39;, \u0026#39;docx\u0026#39;, outputfile=\u0026#34;somefile.docx\u0026#34;)   Markdown \u0026mdash;\u0026ndash;\u0026gt; Rst 1 2 3  output = pypandoc.convert_file(\u0026#39;somefile.md\u0026#39;, \u0026#39;rst\u0026#39;)\t# way1 output = pypandoc.convert_file(\u0026#39;somefile.txt\u0026#39;, \u0026#39;rst\u0026#39;, format=\u0026#39;md\u0026#39;)\t# way 2 output = pypandoc.convert_text(\u0026#39;#some title\u0026#39;, \u0026#39;rst\u0026#39;, format=\u0026#39;md\u0026#39;)\t# 直接转化文本    其中有对应的工具Pandoc\n 如何把 Markdown 文件批量转换为 PDF mdout转换脚本 项目地址:https://github.com/JabinGP/mdout\n使用方法：  打开项目地址查看，其中主要命令为:mdout filename -t pdf\n","description":"Github上好玩的那些库~","id":43,"section":"talks","tags":[""],"title":"Good库","uri":"https://vhope.cf/zh/talks/github-lib/"},{"content":"🚴一些收集视频的方法⚒\n视频归总方法 BiliBli视频嵌入代码 使用方法 首先找到嵌入代码\n然后复制代码到Markdown文件就可以得到如下显示效果：\n 代码如下: 1  \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=6731067\u0026amp;cid=10959711\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt;    其中可以在ifram中添加相关属性\n weibo上传的视频 使用方法 在微博中上传视频后，打开视频的页面，按F12打开工具,鼠标点击视频找到链接\n接下来直接在Markdown中添加代码\nYour browser does not support the video tag.\n代码如下:\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/03/02/GabXC4JmfN6H2hE.png\u0026#34; src=\u0026#34;https://f.video.weibocdn.com/00393mgEgx07BmNCEF4j01041200eeW00E010.mp4?label=mp4_720p\u0026amp;template=1280x720.25.0\u0026amp;trans_finger=721584770189073627c6ee9d880087b3\u0026amp;Expires=1583079687\u0026amp;ssig=%2BAmJANwAPn\u0026amp;KID=unistore,video\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   QQ空间发布的视频 使用方法 与微博的操作类似，打开视频页面，先点击下载按钮\n然后会自动跳转，搜索栏上的地址就是视频的地址\n接下来直接在Markdown中添加代码\nYour browser does not support the video tag.\n代码如下:\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/03/02/GabXC4JmfN6H2hE.png\u0026#34; src=\u0026#34;http://photovideo.photo.qq.com/1075_0b53zeiu6vidieapa3kya5pdbsiej6zqhfsa.f20.mp4?dis_k=97f710c26b204f7f2312614fbcf8f897\u0026amp;dis_t=1583082992\u0026amp;vuin=1427298682\u0026amp;save=1\u0026amp;d=1\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   ","description":"","id":44,"section":"posts","tags":["blog","视频","BliBli","weibo"],"title":"视频的收集","uri":"https://vhope.cf/zh/posts/settings/collect-videos/"},{"content":"在Pt页面增加了一些用JS实现的PPT，主要展示一些效果。🔌\n网页PPT 主题 beige black blood monokai league moon night serif simple solarized sky white 使用方法🌌 在markdown文件的ymal头部添加:revealTheme: serif\n在线制作PPT Slides https://slides.com/\n","description":"","id":45,"section":"posts","tags":["ppt","blog"],"title":"Slides和网页PPT","uri":"https://vhope.cf/zh/posts/settings/ppt-use/"},{"content":"数据分析，begin！📅\n Latex公式参考：\nhttps://www.cnblogs.com/1024th/p/11623258.html\n 概率分析\n中位数\n$$\n\\frac{df(x)}{dx}\\mid_{x_{mode}=0}\n$$\n​\n","description":"","id":48,"section":"posts","tags":["概率","Latex"],"title":"Data Analysis Begin","uri":"https://vhope.cf/zh/posts/bigdata/data-analysis-begin/"},{"content":"使用MXNet的好处你永远想象不到。🉑\n本地环境搭建教程  参考:\nhttps://discuss.gluon.ai/t/topic/13576?u=bigbigwolf-ai\n 范数 L0范数：指向量中非0元素的个数。（难优化求解）\nL1范数：指向量中各个元素的绝对值之和\nL2范数：指向量各元素的平方和然后求平方根\n设$n$维向量$x$中的元素为$x_1, \\ldots, x_n$。向量$x$的$L_{p}$范数为:\n$$\n|\\boldsymbol{x}|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.\n$$\n$L_{1}$范数：\n$$\n|\\boldsymbol{x}|_1 = \\sum_{i=1}^n \\left|x_i \\right|.\n$$\n$L_{2}$范数：\n$$\n|\\boldsymbol{x}|_2 = \\sqrt{\\sum_{i=1}^n x_i^2}.\n$$\n设$X$是一个$m$行$n$列矩阵。矩阵$X$的Frobenius范数为该矩阵元素平方和的平方根：\n$$\n|\\boldsymbol{X}|_F = \\sqrt{\\sum_{i=1}^m \\sum_{j=1}^n x_{ij}^2},\n$$\n查阅文档 1 2  from mxnet import nd print(dir(nd.random))   ['NDArray', '_Null', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_internal', '_random_helper', 'current_context', 'exponential', 'exponential_like', 'gamma', 'gamma_like', 'generalized_negative_binomial', 'generalized_negative_binomial_like', 'multinomial', 'negative_binomial', 'negative_binomial_like', 'normal', 'normal_like', 'numeric_types', 'poisson', 'poisson_like', 'randint', 'randn', 'shuffle', 'uniform', 'uniform_like']  help函数可以查询具体的函数作用及用法\n1  help(nd.ones_like)   Help on function ones_like: ones_like(data=None, out=None, name=None, **kwargs) Return an array of ones with the same shape and type as the input array. Examples:: x = [[ 0., 0., 0.], [ 0., 0., 0.]] ones_like(x) = [[ 1., 1., 1.], [ 1, 1., 1.]] Parameters ---------- data : NDArray The input out : NDArray, optional The output NDArray to hold the result. Returns ------- out : NDArray or list of NDArrays The output of this function.  线性回归 导入必要的库\n1 2 3 4 5  %matplotlib inline from IPython import display from matplotlib import pyplot as plt from mxnet import autograd, nd import random   生成数据集，其中每个例子输入数据个数为2，有1000个数据\n1 2 3 4 5 6 7  num_inputs = 2 num_examples = 1000 true_w = nd.array([2, -3.4]) true_b = nd.array([4.2]) features = nd.random.normal(scale=1, shape=(num_examples, num_inputs)) labels = nd.dot(true_w,features.T) + true_b labels += nd.random.normal(scale=0.01, shape=labels.shape)   查看数据\n1  features[0], labels[0]   ( [ 0.28752208 -0.04466231] \u0026lt;NDArray 2 @cpu(0)\u0026gt;, [4.927063] \u0026lt;NDArray 1 @cpu(0)\u0026gt;)  定义相关函数\n1 2 3 4 5 6 7 8 9 10 11  def use_svg_display(): # 用矢量图显示 display.set_matplotlib_formats(\u0026#39;svg\u0026#39;) def set_figsize(figsize=(3.5, 2.5)): use_svg_display() # 设置图的尺寸 plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = figsize set_figsize() plt.scatter(features[:, 1].asnumpy(), labels.asnumpy(), 1); # 加分号只显示图   data_iter函数作用:\n 扰乱读取顺序，使得读取随机 按Batch_size分段取数据，需要判断是否到结尾，使用yield构建生成器节省内存  1 2 3 4 5 6 7 8  # 本函数已保存在d2lzh包中方便以后使用 def data_iter(batch_size, features, labels): num_examples = len(features) indices = list(range(num_examples)) random.shuffle(indices) # 样本的读取顺序是随机的 for i in range(0, num_examples, batch_size): j = nd.array(indices[i: min(i + batch_size, num_examples)]) yield features.take(j), labels.take(j) # take函数根据索引返回对应元素   1 2 3 4 5  batch_size = 10 for X, y in data_iter(batch_size, features, labels): print(X, y) break   [[-0.65439206 0.74410725] [ 0.69013244 -0.6483847 ] [-0.59409887 0.3589477 ] [-0.47491348 0.6438462 ] [ 0.5074032 0.42834154] [-0.18589513 -0.21707669] [ 0.70281196 -1.3320632 ] [ 1.2072632 1.6909351 ] [-0.17264698 -1.5742793 ] [-1.6516455 -0.29966688]] \u0026lt;NDArray 10x2 @cpu(0)\u0026gt; [ 0.37379816 7.7938933 1.7758217 1.0414512 3.743439 4.5605783 10.148926 0.84148276 9.19984 1.9295483 ] \u0026lt;NDArray 10 @cpu(0)\u0026gt;  初始化\n1 2  w = nd.random.normal(scale=0.01, shape=(num_inputs, 1)) b = nd.zeros(shape=(1,))   添加保存梯度的空间\n1 2  w.attach_grad() b.attach_grad()   1 2  def linreg(X, w, b): # 本函数已保存在d2lzh包中方便以后使用 return nd.dot(X, w) + b   1 2  def squared_loss(y_hat, y): # 本函数已保存在d2lzh包中方便以后使用 return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2   1 2 3  def sgd(params, lr, batch_size): # 本函数已保存在d2lzh包中方便以后使用 for param in params: param[:] = param - lr * param.grad / batch_size   开始训练\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  lr = 0.03 num_epochs = 3 net = linreg loss = squared_loss for epoch in range(num_epochs): # 训练模型一共需要num_epochs个迭代周期 # 在每一个迭代周期中，会使用训练数据集中所有样本一次（假设样本数能够被批量大小整除）。X # 和y分别是小批量样本的特征和标签 for X, y in data_iter(batch_size, features, labels): with autograd.record(): l = loss(net(X, w, b), y) # l是有关小批量X和y的损失 l.backward() # 小批量的损失对模型参数求梯度 sgd([w, b], lr, batch_size) # 使用小批量随机梯度下降迭代模型参数 train_l = loss(net(features, w, b), labels) print(\u0026#39;epoch %d, loss %f\u0026#39; % (epoch + 1, train_l.mean().asnumpy()))   epoch 1, loss 0.040809 epoch 2, loss 0.000157 epoch 3, loss 0.000051  对比\n1  true_w, w   ( [ 2. -3.4] \u0026lt;NDArray 2 @cpu(0)\u0026gt;, [[ 1.9991481] [-3.3992586]] \u0026lt;NDArray 2x1 @cpu(0)\u0026gt;)  1  true_b, b   ( [4.2] \u0026lt;NDArray 1 @cpu(0)\u0026gt;, [4.19921] \u0026lt;NDArray 1 @cpu(0)\u0026gt;) ","description":"","id":49,"section":"posts","tags":["python","MXNet","深度学习","liner"],"title":"MXNet回顾","uri":"https://vhope.cf/zh/posts/dl/mxnet-begin/"},{"content":"重新学习一下DL，这次使用PyTorch框架🔦\n 参考资料：\nhttps://github.com/dsgiitr/d2l-pytorch\n 导入PyTorch库 1 2  import torch import numpy as np   创建Tensor 5x3的未初始化的张量\n1 2  x = torch.empty(5,3) x   tensor([[1.0286e-38, 9.0919e-39, 8.9082e-39], [9.2755e-39, 8.4490e-39, 1.0194e-38], [9.0919e-39, 8.4490e-39, 8.7245e-39], [1.0102e-38, 1.0653e-38, 8.7245e-39], [1.0286e-38, 9.6429e-39, 4.2244e-39]])  5x3随机初始化的张量\n1 2  x = torch.rand(5,3) x   tensor([[0.2518, 0.0419, 0.3233], [0.1493, 0.1408, 0.8559], [0.5145, 0.4648, 0.4605], [0.2555, 0.2502, 0.4506], [0.9798, 0.5056, 0.2726]])  5x3全0的张量\n1 2  x = torch.zeros(5,3) # 可以指定类型 x = torch.zeros(5,3,dtype=torch.long) x   tensor([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])  数据张量\n1 2  x = torch.tensor([5.5,3]) x   tensor([5.5000, 3.0000])  默认创建和原来的张量一样的dtype和device的张量，也可以另外设置\n1 2 3 4  x = x.new_ones(5,3,dtype=torch.double) print(x) x = torch.randn_like(x,dtype=torch.float) print(x)   tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) tensor([[-0.7829, -0.4010, 0.3230], [ 0.2660, 0.4766, 0.3186], [ 0.6096, 1.1226, -1.7942], [ 1.3255, 0.1835, -0.9078], [ 1.7743, -0.0944, -0.1704]])  获取Tensor的形状\n1  x.shape,x.size()   (torch.Size([5, 3]), torch.Size([5, 3]))  其他创建Tensor的函数:\n   函数 功能     Tensor(*sizes) 基础构造函数   tensor(data,) 类似np.array的构造函数   ones(*sizes) 全1Tensor   zeros(*sizes) 全0Tensor   eye(*sizes) 对角线为1，其他为0   arange(s,e,step) 从s到e，步长为step   linspace(s,e,steps) 从s到e，均匀切分成steps份   rand/randn(*sizes) 均匀/标准分布   normal(mean,std)/uniform(from,to) 正态分布/均匀分布   randperm(m) 随机排列     这些创建方法都可以在创建的时候指定数据类型dtype和存放device(cpu/gpu)\n 操作 1 2 3  x = torch.rand(5,3) y = torch.rand(5,3) x,y   (tensor([[0.7706, 0.7674, 0.0476], [0.3675, 0.3652, 0.1215], [0.2842, 0.4927, 0.0903], [0.1202, 0.7635, 0.1862], [0.1391, 0.5023, 0.0580]]), tensor([[0.2149, 0.4744, 0.6664], [0.5948, 0.3451, 0.6485], [0.2303, 0.6660, 0.3796], [0.7194, 0.3815, 0.7536], [0.7886, 0.0630, 0.2459]]))  加法，三种方法\n1 2 3 4  z1 = torch.add(x,y) z2 = x.add_(y) # x会改变 z3 = x + y z1,z2,z3   (tensor([[0.9855, 1.2418, 0.7140], [0.9623, 0.7103, 0.7700], [0.5145, 1.1588, 0.4699], [0.8396, 1.1450, 0.9397], [0.9276, 0.5653, 0.3040]]), tensor([[0.9855, 1.2418, 0.7140], [0.9623, 0.7103, 0.7700], [0.5145, 1.1588, 0.4699], [0.8396, 1.1450, 0.9397], [0.9276, 0.5653, 0.3040]]), tensor([[1.2004, 1.7163, 1.3804], [1.5571, 1.0554, 1.4185], [0.7448, 1.8248, 0.8495], [1.5590, 1.5265, 1.6933], [1.7162, 0.6283, 0.5499]]))  索引\n1 2  y = x[0, :] y   tensor([0.9855, 1.2418, 0.7140])  修改y会修改原来的数据，因为共享内存\n1 2 3  y+=1 print(y) print(x[0,:])   tensor([1.9855, 2.2418, 1.7140]) tensor([1.9855, 2.2418, 1.7140])  PyTorch还提供了一些高级的选择函数:\n   函数 功能     index_select(input, dim, index) 在指定维度dim上选取，比如选取某些行、某些列   masked_select(input, mask) 例子如上，a[a\u0026gt;0]，使用ByteTensor进行选取   nonzero(input) 非0元素的下标   gather(input, dim, index) 根据index，在dim维度上选取数据，输出的size与index一样    改变形状 用view()来改变Tensor的形状：\n1 2 3  y = x.view(15) z = x.view(-1,5) # -1为自动计算维度 print(x.size(),y.size(),z.size())   torch.Size([5, 3]) torch.Size([15]) torch.Size([3, 5])   注意view()返回的新Tensor与源Tensor虽然可能有不同的size，但是是共享data的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，view仅仅是改变了对这个张量的观察角度，内部数据并未改变)\n 1 2  x += 1 x,y   (tensor([[4.9855, 5.2418, 4.7140], [3.9623, 3.7103, 3.7700], [3.5145, 4.1588, 3.4699], [3.8396, 4.1450, 3.9397], [3.9276, 3.5653, 3.3040]]), tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040]))  使用reshape()函数会拷贝一份\n1 2  y = x.reshape(15) y   tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040])  也可以使用克隆后view\n 使用clone还有一个好处是会被记录在计算图中，即梯度回传到副本时也会传到源Tensor。\n 1 2  y = x.clone().view(15) y   tensor([4.9855, 5.2418, 4.7140, 3.9623, 3.7103, 3.7700, 3.5145, 4.1588, 3.4699, 3.8396, 4.1450, 3.9397, 3.9276, 3.5653, 3.3040])  item(), 它可以将一个标量Tensor转换成一个Python number：\n1 2 3  x = torch.randn(1) print(x) print(x.item())   tensor([0.3816]) 0.3816383183002472  线性代数API    函数 功能     trace 对角线元素之和(矩阵的迹)   diag 对角线元素   triu/tril 矩阵的上三角/下三角，可指定偏移量   mm/bmm 矩阵乘法，batch的矩阵乘法   addmm/addbmm/addmv/addr/baddbmm.. 矩阵运算   t 转置   dot/cross 内积/外积   inverse 求逆矩阵   svd 奇异值分解    广播机制 什么是广播机制？简单的说就是形状不同的运算会自动变换为适合的运算\n1 2 3 4 5  x = torch.arange(3).view(1,3) print(x) y = torch.arange(2).view(2,1) print(y) print(x + y)   tensor([[0, 1, 2]]) tensor([[0], [1]]) tensor([[0, 1, 2], [1, 2, 3]]) ","description":"","id":50,"section":"posts","tags":["PyTorch","python","Tensor"],"title":"Pytorch Begin","uri":"https://vhope.cf/zh/posts/dl/pytorch-begin/"},{"content":"一份还算可以的翻墙清单📇\n本文介绍的方法归总: PC端 Mobile端   谷歌访问助手 插件(可以现在极简插件中下载） Astar VPN 插件 SSR    云帆VPN 老王VPN     'use strict'; var containerId = JSON.parse(\"\\\"635a6660b3cf14fc\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  PC端 谷歌访问助手 首先是不能通过谷歌的应用商店下载的，可以在国内的一些插件网站下载，这些推荐极简插件，找到谷歌访问助手进行下载。\n将CRT文件拖入谷歌浏览器的拓展程序界面中(这里用的助手是另一个版本)\n之后就可以访问谷歌的一部分服务了，例如谷歌搜索，Gmail，谷歌应用商店.\n安装过程可能会出现一些问题，具体可以参考:安装指引    其他类似的插件   PP谷歌访问助手:https://chrome.zzzmh.cn/info?token=kahndhhhcnignmbbpiobmdlgjhgfkfil 集装箱:https://chrome.zzzmh.cn/info?token=kbgigmcnifmaklccibmlepmahpfdhjch 谷歌访问助手:https://chrome.zzzmh.cn/info?token=gocklaboggjfkolaknpbhddbaopcepfp 谷歌学术助手:https://chrome.zzzmh.cn/info?token=jkicnibdkfemnfhojeajbldjgdddpajk 谷歌服务助手:https://chrome.zzzmh.cn/info?token=cgncbhnhlkbdieckbbmeppcefokppagh 谷歌上网助手:https://chrome.zzzmh.cn/info?token=nonmafimegllfoonjgplbabhmgfanaka    Astar VPN Astar VPN也是一个Chrome插件，在谷歌应用商店可以下载。经过第一步之后，we\u0026rsquo;re good to go!😁\n应用商店搜索Astar VPN进行下载，直接就可以在Chrome中进行自动安装。\n之后再插件选项中开启该插件，其中可以选择不同的服务器进行连接，速度还不错。\n使用该插件进行科学上网是真正意义上的，它可以访问国外任何网站!  ShadowsSocks ShadowsSocks是一款在github上的开源软件，可以用来进行连接节点服务器，但是节点需要自己去找，下面会介绍节点的选择。\n首先去github下载这个软件，链接为：https://github.com/shadowsocks/shadowsocks-windows/releases/tag/4.1.9.2\n将两个文件解压之后，将第一个文件夹内的exe文件移动到第二个文件夹的根目录并且打开即可\n关于免费节点，这里有一个网址：https://free-ss.site/(需要科学上网)\n右键ShadowSocks的图标，选择服务器，在选择扫描屏幕二维码，即可添加节点，之后点击系统代理并开启系统代理为全局模式。\n之后就可以🤙🤙🤙!\nMobile端 下面两个软件都是需要科学上网的，建议先在PC端下载再传到手机安装。  云帆VPN 下载地址：https://apkpure.com/store/apps/details?id=cc.dingnet.yunfangp\n虽然每天只能使用1小时，但是基本够了。\n老王VPN 下载地址：https://apkpure.com/wang-vpn-%E2%9D%A4%EF%B8%8F-free-fast-stable-best-vpn-just-try-it/com.findtheway\n老王的东西永远免费！\n参考链接\n 2020年Android高速稳定翻墙方法 Windows上长期有效的免费且高速稳定翻墙法！ ","description":"","id":51,"section":"posts","tags":["科学上网","ShadowShocks"],"title":"2020翻墙指南👈","uri":"https://vhope.cf/zh/posts/settings/2020-fanqiang/"},{"content":"👱‍♀介绍一些markdown中比较实用的一些写作方法。\n任务列表✍  a task list item list syntax required normal formatting, @mentions, #1234 refs incomplete completed  上面的代码如下：\n1 2 3 4 5  - [ ] a task list item - [ ] list syntax required - [ ] normal **formatting**, @mentions, #1234 refs - [ ] incomplete - [x] completed   数学公式📐 使用MathJax渲染LaTeX数学表达式。💡\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\n\\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\\n\\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\\n\\end{vmatrix}\n$$\n上面的代码如下：\n1 2 3 4 5 6 7  $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\\\\\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\\\\\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\\\\\ \\end{vmatrix} $$   $$\n\\begin{align*}\ny = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\n\u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\n\u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\n\u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\n\u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\n\u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t)\n\\end{align*}\n$$\n上面代码如下：\n1 2 3 4 5 6 7 8 9 10  $$ \\begin{align*} y = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\\\\ \u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\\\\ \u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\\\\ \u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\\\\ \u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\\\\ \u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{align*} $$   脚注👣 如下是使用的代码，将鼠标悬停在“ fn1”或“ fn2”上标上可以查看脚注的内容。您可以将任何喜欢的唯一标识用作脚注标记（例如“ fn1”）。\n1 2  [^fn1]: Here is the *text* of the first **footnote**. [^fn2]: Here is the *text* of the second **footnote**   你也可以内嵌脚注，就像^[Here is the text of the first footnote.]\n水平线〰 🌟在空行输入***或---，如下：\nYMAL首要事项🤔 包含YAML前事块的文件将作为特殊文件进行处理，下面是一个例子\n1 2 3 4  ---layout:posttitle:BloggingLikeaHacker---  目录📑 输入[toc]并回车即可。\n内部链接🔗 这是一个跳转到任务列表的链接,this link ！\n代码如下：\n1  [this link](#任务列表✍)   参考链接📖 参考链接使用两组方括号的格式，第一个是显示的文字，第二个括号内是查找的id，代码如下：\n1 2 3 4 5  This is [an example][id] reference-style link. Then, anywhere in the document, you define your link label on a line by itself like this: [id]: http://example.com/ \u0026#34;Optional Title Here\u0026#34;   隐式链接，直接使用Google查阅：\n[Google][] And then define the link: [Google]: http://google.com/ 删除线❌ 删除Mistaken text.，代码为~~Mistaken text.~~\n高亮🔆 ==highlight==，使用两个等号在两边进行包围，代码如下：\n1  ==highlight==   插入视频📹 Your browser does not support the video tag.\n上面的代码即：\n1  \u0026lt;video poster=\u0026#34;https://i.loli.net/2020/02/29/S4oN2djFDZYiqAx.png\u0026#34; src=\u0026#34;https://files.catbox.moe/bqrntc.flv\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; loop=\u0026#34;loop\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the video tag.\u0026lt;/video\u0026gt;   插入音乐🎼 Your browser does not support the audio tag.\n上面的代码即：\n1  \u0026lt;audio src=\u0026#34;https://files.catbox.moe/wjiywu.mp3\u0026#34; style=\u0026#34;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;\u0026#34; controls=\u0026#34;controls\u0026#34; loop=\u0026#34;loop\u0026#34; preload=\u0026#34;meta\u0026#34;\u0026gt;Your browser does not support the audio tag.\u0026lt;/audio\u0026gt;   更多：\n随机图片🌳 网址:https://picsum.photos/1920/1080\n","description":"","id":52,"section":"posts","tags":["markdown","Typora"],"title":"Markdown深入使用","uri":"https://vhope.cf/zh/posts/settings/markdown-deep/"},{"content":"SM.MS sm.ms 支持的图片格式包括 JPG、JPEG、GIF、PNG 及 BMP，单档不超过 5 MB，单次可上传图片最大 10 张。图片永久保存，请勿上传政治相关图片\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤(15 年成立)\n如优图床 支持大量免费图床分发，网站稳定性未知\n速度：动态 ❤ ❤ ❤ ❤ ❤\n牛图网 速度：日本服务器 ❤ ❤ ❤ ❤(2010 年)\nniupic.com 稳定性不错，不要上传违法图片\nvim-cn 上传界面十分简单，但十分稳定。\n速度： ❤ ❤ ❤(12年到现在)\nimgbb 无需注册，支持最大 16M 图片上传，支持 https，速度不错\n速度：亚太服务器 ❤ ❤ ❤ ❤\nmeotu 16 年成立的免费图片外链网站。上传下载速度快。\n需要注册，默认原图上传，支持 https\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\n遇见图床 18 年成立的免费图片外链网站。上传下载速度快。\n需要注册，默认原图上传，支持最大 10M，支持 https\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\nz4a 图床 需要注册，支持 HTTPS 速度块\n速度：高速服务器 ❤ ❤ ❤ ❤ ❤\nz4a.net 由于成立时间较短，稳定性未知。\nupload 2012 年成立的免费图片上传外链网站，至今依然稳定\n无需注册，默认原图上传，支持 https\n速度：亚太服务器 ❤ ❤ ❤\ncatbox 无需注册，支持 https\n速度：海外服务器 ❤ ❤ ❤\ncatbox.moe 支持 200m 主流格式文件外链网站\n","description":"","id":53,"section":"posts","tags":["photo","图床"],"title":"几款好用的图床","uri":"https://vhope.cf/zh/posts/settings/free-image-bed/"},{"content":"Freenom 是目前为数不多的免费域名提供商，提供 .ga, .ml, .gq, .tk, .cf 五个免费顶级域。当然也有一些付费的域名，对于普通人来说，免费域名就够了。😏\n第一步，找域名 打开Freenom，登陆后直接在搜索栏搜索自己想要的域名名字，然后系统会返回可以使用的免费域名，选择一个结算即可\n第二步，配置解析服务 使用cloudflare解析服务 打开cloudflare，首先需要注册一个账号。然后他会要求输入需要解析的域名\n填写相应的DNS信息，并且将下面的NS信息填写到freenom的custom nameservers\n等待个几分钟就好了。Over 🤞\n","description":"","id":54,"section":"posts","tags":["域名","freenom"],"title":"Freenom 免费域名申请","uri":"https://vhope.cf/zh/posts/settings/freenom-domain/"},{"content":"安装MinGW之后，我们可以那它来作为C或C++的编译器.🕸\nCMD编译程序  编译过程分为四个步骤：预处理、编译、汇编、链接。\n 使用g++可以在命令行分别实现上面四个步骤。使用下面的程序作为例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; // this is my test program  #ifndef myNum#define myNum 666 #endifint main() { cout \u0026lt;\u0026lt; \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;myNum = \u0026#34; \u0026lt;\u0026lt; myNum \u0026lt;\u0026lt;endl; return 0; }   预处理 预处理主要完成的工作有：\n（1）删除#define，展开宏；\n（2）处理条件编译指令，预处理程序先判断条件，在根据条件修改源代码；\n（3）删除注释；\n（4）添加行号，以及文件名标识，便于调试\n（5）删除“#include”，插入相应的头文件；\n 使用下面的命令，得到预处理后的文件test.i\n1  g++ -E test.cpp -o test.i   查看test.i文件\n编译 使用下面的代码生成汇编文件test.s\n1  g++ -S test.i -o test.s   注意：直接从test.cpp文件得到汇编文件也可以。直接使用命令 g++ -S test.cpp -o test.s  查看test.s文件\n汇编 使用下面的命令将汇编指令转化为机器指令，生成文件test.o\n1  g++ -c test.s -o test.o   查看文件test.o\n链接 通过链接库文件，可以将目标文件test.o转化为可执行文件test.exe\n注意:Windows下可执行文件的后缀为exe，而Linux下不需要后缀。  CMD输入以下代码\n1  g++ test.o -o test.exe   注意:Windows下.o文件已经可以执行，在命令行输入test.o就可以看到如下的效果：\n 另外一个命令是\n1  g++ test.o -o test.exe -L 所需库文件路径   其中L为link的缩写。 快速生成可执行文件 一般情况下，可以直接使用g++ test.cpp -o test 就可以生成可执行程序了。\n运行程序 如下：\nMinGW + SublimeText配置C++环境 下载MinGW和SublimeText SublimeText下载\nMinGW下载及相关配置\n使用SublimeText 因为前面配置好环境变量了，所以可以直接在SublimeText下编译运行程序\nTools-\u0026gt;build(或者按快捷键Ctrl+B 或 Ctrl + Shift + B)\n可以在最下面一栏看到输出结果\nenjoy it!\n解决SublimeText下不能使用输入的问题 SublimeText是把shell执行的结果读回来显示在终端，这意味无法使用输入语句，无法使用调试功能。  解决方法:让程序直接运行在CMD\n在sublime-\u0026gt;Tools\u0026gt;Build System里新建编译系统，输入以下内容构建C++编译环境,保存名字为C++Buider\n1 2 3 4 5 6 7 8 9 10 11 12  {\u0026#34;cmd\u0026#34;: [\u0026#34;g++\u0026#34;,\u0026#34;$file_name\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_base_name}\u0026#34;,\u0026#34;-lm\u0026#34;,\u0026#34;-Wall\u0026#34;],\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c, source.c++\u0026#34;,\u0026#34;shell\u0026#34;: false,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;,\u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;,\u0026#34;/c\u0026#34;,\u0026#34;g++\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;${file}\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;,\u0026#34;\u0026amp;\u0026amp;\u0026#34;,\u0026#34;start\u0026#34;,\u0026#34;cmd\u0026#34;,\u0026#34;/k\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;]}]}  然后可以使用快捷键Ctrl + Shift + B，会显示如下，使用命令行打开模式选项即可\n结果如下：\n其他编译环境的配置也类似：\nC编译配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12  {\u0026#34;cmd\u0026#34;: [\u0026#34;gcc\u0026#34;,\u0026#34;$file_name\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_base_name}\u0026#34;,\u0026#34;-lm\u0026#34;,\u0026#34;-Wall\u0026#34;],\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c, source.c++\u0026#34;,\u0026#34;shell\u0026#34;: false,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;,\u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;,\u0026#34;/c\u0026#34;,\u0026#34;gcc\u0026#34;,\u0026#34;-g\u0026#34;,\u0026#34;${file}\u0026#34;,\u0026#34;-o\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;,\u0026#34;\u0026amp;\u0026amp;\u0026#34;,\u0026#34;start\u0026#34;,\u0026#34;cmd\u0026#34;,\u0026#34;/k\u0026#34;,\u0026#34;${file_path}/${file_base_name}\u0026#34;]}]}  Java编译配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  { \u0026#34;cmd\u0026#34;: [\u0026#34;javac\u0026#34;, \u0026#34;$file_name\u0026#34;], \u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;source.java\u0026#34;, \u0026#34;shell\u0026#34;: false, \u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;, \u0026#34;variants\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RunInCommand\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;javac\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;\u0026amp;\u0026amp;\u0026#34;, \u0026#34;start\u0026#34;, \u0026#34;cmd\u0026#34;, \u0026#34;/k\u0026#34;, \u0026#34;java $file_name\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;javac\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;\u0026amp;\u0026amp;\u0026#34;, \u0026#34;start\u0026#34;, \u0026#34;cmd\u0026#34;, \u0026#34;/k\u0026#34;, \u0026#34;gdb ${file_path}/${file_base_name}\u0026#34;] }] }   解决不能输入中文的问题 使用下面的编译配置文件即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  {\u0026#34;encoding\u0026#34;: \u0026#34;GBK\u0026#34;,\u0026#34;working_dir\u0026#34;: \u0026#34;$file_path\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file_name\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34;\u0026#34;,\u0026#34;file_regex\u0026#34;: \u0026#34;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026#34;,\u0026#34;selector\u0026#34;: \u0026#34;source.c++\u0026#34;,\u0026#34;variants\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;Run in sublime\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file_name\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; cmd /c \\\u0026#34;${file_path}/${file_base_name}\\\u0026#34;\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;CMD Run\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -Wall -std=c++11 \\\u0026#34;$file\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; start cmd /c \\\u0026#34;\\\u0026#34;${file_path}/${file_base_name}\\\u0026#34; \u0026amp; pause\\\u0026#34;\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;gdb Debug\u0026#34;,\u0026#34;shell_cmd\u0026#34;: \u0026#34;g++ -fexec-charset=GBK -g -std=c++11 \\\u0026#34;$file\\\u0026#34; -o \\\u0026#34;$file_base_name\\\u0026#34; \u0026amp;\u0026amp; start cmd /c gdb ${file_path}/${file_base_name} \u0026amp; pause\u0026#34;}]}  配置代码格式化 从菜单里选View-\u0026gt;Show Console，跳出Console，下面有一行输入的（光标位置），把下面这段代码输入进去回车(只适用sublime Text 3)\n1  import urllib.request,os; pf = \u0026#39;Package Control.sublime-package\u0026#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), \u0026#39;wb\u0026#39;).write(urllib.request.urlopen( \u0026#39;http://sublime.wbond.net/\u0026#39; + pf.replace(\u0026#39;\u0026#39;,\u0026#39;%20\u0026#39;)).read())   安装CoolFormat，按Ctrl+Shift+P，然后输入install,就会出现“Package Control: Install Package”，输入CoolFormat进行下载，下载完成之后输入Ctrl+Shift+P，然后输入CoolFormat，选下Formatter Settings，可以看到如下配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ;Pleasevisithttp://akof1314.github.io/CoolFormat/doc/index.htmlformoreinformation[SynTidy]C++=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;Java=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;C#=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;Objective-C=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;HTML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-fu-js-ll-n-ox-pe-qa-qn-m-wa-wj-wp-ws-sw-fo-i0-d1-ce0-ie0-oe0-w0-sbo0\u0026#34;\u0026#34;XML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-js-ll-n-ix-qa-qn-m-wa-wj-wp-ws-sw-fo-i1-ce0-ie0-oe0-w0\u0026#34;\u0026#34;PHP=\u0026#34;\u0026#34;-sas-icd-samt-salo-saeo-saro-sabo-saao-samp-aas-rsl-iel-rpc-rst-st\u0026#34;\u0026#34;JavaScript=\u0026#34;\u0026#34;-nb-cn4\u0026#34;\u0026#34;CSS=\u0026#34;\u0026#34;-c2-rub-cl0-os1-cc-cf-cfp0-rs2\u0026#34;\u0026#34;JSON=\u0026#34;\u0026#34;-cn3\u0026#34;\u0026#34;SQL=\u0026#34;\u0026#34;-cn2-el-ml0\u0026#34;\u0026#34;Verilog=\u0026#34;\u0026#34;-A1\u0026#34;\u0026#34;  建立快捷键\n进入菜单选Preferences-\u0026gt;Browse Packages，然后进CoolFormat，里面有个Default.sublime-keymap\n打开后，里面有快捷方式的按键,更改如下：\n1 2 3 4 5 6 7 8 9  [{\u0026#34;keys\u0026#34;: [\u0026#34;ctrl+q\u0026#34;], \u0026#34;command\u0026#34;: \u0026#34;coolformat\u0026#34;, \u0026#34;args\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;quickFormat\u0026#34;}},{\u0026#34;keys\u0026#34;: [\u0026#34;ctrl+alt+shift+s\u0026#34;], \u0026#34;command\u0026#34;: \u0026#34;coolformat\u0026#34;, \u0026#34;args\u0026#34;: {\u0026#34;action\u0026#34;: \u0026#34;selectedFormat\u0026#34;}}]   这样以后写完的代码直接按 “Ctrl+Q” 便可以格式化代码\n 另一种格式化代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ;Pleasevisithttp://akof1314.github.io/CoolFormat/doc/index.htmlformoreinformation[SynTidy]C++=\u0026#34;\u0026#34;-A2-p-N-Y-o-T-N-k3\u0026#34;\u0026#34;Java=\u0026#34;\u0026#34;-A1-p-N-T-Y-k3\u0026#34;\u0026#34;C#=\u0026#34;\u0026#34;-A1-p-N-Y-T-k3\u0026#34;\u0026#34;Objective-C=\u0026#34;\u0026#34;-A1-p-N-Y-k3\u0026#34;\u0026#34;HTML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-fu-js-ll-n-ox-pe-qa-qn-m-wa-wj-wp-ws-sw-fo-i0-d1-ce0-ie0-oe0-w0-sbo0\u0026#34;\u0026#34;XML=\u0026#34;\u0026#34;-aan-dep-fb-fbc-js-ll-n-ix-qa-qn-m-wa-wj-wp-ws-sw-fo-i1-ce0-ie0-oe0-w0\u0026#34;\u0026#34;PHP=\u0026#34;\u0026#34;-sas-icd-samt-salo-saeo-saro-sabo-saao-samp-aas-rsl-iel-rpc-rst-st\u0026#34;\u0026#34;JavaScript=\u0026#34;\u0026#34;-nb-cn4\u0026#34;\u0026#34;CSS=\u0026#34;\u0026#34;-c2-rub-cl0-os1-cc-cf-cfp0-rs2\u0026#34;\u0026#34;JSON=\u0026#34;\u0026#34;-cn3\u0026#34;\u0026#34;SQL=\u0026#34;\u0026#34;-cn2-el-ml0\u0026#34;\u0026#34;  ","description":"","id":55,"section":"posts","tags":[""],"title":"MinGW在Windows的使用","uri":"https://vhope.cf/zh/posts/settings/mingw-use/"},{"content":"HUGO + Github + Github Action持续集成部署个人博客\nHUGO本地环境 首先在HUGO的官网下载Hugo的Windows安装包，然后将路径添加到环境变量即可。\nstep1:下载hugo\nstep2:配置环境变量\nHUGO站点配置及主题配置 创建站点 在目录下直接输入下面的代码即可创建一个名为blog的hugo站点(注意：新建的站点是没有自带主题的)\n1  hugo new site blog   或者进入blog文件夹内直接输入以下语句：\n1  hugo new site .   下载主题 可以在hugo theme下载主题，然后根据主题的文档进行配置\n放到站点文件夹themes内，配置config.toml\n本地测试运行 输入hugo server测试\nGithub配置 创建站点仓库并且设置GithubPage 可以在Setting中看见如下：\n创建一个存储项目的仓库 配置Github Action 首先在项目仓库点击action，选择Simple workflow，输入一下的配置代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  name:CI#自动化的名称on:push:# push的时候触发branches:# 那些分支需要触发- masterjobs:build:runs-on:ubuntu-latest# 镜像市场steps:- name:checkout# 步骤的名称uses:actions/checkout@v1#软件市场的名称with:# 参数submodules:true- name:SetupHugouses:peaceiris/actions-hugo@v2.2.2with:hugo-version:\u0026#39;0.64.1\u0026#39;extended:true- name:Buildrun:hugo-D- name:Deployuses:peaceiris/actions-gh-pages@v2.5.1env:ACTIONS_DEPLOY_KEY:${{secrets.ACTIONS_DEPLOY_KEY}}EXTERNAL_REPOSITORY:redisread/redisread.github.ioPUBLISH_BRANCH:masterPUBLISH_DIR:./public  准备部署，我们开发的项目及github pages实际是分开的，一个用于保存项目，相当于源代码，另外一个用于保存最终的网页文件。\n  使用git生成ssh key(相当于生成对密钥)\n1 2 3 4  ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key)    假设 开发项目为 HUGO_blog 部署的项目为 redisread.github.io\n   打开HUGO_blog仓库的settings，再点击Secrets，然后添加刚刚生成的私钥，name为ACTIONS_DEPLOY_KEY\n  同理，打开redisread.github.io，点击Deploy keys，添加公钥，Allow write access一定要勾上，否则会无法提交\n  然后，你就可以提交代码了，push成功后，打开仓库actions，至此部署成功，大功告成！\n","description":"Guide to set Hugo site.","id":56,"section":"posts","tags":["Hugo","Github"],"title":"Hugo配置","uri":"https://vhope.cf/zh/posts/hugo/first/"},{"content":"使用Github+PicGo建立一个免费的个人图床。\nPicGo介绍 PicGo是一款图片上传的工具，目前支持微博图床，七牛图床，腾讯云，又拍云，GitHub等图床\n在Github创建图床 创建Repository 生成一个Token用于操作GitHub repository 步骤如下:\n{% note warning %}\n注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存\n{% endnote %}\n配置PicGo 下载PicGo Windows用户下载exe文件\n配置图床    设定仓库名的时候，是按照“账户名/仓库名的格式填写”\n  分支名统一填写“master”\n  将之前的Token黏贴在这里\n  存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹\n  自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/用户名/RepositoryName/分支名，，自定义域名需要按照这样去填写\n   快捷键及相关配置  这里配置上传快捷键为ctrl+shift+c\n 使用 经过上面的配置就大功告成了，每次截图之后，只需要ctrl+shift+c一下就可以把剪切板上面的截图转化为在线网络图片链接。\n","description":"","id":57,"section":"posts","tags":["PicGo","Github","图床"],"title":"配置基于Github的PicGo图床","uri":"https://vhope.cf/zh/posts/settings/image-bed/"},{"content":"写在源文件中的源代码是人类可读的源。它需要\u0026quot;编译\u0026rdquo;，转为机器语言，这样 CPU 可以按给定指令执行程序。C 语言编译器用于把源代码编译成最终的可执行程序。🐤\n安装 首先,到：https://sourceforge.net/projects/mingw-w64/files/latest/download，下载最新版本的 MinGW 安装程\n然后，运行 Download mingw-get-setup.exe ,点击\u0026quot;运行\u0026rdquo;，continue等，注意记住安装的目录，之后需要配置环境变量，例如D:\\MinGW\\bin\n假如网速不好，可以通过下面的链接进行离线下载，下载完成之后使用7Zip解压，然后把解压的文件移动到安装路径即可。\nhttps://pan.baidu.com/s/1W4fHsUeaw1C9vp1lvRygbw\n注：使用这种方式下面的步骤不需要执行了，已经在离线包中集成了。可直接输入gcc -v查看gcc版本。\n 验证安装：\n在开始菜单中，点击\u0026quot;运行\u0026rdquo;，输入 cmd,打开命令行:输入 mingw-get,如果弹出 MinGw installation manager 窗口，说明安装正常，然后关闭窗口。\n安装GCC等编译器 在cmd中输入如下命令进行安装：\n安装gcc\n1  mingw-get install gcc   安装g++\n1  mingw-get install g++   安装gdb\n1  mingw-get install gdb   使用 在桌面创建一个hello.c的程序\n1 2 3 4 5 6 7 8 9  #include \u0026lt;iostream\u0026gt;using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   在 cmd 中输入命令\n1  gcc hello.c   在当前目录下(记住是命令的当前目录)会生成 a.exe 的可执行文件，在 cmd 中输入 a.exe 就可以执行程序了。\n","description":"","id":58,"section":"posts","tags":["gcc","MinGW"],"title":"windows下gcc的安装和使用","uri":"https://vhope.cf/zh/posts/settings/gcc-windows/"},{"content":"我是一个不够严谨的程序员🙉.\n我喜欢📖,还有🏓.\n或许有时候我想的不够远，但是有时候我想的很深入。\n我最喜欢的 Aaron Swartz 语录:\n 在长大的过程中，我才慢慢发现，我身边的所有事，别人跟我说的所有事，那些所谓本来如此，注定如此的事，它们其实没有非得如此，事情是可以改变的。更重要的是，有些事既然错了，那就该做出改变。\n我对学校十分失望，我觉得老师们根本不懂自己所讲的是什么，他们居高临下，管这管那；作业就像是种把戏，就好像知识一种强制所有学生一起庸庸碌碌的手段。于是我就开始去阅读那些关于教育史和这套教育体系演变的书籍。然后你就能发现，如果要真正学到东西，那就不能机械重复老师所教的，这有点儿使得我渐渐学会了质疑。我质疑我所上的学校，我质疑简历这所学校的这个社会，我质疑学校教人们追求的那套事理，我质疑建立起这整个体系的政府。\n我总是深入思考，我希望别人也能想远一点。我为理想而工作，并从别人身上学习，我不喜欢拒人于外。我是个完美主义者，但我不会要求出版界也精益求精。除了教育和娱乐以外，我不会浪费时间在那些不会有影响的事情上。我试着和每个人都友好相处，但我讨厌人们不认真对待我。我不记恨他人，因为这于创造无益。但我从自身经历中学习，我想让世界变得更美好。\n我深深地觉得，光安生与当下这世界是不够的，那样子知识别人给什么你就照收，大人们说什么你就照做，你照着父母说的去做，照着社会说的去做。我觉得你应该总持有质疑，我觉得从科学的角度看，你所学的一切都知识暂时性的，任何所学都有改口、驳斥、质疑的余地。我觉得这情况对社会也适用。当我意识到社会上有着我能尽份力去解决的真正严重的、基础性的问题时，我没法去遗忘它、回避它。\n ","description":"Zzo about page","id":59,"section":"","tags":null,"title":"About","uri":"https://vhope.cf/zh/about/"},{"content":"Markdownify box This is boxmd shortcode Simple box This is **box** shortcode  Code tabs Make it easy to switch between different code\njava javascript  1  System.out.println(\u0026#39;Hello World!\u0026#39;);     1  console.log(\u0026#39;Hello World!\u0026#39;);       'use strict'; var containerId = JSON.parse(\"\\\"642b4352e05d9e04\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Tabs for general purpose Windows MacOS Ubuntu  Windows section 1  console.log(\u0026#39;Hello World!\u0026#39;);   ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n MacOS section Hello world!  Ubuntu section Great!    'use strict'; var containerId = JSON.parse(\"\\\"f09fb25fccaa3686\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Expand   Expand me  Title contents     Expand me2  Title2 contents2   Alert Colored box\nthis is a text this is a text this is a text this is a text Notice success text  info text  warning text  error text  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":60,"section":"posts","tags":["shortcode"],"title":"Shortcodes","uri":"https://vhope.cf/zh/posts/hugo/shortcodes/"},{"content":"A Short Video：  ——以下 Aaron Swartz的宣言，我想这才是信息革命的真谛——\n信息就是力量。但就像所有力量一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 Reed Elsevier 这样的出版商大把钱。\n有人努力去改变这种状况。开放访问运动 (Open Access Movement) 奋勇斗争，确保科学家们没有将他们的版权签署给别人，而是将他们的成果发布到网络上，允许任何人访问它们。但即便是最好的情况，他们的行为也只作用于未来发布的东西。之前的都将失去。\n这样的代价实在太高。强制学者付钱以阅读他们同行的成果？扫描整个图书馆却只允许 Google 的人阅读它们？提供科学文章给那些第一世界的精英大学，却不给身在南半球的儿童？这实在蛮横且无法接受。\n“我同意，”有些人就说了，“但是我们能做什么呢？那些公司握有版权，他们靠限制访问赚取大把的钱，而且这是完全合法的 - 我们没有办法阻止他们。”但有些事我们能做，这些事我们已经在做：我们可以反击。\n那些能够访问这些资源的人 - 学生，图书管理员，科学家 - 你们被赋予了特权。你们能享受到这知识的盛宴，而其他人却被排除在外。但是你们不必 - 事实上，从道义层面来说，你们不能 - 为保留自己保留这份特权。你们有义务和全世界分享它。而且你们已经在做了：和同行们交换密码，回应朋友们的下载请求。\n同时，那些被拒之门外的人们并没有袖手旁观。你们溜过洞穴，翻越围墙，解放那些被出版商封锁的信息并分享给你的朋友们。\n但所有这些行动都是在黑暗中进行，隐藏于地底。它们被称作偷窃或盗版，仿佛分享大量的知识精神上等同于抢劫一艘船只并谋杀其船员。但是分享绝非不道德的，它是一种道德使命。只有那些利欲熏心的人才会拒绝让朋友复制一份。\n大公司，当然，就是利欲熏心。使它们运转的法律要求使然 - 稍微出点事投资人就得叛乱。它们收买的政治家们支持它们，通过法案让它们拥有专属的权力决定谁可以复制。\n遵从不公正的法律不会带来公正。步入光明的时候到了，在公民不服从的伟大传统下，宣告我们对这种私人盗窃公共文化的反抗。\n我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。\n只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？\n亚伦·斯沃茨 (Aaron Swartz)\n2008 年 7 月，意大利 Eremo\nInformation is power. But like all power, there are those who want to keep it for themselves. The world\u0026rsquo;s entire scientific and cultural heritage, published over centuries in books and journals, is increasingly being digitized and locked up by a handful of private corporations. Want to read the papers featuring the most famous results of the sciences? You\u0026rsquo;ll need to send enormous amounts to\npublishers like Reed Elsevier.\nThere are those struggling to change this. The Open Access Movement has fought valiantly to ensure that scientists do not sign their copyrights away but instead ensure their work is published on the Internet, under terms that allow anyone to access it. But even under the best scenarios, their work will only apply to things published in the future. Everything up until now will have been lost.\nThat is too high a price to pay. Forcing academics to pay money to read the work of their colleagues? Scanning entire libraries but only allowing the folks at Google to read them? Providing scientific articles to those at elite universities in the First World, but not to children in the Global South? It\u0026rsquo;s outrageous and unacceptable.\n\u0026ldquo;I agree,\u0026rdquo; many say, \u0026ldquo;but what can we do? The companies hold the copyrights, they make enormous amounts of money by charging for access, and it\u0026rsquo;s perfectly legal - there\u0026rsquo;s nothing we can do to stop them.\u0026rdquo; But there is something we can, something that\u0026rsquo;s already being done: we can fight back.\nThose with access to these resources - students, librarians, scientists - you have been given a privilege. You get to feed at this banquet of knowledge while the rest of the world is locked out. But you need not - indeed, morally, you cannot - keep this privilege for yourselves. You have a duty to share it with the world. And you have: trading passwords with colleagues, filling download requests for friends.\nMeanwhile, those who have been locked out are not standing idly by. You have been sneaking through holes and climbing over fences, liberating the information locked up by the publishers and sharing them with your friends.\nBut all of this action goes on in the dark, hidden underground. It\u0026rsquo;s called stealing or piracy, as if sharing a wealth of knowledge were the moral equivalent of plundering a ship and murdering its crew. But sharing isn\u0026rsquo;t immoral - it\u0026rsquo;s a moral imperative. Only those blinded by greed would refuse to let a friend make a copy.\nLarge corporations, of course, are blinded by greed. The laws under which they operate require it - their shareholders would revolt at anything less. And the politicians they have bought off back them, passing laws giving them the exclusive power to decide who can make copies.\nThere is no justice in following unjust laws. It\u0026rsquo;s time to come into the light and, in the grand tradition of civil disobedience, declare our opposition to this private theft of public culture.\nWe need to take information, wherever it is stored, make our copies and share them with the world. We need to take stuff that\u0026rsquo;s out of copyright and add it to the archive. We need to buy secret databases and put them on the Web. We need to download scientific journals and upload them to file sharing networks. We need\nto fight for Guerilla Open Access.\nWith enough of us, around the world, we\u0026rsquo;ll not just send a strong message opposing the privatization of knowledge - we\u0026rsquo;ll make it a thing of the past.\nWill you join us?\nAaron Swartz\nJuly 2008, Eremo, Italy\n","description":"","id":61,"section":"talks","tags":[""],"title":"My Awesome links","uri":"https://vhope.cf/zh/talks/mylinks/"},{"content":"Sample images about life.\n","description":"my gallery","id":63,"section":"gallery","tags":[""],"title":"life","uri":"https://vhope.cf/zh/gallery/life/"},{"content":"between 70 and 240 in movies\ngood movies！🎥\n","description":"my gallery","id":64,"section":"gallery","tags":[""],"title":"movie","uri":"https://vhope.cf/zh/gallery/movie/"},{"content":"一个测试视频:  ","description":"","id":68,"section":"talks","tags":[""],"title":"B站视频","uri":"https://vhope.cf/zh/talks/blibli/"},{"content":"UE编辑器下模拟使用HitProxy 需要从 UGameViewportClient 类继承 修改返回值为true,路径：\\Source\\Runtime\\Engine\\Private\\GameViewportClient.h\n1  virtual bool RequiresHitProxyStorage() override { return true; }   在FViewportClient类中新建DrawHitProxy函数 文件UnrealClient.h\n在GameViewportClient类中声明并且实现 声明：\\Source\\Runtime\\Engine\\Private\\GameViewportClient.h\n将GameViewportClient类中的函数Draw()内容复制到该函数DrawHitProxy，修改下面的的地方：\n修改FViewport类中的GetRawHitProxyData函数 在GetRawHitProxyData函数中进行以下的修改：Engine\\Source\\Runtime\\Engine\\Private\\UnrealClient.cpp\n调用\u0026ndash;获取屏幕坐标Hitproxy 相关类型 HHitProxy：用于检测用户界面命中的基类\nFHitProxyMap：从2D坐标到缓存命中代理的地图。\n参考：\n How to select an actor in-game using GetHitProxy? UE4 编辑器的光标拾取 编辑器Viewport窗口中的鼠标拾取原理 场景基本对象 渲染总流程 https://docs.unrealengine.com/zh-CN/Programming/Rendering/MeshDrawingPipeline/index.html Unreal Mesh Drawing源码分析 白袍笑道  ","description":"","id":69,"section":"posts","tags":null,"title":"","uri":"https://vhope.cf/zh/posts/ue/ue-hitproxy/"}]